<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="../images/spider-man.webp">
  <title>C/C++ 知识总结（更新中） | 心之所向便是光</title>
  <meta name="author" content="Ender" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="前言&amp;emsp;&amp;emsp;关于 C&#x2F;C++ 知识体系的总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++ 知识总结（更新中）">
<meta property="og:url" content="http://ender-coder.github.io/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="心之所向便是光">
<meta property="og:description" content="前言&amp;emsp;&amp;emsp;关于 C&#x2F;C++ 知识体系的总结。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ender-coder.github.io/images/spider-man.webp">
<meta property="article:published_time" content="2021-08-06T13:11:00.000Z">
<meta property="article:modified_time" content="2021-09-02T08:05:45.881Z">
<meta property="article:author" content="Ender">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ender-coder.github.io/images/spider-man.webp">
<meta name="twitter:site" content="@undefined">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  <script src="//cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fas fa-home fa-fw"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fas fa-folder fa-fw"></i>归档</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fas fa-comments fa-fw"></i>友链</a></li>
                                    
                                
                                    
                                        <li><a href="/about"><i class="fas fa-paper-plane fa-fw"></i>关于</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">心之所向便是光</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>心之所向便是光</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        <section class="col-md-8">
    <article>
        <div class="kratos-hentry kratos-post-inner clearfix">
            <header class="kratos-entry-header">
                
                    <h1 class="kratos-entry-title text-center">C/C++ 知识总结（更新中）</h1>
                
                
                <ul class="kratos-post-meta text-center">
                    <li><i class="fas fa-calendar-alt"></i> 2021-08-06</li>
                    <li><i class="fas fa-user"></i> 作者 Ender</li>
                    <li>
                        <i class="fas fa-edit"></i> 
                        
                        
                            19.16K
                        
                        字
                    </li>
                    
                        <li id="/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="leancloud_visitors" data-flag-title="C/C++ 知识总结（更新中）">
                            <i class="fas fa-eye"></i>
                            <span class="leancloud-visitors-count"> </span> 次阅读
                        </li>
                        
                    
                </ul>
            </header>
            <div class="kratos-post-content">
                <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                    本文最后编辑于 <time datetime="1630569945881"></time> 前，其中的内容可能需要更新。
                </div>
                
                    <div class="kratos-post-inner-toc">
                        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-number">2.</span> <span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">数据类型与声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">关键字和标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">常量与变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">static 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">const 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">extern 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">volatile 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">基本词法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">引用与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">4.3.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">4.3.3.</span> <span class="toc-text">this 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-%E5%92%8C-free-%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">malloc 和 free 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-delete-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.4.2.</span> <span class="toc-text">new 和 delete 操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%A5%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">基本句法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E3%80%81%E5%88%A4%E6%96%AD%E3%80%81%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.</span> <span class="toc-text">赋值、判断、循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">5.2.1.</span> <span class="toc-text">内存对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.3.1.</span> <span class="toc-text">inline 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.4.3.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.4.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.5.</span> <span class="toc-text">struct 和 class 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.</span> <span class="toc-text">命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">高级语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.1.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.1.1.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.1.2.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.3.</span> <span class="toc-text">I&#x2F;O 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">C++ 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">C 和 C++ 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">7.2.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.2.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">7.2.2.</span> <span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">7.3.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">7.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">7.6.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">7.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.2.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.3.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">模板编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">C++ 标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E5%AE%B9%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">STL 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E7%9A%84-sort-%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">STL 的 sort 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.5.</span> <span class="toc-text">适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11"><span class="toc-number">9.</span> <span class="toc-text">C++ 11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.1.</span> <span class="toc-text">auto 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">9.2.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-ptr"><span class="toc-number">9.2.1.</span> <span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-number">9.2.2.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">9.2.3.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-number">9.2.4.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.4.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.5.</span> <span class="toc-text">Lambda 表达式</span></a></li></ol></li></ol>
                    </div>
                
                <hr />
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;关于 <strong>C/C++</strong> 知识体系的总结。<br><span id="more"></span></p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul>
<li>基本语法<ul>
<li>数据类型与声明</li>
<li>关键字和标识符</li>
<li>常量与变量</li>
<li>运算符</li>
<li>表达式</li>
</ul>
</li>
<li>基本词法<ul>
<li>数组</li>
<li>字符串</li>
<li>各种指针</li>
<li>引用</li>
<li>内存管理</li>
</ul>
</li>
<li>基本句法<ul>
<li>赋值、判断、循环</li>
<li>结构体</li>
<li>函数</li>
<li>类和对象</li>
<li>命名空间</li>
</ul>
</li>
<li>高级语法<ul>
<li>类型转换</li>
<li>异常处理</li>
<li>I/O 设计</li>
<li>文件操作</li>
<li>多线程</li>
</ul>
</li>
<li>C++ 编程<ul>
<li>C 和 C++ 的区别</li>
<li>运算符重载</li>
<li>深拷贝与浅拷贝</li>
<li>封装</li>
<li>继承</li>
<li>多态</li>
<li>模板编程</li>
</ul>
</li>
<li>C++ 标准库<ul>
<li>STL 容器</li>
<li>仿函数</li>
<li>迭代器</li>
<li>适配器</li>
</ul>
</li>
<li>C++ 11<ul>
<li>auto 关键字</li>
<li>智能指针</li>
<li>右值引用</li>
<li>列表初始化</li>
<li>Lambda 表达式</li>
</ul>
</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="数据类型与声明"><a href="#数据类型与声明" class="headerlink" title="数据类型与声明"></a>数据类型与声明</h3><ul>
<li>基本数据类型<ul>
<li>bool 布尔型</li>
<li>char 字符型</li>
<li>int 整型</li>
<li>float 浮点型</li>
<li>double 双精度浮点型</li>
<li>void 无类型</li>
<li>wchar_t 宽字符型</li>
</ul>
</li>
<li>类型修饰符（一些基本类型可以使用一个或多个类型修饰符进行修饰）<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
</li>
<li>变量声明<ul>
<li><code>type variable_list;</code></li>
<li><code>type variable_name = value;</code></li>
</ul>
</li>
</ul>
<h3 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h3><ul>
<li>常用关键字<ul>
<li>上面提到的基本数据类型和类型修饰符</li>
<li>class / struct / union 类 / 结构体 / 联合体</li>
<li>const / static / extern / volatile 变量修饰符</li>
<li>return 函数返回</li>
<li>true / false 布尔值真 / 假</li>
<li>if / else / switch / case / default 条件语句</li>
<li>for / while / do / continue / break 循环语句</li>
<li>enum 枚举类型</li>
<li>try / throw / catch 异常处理</li>
<li>new / delete 动态内存分配</li>
<li>using / namespace 命名空间</li>
<li>nullptr 空指针</li>
<li>sizeof 返回数据对象所占空间大小</li>
<li>public / protected / private 访问说明符</li>
<li>template / typename 模板类</li>
<li>virtual 虚类</li>
<li>typedef 类型别名</li>
<li>operator 运算符重载</li>
</ul>
</li>
<li>标识符<ul>
<li>标识符是程序员给变量、类、函数或其他实体的唯一名称。</li>
<li>标识符命名规则<ul>
<li>标识符可以由字母，数字和下划线字符组成。</li>
<li>它对名称长度没有限制。</li>
<li>它必须以字母或下划线开头。</li>
<li>区分大小写。</li>
<li>我们不能将关键字用作标识符。</li>
</ul>
</li>
<li>我们应该为有意义的标识符提供有意义的名称。</li>
</ul>
</li>
</ul>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><ul>
<li>变量<ul>
<li>在编程中，变量是用于保存数据的容器（存储区）。</li>
<li>为了表示存储区域，应该为每个变量赋予唯一的名称（标识符）。</li>
<li>变量的值可以更改。</li>
</ul>
</li>
<li>字面量<ul>
<li>字面量用于表示固定值的数据。它们可以直接在代码中使用。</li>
<li>整型字面量、浮点字面量、字符字面量、转义字符字面量、字符串字面量。</li>
</ul>
</li>
<li>常量<ul>
<li>我们使用 const 关键字来定义一个常量。</li>
<li>我们还可以使用 #define 预处理器指令创建常量。</li>
<li>常量的值不能更改。</li>
</ul>
</li>
</ul>
<h4 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h4><ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，表示该函数属于一个类而不是属于此类的任何特定对象，类和对象不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
<h4 id="const-关键字的作用"><a href="#const-关键字的作用" class="headerlink" title="const 关键字的作用"></a>const 关键字的作用</h4><ul>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
<li>const 的指针与引用<ul>
<li>指针<ul>
<li>指向常量的指针（pointer to const）<code>const type* p;</code></li>
<li>自身是常量的指针（常量指针，const pointer）<code>type* const p;</code></li>
</ul>
</li>
<li>引用<ul>
<li>指向常量的引用（reference to const）<code>const type&amp; p;</code></li>
<li>没有 const reference，因为引用只是对象的别名，不是对象，不能用 const 修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="extern-关键字的作用"><a href="#extern-关键字的作用" class="headerlink" title="extern 关键字的作用"></a>extern 关键字的作用</h4><ul>
<li>extern 用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</li>
<li>extern 声明不是定义，即不分配存储空间。</li>
<li>我们也可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。为什么还要使用 extern 关键字呢？因为用 extern 引用另一个文件的范围更小，会加速程序的编译过程，这样能节省时间。</li>
<li>在 C++ 中 extern 还有另外一种作用，用于指示 C 或者 C++ 函数的调用规范。比如在 C++ 中调用 C 库函数，就需要在 C++ 程序中用 <code>extern &quot;C&quot;</code> 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用 C 函数规范来链接。主要原因是 C++ 和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</li>
</ul>
<h4 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h4><ul>
<li>C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的内存屏障。</li>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。</li>
<li>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li>
<li>一般说来，volatile 用在如下的几个地方：<ul>
<li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li>
<li>多任务环境下各任务间共享的标志应该加 volatile；</li>
<li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义。</li>
</ul>
</li>
<li>volatile 并不能保证线程安全，因为 volatile 并不能保证变量操作的原子性。</li>
</ul>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul>
<li>作用域是程序的一个区域，一般来说有三个地方可以定义变量：<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量。</li>
</ul>
</li>
<li>局部变量：只能被函数内部或者代码块内部的语句使用。</li>
<li>全局变量：<ul>
<li>全局变量的值在程序的整个生命周期内都是有效的。</li>
<li>全局变量可以被任何函数访问。全局变量一旦声明，在整个程序中都是可用的。</li>
<li>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。</li>
</ul>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>运算符类型<ul>
<li>算术运算符：+、-、*、/、%、++、—</li>
<li>赋值运算符：=、+=、-+、*=、/=、%=</li>
<li>关系运算符：==、!=、&gt;、&lt;、&gt;=、&lt;=</li>
<li>逻辑运算符：&amp;&amp;、||、!</li>
<li>按位运算符：&amp;、|、^、~、&lt;&lt;、&gt;&gt;</li>
<li>其他运算符：sizeof、?:、,、.、-&gt;、&amp;（地址）、*（指针）</li>
</ul>
</li>
</ul>
<h2 id="基本词法"><a href="#基本词法" class="headerlink" title="基本词法"></a>基本词法</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h3 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul>
<li>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</li>
<li>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。</li>
<li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
<li>引用很容易与指针混淆，它们之间有三个主要的不同：<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
</li>
<li>把引用作为参数：C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</li>
<li>把引用作为返回值：可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</li>
</ul>
<h4 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h4><ul>
<li>this 指针是隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为 ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为 const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。</li>
<li>在以下场景中，经常需要显式引用 this 指针：<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 list。</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="malloc-和-free-函数"><a href="#malloc-和-free-函数" class="headerlink" title="malloc 和 free 函数"></a>malloc 和 free 函数</h4><ul>
<li>在 C 语言中只能通过 malloc() 和其派生的函数进行动态的申请内存，而实现的根本是通过系统调用实现的。free() 函数释放由其分配的内存。</li>
<li>malloc 函数是从堆里面获得了空间。</li>
<li>此外，堆中的内存块总是成块分配的，并不是申请多少字节，就拿出多少个字节的内存来提供使用。堆中内存块的大小通常与内存对齐有关。</li>
<li>free(p) 释放的是指针变量 p 所指向的内存，而不是指针变量 p 本身。指针变量 p 并没有被释放，仍然指向原来的存储空间，这时候 p 是个野指针。</li>
</ul>
<h4 id="new-和-delete-操作符"><a href="#new-和-delete-操作符" class="headerlink" title="new 和 delete 操作符"></a>new 和 delete 操作符</h4><ul>
<li>new 和 delete 是 C++ 中关于管理内存的操作符。</li>
<li>malloc / free 只是动态分配内存空间 / 释放空间。而 new / delete 除了分配空间还会调用构造函数和析构函数进行初始化与清理（清理成员）。</li>
<li>它们都是动态管理内存的入口。</li>
<li>malloc / free是 C/C++ 标准库的函数，new / delete 是 C++ 操作符。</li>
<li>malloc / free 需要手动计算类型大小且返回值为 void*（需要进行强制类型转换），new / delete 可自动计算类型的大小，返回对应类型的指针。</li>
<li>malloc / free 管理内存失败会返回 0，new / delete 等的方式管理内存失败会抛出异常。</li>
<li>实际上 new 和 delete 只是 malloc 和 free 的一层封装。</li>
<li>他们都需要配套使用。</li>
</ul>
<h2 id="基本句法"><a href="#基本句法" class="headerlink" title="基本句法"></a>基本句法</h2><h3 id="赋值、判断、循环"><a href="#赋值、判断、循环" class="headerlink" title="赋值、判断、循环"></a>赋值、判断、循环</h3><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><ul>
<li>结构体中可以存放不同类型的数据，它的大小也不是简单的各个数据成员大小之和，限于读取内存的要求，而是每个成员在内存中的存储都要按照一定偏移量来存储，根据类型的不同，每个成员都要按照一定的对齐数进行对齐存储，最后整个结构体的大小也要按照一定的对齐数进行对齐。</li>
<li>对齐规则<ul>
<li>第一个成员在与结构体变量偏移量为 0 的地址。</li>
<li>其他成员变量要对齐到对齐数（对齐数 = 编译器默认的一个对齐数与该成员大小的较小值）的整数倍的地址处。</li>
<li>Linux 中默认对齐数为 4，vs 中的默认值为 8。</li>
<li>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）。</li>
<li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍，结构体的整体大小就是所有最大对齐数的整数倍（含嵌套结构体的对齐数）。</li>
</ul>
</li>
<li>对齐特点：<ul>
<li>每个成员的偏移量 % 自己的对齐数 = 0。</li>
<li>结构体整体大小 % 所有成员最大对齐数 = 0。</li>
<li>结构体的对齐数是自己内部成员的对齐数中的最大对齐数。</li>
</ul>
</li>
<li>为什么要内存对齐？<ul>
<li>平台移植型好。</li>
<li>CPU 处理效率高。</li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="inline-关键字"><a href="#inline-关键字" class="headerlink" title="inline 关键字"></a>inline 关键字</h4><ul>
<li>为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</li>
<li>引入内联函数的主要原因是用它替代 C 中表达式形式的宏定义。</li>
<li>宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受 C++ 编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</li>
<li>在 C++ 中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将 this 指针放在合适的位置）。</li>
<li>inline 的使用是有所限制的，inline 只适合函数体简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数。</li>
<li>inline 对于编译器只是一个建议，编译器会根据实际情况选择是否设置当前函数为内联函数。</li>
</ul>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>定义一个类（class），本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</li>
<li>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。</li>
<li>类成员函数：指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</li>
<li>构造函数：一种特殊的函数，在创建一个新的对象时调用。</li>
<li>析构函数：一种特殊的函数，在删除所创建的对象时调用。</li>
<li>拷贝构造函数：一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</li>
<li>友元函数：可以访问类的 private 和 protected 成员。</li>
<li>内联函数：通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</li>
<li>指向类的指针：如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</li>
</ul>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul>
<li>构造函数<ul>
<li>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</li>
<li>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值。</li>
</ul>
</li>
<li>析构函数<ul>
<li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</li>
</ul>
</li>
<li>构造函数不能是虚函数。<ul>
<li>若构造函数是虚的，则需要通过虚函数表来调用，若对象还未实例化，即还未分配内存空间，无法找到虚函数表。</li>
<li>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数就没有实际意义。</li>
</ul>
</li>
<li>析构函数应当是虚函数。<ul>
<li>析构时将调用相应对象类型的析构函数。</li>
<li>如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</li>
</ul>
</li>
</ul>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li>public：公有成员。任何位置都可以访问。</li>
<li>protected：保护成员。只有类自己和子类的成员函数以及友元函数才能访问。</li>
<li>private：私有成员。只有类自己的成员函数和友元函数才能访问。</li>
<li>C++ 的限定符是限定类的，不是限定对象的，只要是类型相同就能相互访问。</li>
</ul>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><ul>
<li>类的友元函数是定义在类外部，但有权访问类的所有私有成员和保护成员的函数。</li>
<li>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</li>
<li>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</li>
<li>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。</li>
</ul>
<h4 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h4><ul>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
<li>总的来说，struct 更适合看成是数据结构的实现体，class 更适合看成是对象的实现体。</li>
</ul>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。</li>
<li>在 C++ 中，变量、函数和类都是大量存在的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。</li>
<li>命名空间的定义使用关键字 namespace，后跟命名空间的名称。<ul>
<li><code>namespace name &#123; // 代码声明 &#125;</code></li>
</ul>
</li>
<li>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称。  <ul>
<li><code>name::code;  // code 可以是变量或函数</code></li>
</ul>
</li>
<li>可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。<ul>
<li>如 <code>using namespace std;</code> 使用 C++ 标准库。</li>
</ul>
</li>
</ul>
<h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><ul>
<li>当运算符的操作数具有不同的数据类型时，C++ 会自动将它们转换为相同的数据类型。</li>
<li>当一个值被转换为更髙的数据类型时，称之为升级。反之，降级则意味着将其转换为更低的数据类型。</li>
<li>char、short 和 unsigned short 值自动升级为 int 值。</li>
<li>当运算符使用不同数据类型的两个值时，较低排名的值将被升级为较高排名值的类型。</li>
<li>当表达式的最终值分配给变量时，它将被转换为该变量的数据类型。</li>
<li>如果接收值的变量的数据类型低于接收的值，值将被降级为变量的类型。如果变量的数据类型没有足够的存储空间来保存该值，则该值的一部分将丢失。</li>
<li>当变量值的数据类型更改时，它不会影响变量本身。</li>
</ul>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li>static_cast<ul>
<li>用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。</li>
<li><code>static_cast &lt;type_id&gt; (expression)</code>。</li>
<li>用于类层次结构中基类和派生类之间指针或引用的转换。<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示），是安全的。</li>
<li>进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</li>
<li>只能在有相互联系的类型中进行相互转换，不一定包含虚函数。</li>
</ul>
</li>
<li>用于基本数据类型之间的转换。这种转换的安全需要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针。</li>
<li>把任何类型的表达式转换为 void 类型。</li>
<li>static_cast 不能转换掉表达式的 const、volitale 或者 __unaligned 属性。</li>
</ul>
</li>
<li>const_cast<ul>
<li>用来移除变量的 const 或 volatile 限定符。</li>
<li><code>const_cast &lt;type_id&gt; (expression)</code>。</li>
<li>不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</li>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li>
<li>经过转换并修改值之后，常量的值不会被修改，指针取值会修改，而它们指向的地址是相同的。（这里我黑人问号，不是很懂为什么会这样，找到的资料都是说这样是无奈之举，并没有说为什么可以地址一样值不一样。）</li>
<li>移除 const 限定后通过指针修改值是一种未定义行为，具体操作取决于编译器。</li>
<li>所以说，这种用法最好只用在迫不得已的地方（比如函数参数类型不一样，只能转换），尽量不要去修改值。</li>
</ul>
</li>
<li>reinterpret_cast<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h3 id="I-O-设计"><a href="#I-O-设计" class="headerlink" title="I/O 设计"></a>I/O 设计</h3><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h2 id="C-编程"><a href="#C-编程" class="headerlink" title="C++ 编程"></a>C++ 编程</h2><h3 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C 和 C++ 的区别"></a>C 和 C++ 的区别</h3><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul>
<li>在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</li>
<li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</li>
</ul>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><ul>
<li>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。</li>
<li>不能仅通过返回类型的不同来重载函数。</li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><ul>
<li>大部分 C++ 内置的运算符都可以被重定义或重载。</li>
<li>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</li>
<li>不可重载的运算符列表：<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>, <code>-&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
</li>
</ul>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。</li>
<li>数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</li>
<li>通常情况下，我们都会设置类成员状态为私有，除非我们真的需要将其暴露，这样才能保证良好的封装性。</li>
<li>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</li>
<li>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</li>
<li>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。</li>
<li>一个派生类继承了所有的基类方法，但下列情况除外：<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
</li>
<li>一般形式：<code>class 派生类名: 访问修饰符 基类名</code>。</li>
<li>如果未使用访问修饰符，则默认为 private。</li>
<li>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：<ul>
<li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>
<li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li>
<li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>多态按字面的意思就是多种形态，可以简答地概括为 “一个接口，多种方法”。调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</li>
<li>静态多态<ul>
<li>静态多态也称为编译时多态。</li>
<li>静态多态通过重载和模板实现。</li>
</ul>
</li>
<li>动态多态<ul>
<li>动态多态也称为运行时多态。</li>
<li>动态多态通过虚函数实现。</li>
</ul>
</li>
</ul>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><ul>
<li>虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。</li>
<li>虚函数指针<ul>
<li>虚函数指针从本质上来说就只是一个指向函数的指针，与普通的指针并无区别。它指向用户所定义的虚函数，具体是在子类里的实现，当子类调用虚函数的时候，实际上是通过调用该虚函数指针从而找到接口。</li>
<li>虚函数指针是确实存在的数据类型，在一个被实例化的对象中，它总是被存放在该对象的地址首位，这种做法的目的是为了保证运行的快速性。与对象的成员不同，虚函数指针对外部是完全不可见的，除非通过直接访问地址的做法或者在 DEBUG 模式中，否则它是不可见的也不能被外界调用。</li>
</ul>
</li>
<li>虚函数表<ul>
<li>每个类的实例化对象都会拥有虚函数指针并且都排列在对象的地址首部。而它们也都是按照一定的顺序组织起来的，从而构成了一种表状结构，称为虚函数表。</li>
<li>虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面，子类覆盖父类的函数直接放到父类函数原来的位置中。</li>
<li>对于多重继承，每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的表中（所谓的第一个父类是按照声明顺序来判断的）。</li>
</ul>
</li>
<li>函数的声明与定义要求非常严格，只有在子函数中的虚函数与父函数一模一样的时候（包括限定符）才会被认为是真正的虚函数，不然的话就只能是重载。这被称为虚函数定义的同名覆盖原则，意思是只有名称完全一样时才能完成虚函数的定义。</li>
</ul>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><ul>
<li>虚函数的定义形式：<code>virtual &#123;method body&#125;</code></li>
<li>纯虚函数的定义形式：<code>virtual &#123; &#125; = 0</code>;</li>
<li>在虚函数和纯虚函数的定义中不能有 static 标识符，原因很简单，被 static 修饰的函数在编译时候要求前期 bind，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li>
<li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li>
<li>虚函数可以被直接使用，也可以被子类重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。</li>
<li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li>
<li>虚函数和纯虚函数通常存在于抽象基类中，被继承的子类重载，目的是提供一个统一的接口。</li>
<li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。</li>
<li>如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。</li>
<li>抽象类的子类也可以是抽象类。</li>
</ul>
<h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><ul>
<li>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</li>
<li>函数模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line">ret-type func-<span class="built_in">name</span> (parameter list) &#123;</span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="keyword">class</span>-<span class="title">name</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h2><h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><h3 id="STL-的-sort-函数"><a href="#STL-的-sort-函数" class="headerlink" title="STL 的 sort 函数"></a>STL 的 sort 函数</h3><ul>
<li>对于STL中的sort()算法：<ul>
<li>当数据量大时，将会采用 Quick Sort（快排），分段递归进行排序。</li>
<li>一旦分段后的数据量小于某个阈值，为了避免快排的递归带来过大的额外的开销，sort()算法就自动改为 Insertion Sort（插入排序）。</li>
<li>如果递归的层次过深，还会改用 Heap Sort（堆排序）。</li>
</ul>
</li>
<li>简单来说，sort并非只是普通的快速排序，除了对普通的快排进行优化，它还结合了插入排序和堆排序。</li>
<li>根据不同的数量级以及不同的情况，能够自动选择合适的排序算法。</li>
</ul>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><h3 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h3><ul>
<li>auto 可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。</li>
<li>auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。</li>
<li>auto 声明的变量必须要初始化，否则编译器不能判断变量的类型。</li>
<li>auto 不能被声明为返回值，不能作为形参，不能被修饰为模板参数。</li>
<li>定义在一个 auto 序列的变量必须始终推导成同一类型。</li>
<li>使用 auto 关键字做类型自动推导时，依次施加以下规则：<ul>
<li>如果初始化表达式是引用，则去除引用语义。</li>
<li>如果初始化表达式为 const 或 volatile（或者两者兼有），则除去 const / volatile 语义。</li>
<li>如果 auto 关键字带上 &amp; 号，则不去除 const 语意。</li>
<li>初始化表达式为数组时，auto 关键字推导类型为指针。</li>
<li>若表达式为数组且 auto 带上 &amp;，则推导类型为数组类型。</li>
</ul>
</li>
</ul>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li>四个智能指针: <code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>。</li>
<li>包含在头文件 <code>&lt;memory&gt;</code> 中</li>
<li>使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</li>
<li>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</li>
<li>所有智能指针都重载了 <code>operator-&gt;</code> 操作符，直接返回对象的引用，用以操作对象。</li>
</ul>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><ul>
<li>C++98的方案，C++11 已经抛弃。</li>
<li>采用所有权模式。</li>
<li><code>operator=</code> 会剥夺先前对象的内存管理所有权。</li>
<li><code>release()</code> 函数不会释放对象，仅仅归还所有权。</li>
<li>缺点是存在潜在的内存崩溃问题。</li>
</ul>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><ul>
<li>实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。</li>
<li>对于避免资源泄露特别有用。</li>
<li>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。</li>
<li>可以通过 <code>move()</code> 函数转让所有权。</li>
<li>可以通过 <code>release()</code> 函数释放所有权。</li>
</ul>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><ul>
<li>实现共享式拥有概念，多个智能指针可以指向相同对象。</li>
<li>使用引用计数来表明资源被几个指针共享，每一个 shared_ptr 的拷贝都指向相同的内存。</li>
<li>每使用它一次，内部的引用计数加 1，每析构一次，内部的引用计数减 1。</li>
<li>该对象和其相关资源会在“最后一个引用被销毁”时候释放。</li>
<li>可以通过成员函数 <code>use_count()</code> 来查看资源的所有者个数。</li>
<li>可以指定类型，传入指针通过构造函数初始化。也可以使用 <code>make_shared()</code> 函数初始化。</li>
<li>不能将指针直接赋值给一个智能指针，一个是类，一个是指针。</li>
<li>注意不要用一个原始指针初始化多个 shared_ptr，否则会造成二次释放同一内存。</li>
<li>share_ptr 智能指针还是有内存泄露的情况，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fas fa-plus"></i></div><span>share_ptr的简单实现</span></div>
    <div class="xContent"><div class="inner">
        <p>作者：code_peak<br>链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindSun/p/11444429.html">https://www.cnblogs.com/WindSun/p/11444429.html</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span> <span class="comment">//为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharePtr</span>(T *p = <span class="number">0</span>) : _ptr(p)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="built_in">Counter</span>();</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in construct &quot;</span> &lt;&lt; cnt-&gt;s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SharePtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharePtr</span>(SharePtr&lt;T&gt; <span class="keyword">const</span> &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in copy con&quot;</span> &lt;&lt; endl;</span><br><span class="line">        _ptr = s._ptr;</span><br><span class="line">        (s.cnt)-&gt;s++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; (s.cnt)-&gt;s &lt;&lt; endl;</span><br><span class="line">        cnt = s.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SharePtr</span>(WeakPtr&lt;T&gt; <span class="keyword">const</span> &amp;w) <span class="comment">//为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in w copy con &quot;</span> &lt;&lt; endl;</span><br><span class="line">        _ptr = w._ptr;</span><br><span class="line">        (w.cnt)-&gt;s++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy w  construct&quot;</span> &lt;&lt; (w.cnt)-&gt;s &lt;&lt; endl;</span><br><span class="line">        cnt = w.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    SharePtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(SharePtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            (s.cnt)-&gt;s++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;assign construct &quot;</span> &lt;&lt; (s.cnt)-&gt;s &lt;&lt; endl;</span><br><span class="line">            cnt = s.cnt;</span><br><span class="line">            _ptr = s._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&lt;</span>T&gt;; <span class="comment">//方便weak_ptr与share_ptr设置引用计数和赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cnt-&gt;s--;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;release &quot;</span> &lt;&lt; cnt-&gt;s &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (cnt-&gt;s &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">if</span> (cnt-&gt;w &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> cnt;</span><br><span class="line">                cnt = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    Counter *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
 
    </div></div>
    </div>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><ul>
<li>为了配合 shared_ptr 而引入的一种智能指针，因为它不具有普通指针的行为，没有重载 <code>*</code> 和 <code>-&gt;</code>,它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况。</li>
<li>weak_ptr 可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造，获得资源的观测权。</li>
<li>weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加。</li>
<li>weak_ptr 可以通过调用 lock 函数来获得 shared_ptr。</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fas fa-plus"></i></div><span>weak_ptr的简单实现</span></div>
    <div class="xContent"><div class="inner">
        <p>作者：code_peak<br>链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindSun/p/11444429.html">https://www.cnblogs.com/WindSun/p/11444429.html</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//给出默认构造和拷贝构造，其中拷贝构造不能有从原始指针进行构造</span></span><br><span class="line">    <span class="built_in">WeakPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WeakPtr</span>(SharePtr&lt;T&gt; &amp;s) : _ptr(s._ptr), <span class="built_in">cnt</span>(s.cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;w con s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cnt-&gt;w++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WeakPtr</span>(WeakPtr&lt;T&gt; &amp;w) : _ptr(w._ptr), <span class="built_in">cnt</span>(w.cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt-&gt;w++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WeakPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            cnt = w.cnt;</span><br><span class="line">            cnt-&gt;w++;</span><br><span class="line">            _ptr = w._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(SharePtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;w = s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        cnt = s.cnt;</span><br><span class="line">        cnt-&gt;w++;</span><br><span class="line">        _ptr = s._ptr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SharePtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SharePtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt-&gt;s &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; cnt-&gt;s &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SharePtr</span>&lt;</span>T&gt;; <span class="comment">//方便weak_ptr与share_ptr设置引用计数和赋值</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt-&gt;w--;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;weakptr release&quot;</span> &lt;&lt; cnt-&gt;w &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; cnt-&gt;s &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//delete cnt;</span></span><br><span class="line">                cnt = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    Counter *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
 
    </div></div>
    </div>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ul>
<li>左值和右值<ul>
<li>左值：英文简写为 lvalue，是 loactor value 的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据。</li>
<li>右值：英文简写为 rvalue，是 read value 的缩写，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</li>
</ul>
</li>
<li>判断某个表达式是左值还是右值的方法。<ul>
<li>可位于赋值号左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ul>
</li>
<li>C++98/03 标准中的引用使用 “&amp;” 表示，正常情况下只能引用左值，无法对右值添加引用。因此这种引用方式也称为左值引用。</li>
<li>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值。</li>
<li>C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</li>
<li>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。</li>
<li>和常量左值引用不同的是，右值引用还可以对右值进行修改。</li>
<li>C++ 语法上是支持定义常量右值引用的，但这种定义出来的右值引用并无实际用处。</li>
<li>移动语义<ul>
<li>我们一般在使用函数管理含有资源的类的时候，一般都需要实现拷贝构造函数和拷贝赋值函数，因为默认的拷贝是浅拷贝，而指针这种资源不能共享，不然会因为指向同一个区域，一个析构了另一个也不能使用。</li>
<li>当我们将一个右值（比如一个字符串）作为函数参数传入时，本来就已经需要构造这个右值了，传进去之后却又要拷贝一遍，并且这个右值只是一个临时对象，拷贝完也没有什么用了，这就造成了很多不必要的资源申请和释放。</li>
<li>实现移动语义需要增加两个函数：移动构造函数和移动赋值构造函数。</li>
<li>移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是常量左值引用，而移动构造的参数是右值引用。</li>
<li>移动构造函数并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为空。</li>
<li>有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11 为了解决这个问题，提供了<code>std::move()</code> 方法来将左值转换为右值，从而方便应用移动语义。</li>
</ul>
</li>
<li>通用引用<ul>
<li>当右值引用和模板结合的时候，<code>T&amp;&amp;</code> 并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。</li>
<li>它是左值引用还是右值引用却决于它的初始化，如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用。</li>
<li>引用折叠<ul>
<li>所有的右值引用叠加到右值引用上仍然使一个右值引用。</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>
</ul>
</li>
</ul>
</li>
<li>完美转发<ul>
<li>所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</li>
<li>c++ 中提供了一个 <code>std::forward()</code> 模板函数将拥有名字的右值依然保持为右值。</li>
<li>配合上面提到的通用引用，我们可以将左值引用、常量左值引用、右值引用、常量右值引用都保持原样转发给另一个函数，也即实现完美转发。</li>
</ul>
</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fas fa-plus"></i></div><span>右值引用例子及理解</span></div>
    <div class="xContent"><div class="inner">
        <p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d19fc8447eaa">https://www.jianshu.com/p/d19fc8447eaa</a></p>
 
    </div></div>
    </div>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><ul>
<li>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</li>
<li>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</li>
<li>Lambda 表达式本质上与函数声明非常类似。</li>
<li>一般形式：<code>[capture](parameters) -&gt; return-type &#123;body&#125;</code></li>
<li><code>[capture]</code> 可能值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      // 沒有定义任何变量。使用未定义变量会引发错误。</span><br><span class="line">[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。</span><br><span class="line">[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br><span class="line">[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br><span class="line">[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br><span class="line">[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></pre></td></tr></table></figure>
</li>
</ul>

            </div>
            
                <div class="kratos-copyright text-center clearfix">
                    <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
                </div>
            
            <footer class="kratos-entry-footer clearfix">
                
                    <div class="post-like-donate text-center clearfix" id="post-like-donate">
                    
                        <a class="donate" href="javascript:;"><i class="fas fa-coffee"></i> 打赏</a>
                    
                    
                        <a class="share" href="javascript:;"><i class="fas fa-share-alt"></i> 分享</a>
                        <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fab fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fas fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fab fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fab fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fab fa-facebook-f"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fab fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://ender-coder.github.io/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://ender-coder.github.io/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/";
            const title         = "「C/C++ 知识总结（更新中）」";
            const excerpt       = `前言&emsp;&emsp;关于 C/C++ 知识体系的总结。`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                    
                    </div>
                
                <div class="footer-tag clearfix">
                    <div class="pull-left">
                    <i class="fas fa-tags"></i>
                        
                    </div>
                    <div class="pull-date">
                    <span>最后编辑：2021-09-02</span>
                    </div>
                </div>
            </footer>
        </div>
        
            <nav class="navigation post-navigation clearfix" role="navigation">
                
                <div class="nav-previous clearfix">
                    <a title=" Leetcode 297.二叉树的序列化与反序列化" href="/2021/08/06/Leetcode 297.二叉树的序列化与反序列化/">&lt; 上一篇</a>
                </div>
                
                
                <div class="nav-next clearfix">
                    <a title=" Leetcode 300.最长递增子序列" href="/2021/08/07/Leetcode 300.最长递增子序列/">下一篇 &gt;</a>
                </div>
                
            </nav>
        
        
            <div id="v-comments" class="post-comments"></div>
<script>
    var load_comm = () => {
        const init = () => {
            new Valine({
                el: '#v-comments',
                appId: 'xViI6ucIqBOwXsIxB7YGyFWu-gzGzoHsz',
                appKey: 'nJvn3U27Xay2sVJ3rXtOj5yB',
                visitor: true,
                enableQQ: true,
                path: '/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/'
            });
        }
        if (typeof Valine == 'undefined') {
            const src = 'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js';
            $.getScript(src, init);
        } else {
            init();
        }
    };
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://valine.js.org/">comments powered by Valine.</a></noscript>

        
    </article>
</section>

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/spider-man.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=1498076242&auto=0&height=66"></iframe></p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fas fa-compass"></i>
        目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-text">数据类型与声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">关键字和标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-text">常量与变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">static 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">const 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">extern 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">volatile 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95"><span class="toc-text">基本词法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">引用与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-text">this 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-%E5%92%8C-free-%E5%87%BD%E6%95%B0"><span class="toc-text">malloc 和 free 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-delete-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">new 和 delete 操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%A5%E6%B3%95"><span class="toc-text">基本句法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E3%80%81%E5%88%A4%E6%96%AD%E3%80%81%E5%BE%AA%E7%8E%AF"><span class="toc-text">赋值、判断、循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">内存对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">inline 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">struct 和 class 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95"><span class="toc-text">高级语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E8%AE%BE%E8%AE%A1"><span class="toc-text">I&#x2F;O 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E7%A8%8B"><span class="toc-text">C++ 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C 和 C++ 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B"><span class="toc-text">模板编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">C++ 标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E5%AE%B9%E5%99%A8"><span class="toc-text">STL 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E7%9A%84-sort-%E5%87%BD%E6%95%B0"><span class="toc-text">STL 的 sort 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11"><span class="toc-text">C++ 11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">auto 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-ptr"><span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fas fa-archive"></i>分类</h4>
    <div class="tab-content">
      <ul class="list-group">
        
          <a class="list-group-item" href="/categories/Leetcode/">
            <i class="fas fa-folder"></i> Leetcode
            <span>98</span>
          </a>
        
          <a class="list-group-item" href="/categories/Project/">
            <i class="fas fa-folder"></i> Project
            <span>1</span>
          </a>
        
          <a class="list-group-item" href="/categories/Test/">
            <i class="fas fa-folder"></i> Test
            <span>1</span>
          </a>
        
          <a class="list-group-item" href="/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">
            <i class="fas fa-folder"></i> 复习资料
            <span>6</span>
          </a>
        
          <a class="list-group-item" href="/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/">
            <i class="fas fa-folder"></i> 智力题
            <span>2</span>
          </a>
        
      </ul>
    </div>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fas fa-tags"></i>标签云</h4>
      <div class="tag-clouds">
        <a href="/tags/BFS/" style="font-size: 0.65em;">BFS</a> <a href="/tags/C/" style="font-size: 0.8em;">C++</a> <a href="/tags/DFS/" style="font-size: 0.72em;">DFS</a> <a href="/tags/Project/" style="font-size: 0.6em;">Project</a> <a href="/tags/set/" style="font-size: 0.6em;">set</a> <a href="/tags/test/" style="font-size: 0.6em;">test</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 0.63em;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 0.77em;">二叉树</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 0.62em;">位运算</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 0.62em;">分治</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.78em;">动态规划</a> <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 0.63em;">单调栈</a> <a href="/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/" style="font-size: 0.67em;">原地算法</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 0.67em;">双指针</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 0.73em;">哈希</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 0.7em;">回溯</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 0.62em;">图论</a> <a href="/tags/%E5%A0%86/" style="font-size: 0.62em;">堆</a> <a href="/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/" style="font-size: 0.6em;">字典序</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 0.6em;">归并排序</a> <a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 0.67em;">快慢指针</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 0.6em;">快速排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 0.63em;">排序</a> <a href="/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/" style="font-size: 0.6em;">摩尔投票</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/" style="font-size: 0.65em;">数学方法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.63em;">数据结构</a> <a href="/tags/%E6%A0%88/" style="font-size: 0.63em;">栈</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 0.63em;">滑动窗口</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size: 0.6em;">程序设计</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 0.63em;">贪心</a> <a href="/tags/%E8%BF%AD%E4%BB%A3/" style="font-size: 0.68em;">迭代</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 0.75em;">递归</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 0.65em;">队列</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
    <h4 class="widget-title"><i class="fas fa-folder"></i>最新文章</h4>
    <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2021/09/04/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"><i class="fas fa-file-alt"></i> 智力题：赛马问题</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"><i class="fas fa-file-alt"></i> 操作系统原理 知识总结</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/08/24/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A12%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/"><i class="fas fa-file-alt"></i> 智力题：12 硬币问题</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/08/19/Leetcode%20739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"><i class="fas fa-file-alt"></i> Leetcode 739.每日温度</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/08/18/Leetcode%20647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"><i class="fas fa-file-alt"></i> Leetcode 647.回文子串</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
    </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer">
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fas fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fas fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fas fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <li><a href="" title="1422112890"><i class="fab fa-qq fa-fw"></i></a></li>
                        <li><a href="" title="Ender0u0"><i class="fab fa-weixin fa-fw"></i></a></li>
                        
                        <li><a href="mailto:1422112890@qq.com" title="1422112890@qq.com"><i class="fas fa-envelope fa-fw"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://www.instagram.com/Ender0u0" title="Ender0u0"><i class="fab fa-instagram fa-fw"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Ender-coder" title="Ender-coder"><i class="fab fa-github fa-fw"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://www.zhihu.com/people/ender-95-27" title="Ender"><i class="fab fa-zhihu fa-fw"></i></a></li>
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li><i class='fas fa-fan fa-spin fa-fw'></i> 努力运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos-Rebirth</a></li>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                        <div>
                            <li>&copy; 2021 Ender 版权所有.</li>
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.js"></script>
    </div>

<script async src="/js/candy.js"></script>


    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.js"></script>
<script defer src="/js/pjax.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/layui-src@2.5.5/dist/layui.all.js"></script>


    <script defer src="/js/kr-dark.js"></script>



<!-- Extra support for third-party plguins  -->

    <script>
    // Initialize
    const init = () => {
        mermaid.initialize({theme: 'dark'});
    };
    const reload = () => {
        mermaid.init(undefined, ".mermaid");
    };
    if (typeof mermaid == 'undefined') {
        const src = 'https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js';
        $.getScript(src, init);
    }
    // Set PJAX callback function
    window.addEventListener('pjax:complete', reload);
</script>


    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>