[{"title":"Leetcode 146.LRU 缓存机制","date":"2021-07-03T15:21:00.000Z","url":"/2021/07/03/Leetcode%20146.LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例： 提示： $1 &lt;= capacity &lt;= 3000$ $0 &lt;= key &lt;= 3000$ $0 &lt;= value &lt;= 10^4$ 最多调用 $3 * 10^4$ 次 get 和 put 链接： 题目分析&emsp;&emsp;LRU 也即 Least Recently Used，最近最少使用。顾名思义，最近最少使用的结点会从缓存删去，那么怎么判断哪个结点是最近没有被使用到的呢？我们可以维护一个双向链表作为缓存，越靠近头部表示上一次被使用的时间越近，如果一个结点被使用，就将其移动到链表头部（没有则也是添加到头部），而如果缓存区已满，则删除链表末尾的结点。而我们怎么快速找到结点呢？题目说明了每个结点具有不同的关键字，则我们可以使用一个哈希表来存储结点的指针。所以我们采用的是一个双向链表加一个哈希表的数据结构。（PS：为什么要使用双向链表而不是单向链表呢？因为我们需要频繁地从链表中删除结点（包括移动操作和删除操作），使用双向链表才可以在定位后对前后进行连接操作。&emsp;&emsp;从实现的细节上来说，我们经常操作的是链表的头结点和尾结点，为了避免多次判定链表是否为空（链表为空时添加的新结点既是头结点也是尾结点），我们使用了两个哨兵结点，分别作为伪头部和伪尾部。&emsp;&emsp;各操作的作用已经包含到代码的注释中。 &emsp;&emsp;时间复杂度：$O(1)$。哈希表的查询是 $O(1)$ 的，各项操作也都是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(capacity)$。我们需要建立哈希表和双向链表，他们的最大大小都是 $O(capacity)$ 的。"},{"title":"Leetcode 142.环形链表II","date":"2021-07-03T13:37:00.000Z","url":"/2021/07/03/Leetcode%20142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶：你是否可以使用 O(1) 空间解决此题？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目范围在范围 $[0, 10^4]$ 内 $-10^5 &lt;= Node.val &lt;= 10^5$ pos 的值为 -1 或者链表中的一个有效索引 链接： 题目分析&emsp;&emsp;这道题是 Leetcode 141.环形链表 的进阶，在判断链表是否有环的基础上还需要返回环的开始结点。我们在那道题中采用的是快慢指针的做法，这道题应该可以使用的方法，但是我们需要解决一个问题：怎么获得环开始的结点？我们知道，快指针的速度是慢指针的两倍，而它们是同时出发的，则快指针走的路程也是慢指针的两倍。我们分析它们走过的路程是什么样的。如下图所示。蓝色的点是它们的相遇点。 &emsp;&emsp;则我们可以知道，快指针走过的路程应该是 $a+n(b+c)+b$，而慢指针走过的路应该是 $a+b$。而快指针走过的路程是慢指针的两倍，则我们可以得到下面的等式 a+n(b+c)+b=2(a+b)&emsp;&emsp;通过变换我们可以得到 $a=c+(n-1)(b+c)$，则我们可以发现，在快慢指针的相遇点出发，走 c 步就刚好到了环的入口，而链表头部到环入口的距离（也即 a），就是从相遇点到环入口加上 n-1 个环（也即 b+c）的距离。则我们可以在快慢指针相遇后，令一个新的指针从 head 出发，与慢指针同时前进，经过了 a 的单位时间后，他们的相遇点就是环的入口。&emsp;&emsp;需要注意的是，当时在做前一道题的时候，我们使用的是 while 循环，让快慢指针先走了一步，它们的出发点不是 head，因此他们的相遇点也不会是上面分析的那样。这道题我们使用了上一道题提到过的 do-while 循环，将出发点修改为 head。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为链表的长度。我们知道快慢指针相遇所需要的时间是 $O(n)$，而相遇后慢指针和新指针走的路程为 a，也不会超过 $n$。因此复杂度仍然是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要三个指针的空间。"},{"title":"Leetcode 141.环形链表","date":"2021-06-29T16:20:00.000Z","url":"/2021/06/30/Leetcode%20141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目范围是 $[0, 10^4]$ $-10^5 &lt;= Node.val &lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 链接： 题目分析&emsp;&emsp;这道题也是一个典型的题目，可以使用快慢指针解决。我们知道，如果链表中存在环，则按照链表的顺序走，最终会在环里面一直转圈。所以如果按照链表顺序走能够走到终点（走到 nullptr）则说明链表不存在环。而如果我们使用两个指针同时在链表中行走，快指针一次走两步，而慢指针一次走一步，则如果存在环，快指针会比慢指针先进入环中并开始转圈，当慢指针也进入环后，它们会在环中的某一个节点相遇，此时快指针“套”了慢指针若干圈。（为什么一定会相遇？因为它们的速度差是 1，则每一次前进，它们之间的步数差增加 1，而当它们同时处于环中并且步数差是环长的整数倍时，它们就相遇了）因此如果快慢指针相遇，则说明存在环。&emsp;&emsp;一些细节：快指针一次走两步，在走之前需要判断 fast 和 fast-&gt;next 是否为空，避免非法访问。为空时其实也说明不存在环，可以直接返回 false。出发时，快指针在 head-&gt;next 而慢指针在 head，这是由于我们循环的终止条件是两个指针相遇，如果它们的出发点是相同的则不会进入循环。其实我们也可以理解为它们是在 head 之前才是起跑线，第一次行走时慢指针到 head 而快指针已经到了 head-&gt;next，如果使用一个 do-while 循环则可以从 head 起跑。由于它们在同一位置起跑，如果链表不存在环，则快指针一定先于慢指针到达终点，因此退出条件只设置快指针即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为链表的长度。当不存在环时，快指针到达终点就结束，每个结点至多被访问两次；当存在环时，至多行走了 $n$ 步慢指针就会进入环，而两个指针都进入环之后，至多行走 $n$ 步快慢指针就会相遇。因此复杂度都是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个指针的空间。"},{"title":"Leetcode 139.单词拆分","date":"2021-06-29T15:26:00.000Z","url":"/2021/06/29/Leetcode%20139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 示例 2： 示例 3： 链接： 题目分析&emsp;&emsp;字典中的单词不会重复，并且可以重复使用，我们可以考虑使用一个哈希表存储这个字典。而对于字符串 s，我们用动态规划的思想，dp[i] 表示 s 的前 i 个字母 s[0 ~ i-1] 是否可以使用字典中的单词表示，则我们知道，如果 dp[j] 为真，并且 s[j ~ i-1] 刚好是字典中的一个单词，则 dp[i] 也为真。而 dp[0] 作为起始条件，表示空串的结果为真。对于每一个 dp[i]，我们都要遍历 dp[0] ~ dp[i-1]，寻找以这个位置分割是否符合条件，一旦符合条件则可以置为真并提前退出遍历。遍历所有的 dp[i] 之后，我们的答案就是 dp[s.size()]。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 为字符串的长度。动态规划的状态数为 $n+1$，而对于每个状态最多都要枚举 $O(n)$ 个分割点，其实也即双层遍历，时间复杂度为 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(n+k)$，其中 $n、k$ 分别为字符串的长度与字典的大小。动态规划数组大小为 $n+1$，而哈希表大小为 $k$。 &emsp;&emsp;PS：这道题还存在优化空间，比如如果字典中的单词量较少，内层循环也可以设计成匹配字典中每个单词的形式；比如可以进行剪枝，内层循环中分割的位置无需从 0 开始，可以从字典中最长的单词长度作为右半部分开始。"},{"title":"Leetcode 136.只出现一次的数字","date":"2021-06-29T13:49:00.000Z","url":"/2021/06/29/Leetcode%20136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","tags":[["C++","/tags/C/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 非空 整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;很经典的一道题，以前已经做过，知道这道题的骚套路，这里需要用到的是位运算中的异或运算。首先异或运算有以下几个特点 一个数与 0 异或还是它本身，也即 $0\\oplus a = a$。 一个数与本身异或的结果为 0，也即 $a\\oplus a = 0$。 异或运算满足交换律与结合律，也即 $a\\oplus b = b\\oplus a$，$a\\oplus(b\\oplus c)=(a\\oplus b)\\oplus c$。 &emsp;&emsp;在这个题目中，有一个数字出现了一次，其他数字都出现了两次。如果我们将 0 与所有的数字异或一次，则出现了两次的数字得到的结果会变为 0，最后留下的就是 0 与出现了一次的那个数字的异或结果，也即留下的就是只出现了一次的那个数字。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们遍历了一次数组。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要使用一个变量记录异或结果。 &emsp;&emsp;如果没有这么骚的解法，其实也有很多其他需要额外空间但仍然是线性时间复杂度的解法，比如维护一个哈希表记录每个数字出现的次数；或者是将未在哈希表中的数字加入，而已经存在的数字删除，最后留下的也是那个只出现了一次的数字；或者利用元素和，分别记录出现的数字以及数组的数字和，这个和再加上那个只出现过一次的数字得到的结果应该是所有出现过的数字和的两倍。"},{"title":"Leetcode 128.最长连续序列","date":"2021-06-29T13:18:00.000Z","url":"/2021/06/29/Leetcode%20128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","tags":[["C++","/tags/C/"],["set","/tags/set/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？ 示例 1： 示例 2： 提示： $0 &lt;= nums.length &lt;= 10^4$ $-10^9 &lt;= nums[i] &lt;= 10^9$ 链接： 题目分析&emsp;&emsp;阅读示例后发现，题目所说的连续序列只需要数字的值连续，而不需要在数组中相对有序，更不需要连续出现，则某个数在数组中只有 “存在” 与 “不存在” 两种状态，它的个数、位置都是没有影响的，我们可以考虑使用一个 set 容器来存放这些数（为什么不用 unordered_set 呢？因为我们同时也需要对这些数进行排序）。&emsp;&emsp;存放所有的数后，我们只需要对 set 进行一次遍历，每次寻找数字的值是否连续，并维护一个 count 进行计数，一旦不连续则重置，寻找下一个连续序列，与此同时记录最大的序列长度即可。代码中的 result 用于存放最大序列长度（也即结果），count 用于序列长度计数，pre 用于存放遍历的上一个值（用于比较）。重置的时候是重置为 1 （也即已经算上当前的这个数）。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 为数组的大小。我们遍历了一次数组存入 set 容器中，每一个数的存入需要 $O(\\log n)$，再遍历一次 set 找到答案。&emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们需要一个 set 容器来存放数组中出现的所有数字，最大的大小为 $n$。 &emsp;&emsp;PS：进阶要求的时间复杂度是 $O(n)$，但是我看了官方题解仍然觉得是 $O(n\\log n)$，并没有更好的算法了吧。看了官方题解的评论，大概是说最优情况下是 $O(n)$，那倒确实&emsp;&emsp;PPS：所以好像直接对原数组排序一遍再遍历更省事更快，还不需要那么多的额外空间…"},{"title":"Leetcode 124.二叉树中的最大路径和","date":"2021-06-29T07:31:00.000Z","url":"/2021/06/29/Leetcode%20124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 示例 2： 提示： 树中节点数目范围是 $[1, 3*10^4]$ $-1000 &lt;= Node.val &lt;= 1000$ 链接： 题目分析&emsp;&emsp;由于同一个节点在一条路径序列中至多出现一次，则某条路径中有且只有一个根结点，既可以是根结点作为路径端点，也可以是根结点连接来自左右子树的两个子路径。我们可以这样考虑，当一个结点作为根结点时，最大路径和即为左右子树中的最大子路径和（不超过 0 可以不要）加上结点本身的值。这样的话这个定义是递归的，结果应该可以通过递归遍历所有结点得到。&emsp;&emsp;但是存在着一个问题，我们需要计算的结果是一个结点连接左右子序列形成的序列和，而我们递归需要调用的子序列只能是以根结点作为端点的序列。如示例2，以结点 20 作为根结点的最大序列和是 [15, 20, 7]，但是当我们计算结点 -10 时，来自右子树 20 的子序列只能是 [20, 15] 或者是 [20, 7]。如果解决这个不同呢？由于我们要求的只是所有序列和中最大的那个，则我们可以使用一个全局变量存储最大序列和，而递归函数的返回值则是以这个结点为端点的最大序列和，以提供给上层函数使用。&emsp;&emsp;需要注意的是，结点值可以为负数，且必须至少选择一个结点，则有可能最终的最大路径和是负数，因此 result 的初始值需置为 INT_MIN 而不是 0。另外一个注意的点上面也已经提到，我们不一定要连接左右子序列，如果最大的左右子序列是负数的话，我们可以选择不连接。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。递归的最大深度为 $n$。 官方题解&emsp;&emsp;与我的代码有一点小小的不同（PS：第一次困难题（PPS：这题其实有点简单不像是困难题）自己有思路，在完全没看官方题解的前提下居然写出了几乎一样的代码，连全局变量的使用也一样，有点神奇），官方题解在计算 left 和 right 的值时就已经与 0 进行比较，下面更新 result 和函数返回值的时候就无需进行比较。在我的代码里，left 和 right 表示最大子序列和，可以为负数；在官方题解里，它们表示的含义变成了子树的 “贡献度”，如果子序列和为负数则不进行连接，贡献度为 0。 "},{"title":"Leetcode 121.买卖股票的最佳时机","date":"2021-06-25T19:02:00.000Z","url":"/2021/06/26/Leetcode%20121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 示例 2： 提示： $1 &lt;= prices.length &lt;= 10^5$ $0 &lt;= prices[i] &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;卖股票需要在买股票之后，如果我们卖股票的那一天为 i，则需要在 [0 ~ i-1] 天买入股票，买入股票的价格越低越好。我们可以动态维护一个 min 表示当前的最低价格，而当天卖出股票能赚的钱也即 prices[i] - min，如果 prices[i] 比 min 更小则可以更新 min 值。遍历数组得到 prices[i] - min 的最大值即可。这也算是一种动态规划的思想吧。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是 prices 的大小。我们进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 114.二叉树展开为链表","date":"2021-06-25T15:15:00.000Z","url":"/2021/06/25/Leetcode%20114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你二叉树的根结点 root ，请你将它展开为一个单链表。 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？ 示例 1： 示例 2： 示例 3： 提示： 树中结点数在范围 [0, 2000] 内 -100 &lt;= Node.val &lt;= 100 链接： 题目分析1.前序遍历&emsp;&emsp;如果先不考虑进阶的要求，我们可以直接按照先序遍历的顺序遍历一次二叉树，将其所有结点逐一添加到数组中，然后再逐一进行连接。（如果采用迭代的方法遍历二叉树则还可以边遍历边连接） &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历一次二叉树，重新连接了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们需要一个大小为 $n$ 的数组存放二叉树结点。 2.寻找前驱结点&emsp;&emsp;进阶的要求如何达到呢？我们如果能够直接在原树进行连接，则不需要额外空间。最终的树是按照前序遍历的顺序逐一连接到右子树中的，而前序遍历的顺序是 [根结点 左子树 右子树]。如果当前结点左子树为空，则与最终结果一样，无需进行操作。如果当前结点左子树不为空，则当前结点右子树应该是在左子树访问完毕后才进行访问，这个时候，右子树的前驱结点应该就是左子树的最右叶子。我们寻找到这个前驱结点，并将当前结点的右子树作为前驱结点的右子树连接，同时将当前结点的左子树变为右子树。如此处理所有的结点。&emsp;&emsp;如下面例子（第一棵树）所示，1 有左子树，我们找到左子树的最右叶子 4，并将 1 的右子树 [5, 6] 连接到 4 之后，如第二棵树所示。然后再将左子树根结点 2 变为 1 的右子树，如第三棵树所示。这个时候就处理好了 1 这个结点，接下来以同样的流程处理 2 这个结点。如第四第五颗树所示。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对于每个结点都需要访问一次进行处理，而寻找前驱结点的过程中每个结点至多被访问一次。&emsp;&emsp;空间复杂度：$O(1)$。这个算法为原地算法，我们只需要常数的空间存放若干变量。"},{"title":"Leetcode 105.从前序与中序遍历序列构造二叉树","date":"2021-06-25T05:50:00.000Z","url":"/2021/06/25/Leetcode%20105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。 注意：你可以假设树中没有重复的元素。 例如，给出 返回如下的二叉树： 链接： 题目分析1.迭代&emsp;&emsp;我们知道，在前序遍历中，结点的顺序按照 [根结点 左子树 右子树] 的顺序排列。则在连续的两个结点之间的关系只有两种情况，一种是后面结点是前面结点的左孩子，一种是后面结点是前面结点本身或者某个祖先的右孩子。而这两情况，可以通过中序遍历加以区分。中序遍历中，结点的排列是按照 [左子树 根结点 右子树] 进行排列的，若是第一种情况，则两种遍历的顺序相反，第二种情况则相同。并且第二种情况中是哪个祖先的右子树呢？其实就是前序遍历和中序遍历不再相反的那一个结点，也即局部的根结点。结合这样的数据特点，我们选择栈这种数据结构。栈中存放的结点是 还没考虑过右孩子的结点。&emsp;&emsp;我们使用一个 inorderIndex 来表示当前中序遍历的下标。我们按前序遍历的顺序作为循环，前序遍历的第一个结点就是根结点，加入到栈中。开始检查栈顶结点是否是当前中序遍历的结点，如果不是，也即意味着是第一种情况，前序遍历到的结点是栈顶结点的左孩子（这个左孩子会比栈顶结点更早出现于中序遍历中，因此栈顶结点不会是当前中序遍历的结点），连接到树中，并将其入栈；如果是，则说明是第二种情况，这个时候我们要找到是哪个祖先的右孩子，开始出栈，同时中序遍历下标也开始右移，不断比对直到栈为空或者栈顶结点不再是中序遍历的结点，则说明该结点是栈顶结点的右子树了。上面说的两种情况可能有点复杂，我们用下面的树进行理解。 &emsp;&emsp;中序遍历的第一个数字是 4。前序遍历中 1 为根，2 是第一种情况，也即是 1 的左孩子（可以采用反证法，如果不是，则 2 只能为 1 的右孩子，且左孩子为空，这个时候中序遍历一定是 1 开始的）。同理，在前序遍历遇到 4 之前的所有数字都要入栈，也即栈中为 [1, 2, 3, 4]。&emsp;&emsp;遇到 4 之后，我们可以知道，4 是最左的孩子了。那么前序遍历的下一个数字 5 是哪个祖先的右孩子呢？在中序遍历中，这个祖先的右孩子是比祖先的祖先更早出现的（因为他们在祖先的祖先的左孩子中），因此我们找到中序遍历中比栈更早出现的结点即可。我们将 4 出栈；inorderIndex 右移，栈顶为 3，中序遍历也为 3，继续出栈；栈顶为 2，中序遍历为 2，继续出栈；栈顶为 1，而中序遍历为 6。这个时候，我们可以知道，6 就是在 2 的右孩子中了（2 是祖先，1 是祖先的祖先，6 所在的子树比 1 更早出现，是 2 的右孩子）。而前序遍历到的结点 5 就是 2 的右孩子的根（前序遍历的根最早出现），所以可以直接将其连接到 2 的右孩子中，然后将 5 入栈。&emsp;&emsp;这个时候的栈是 [1, 5]。又可以继续上面的过程，6 不是 5，是第一种情况，也即 5 的左孩子，连接并入栈。重复以上的过程就可以得到最终的答案。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对前序遍历和中序遍历都进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。栈的最大元素个数为 $n$。 2.递归&emsp;&emsp;我们知道，前序遍历的结构是 [根结点, [左子树的前序遍历], [右子树的前序遍历]]，中序遍历的顺序是 [[左子树的中序遍历], 根结点, [右子树的中序遍历]]。可以发现，他们的定义是递归的，并且这三块中的内容也具有对应关系，左子树的前序遍历和中序遍历构造的树就是根结点的左子树，右子树同理。因此我们应该可以使用一个递归函数解决这个问题。&emsp;&emsp;递归的关键就是找到这三块内容的分界线。很容易可以想到利用根结点进行划分。前序遍历的第一个结点就是根结点，而我们在中序遍历中就可以根据根结点的值找到根结点的位置，划分好中序遍历后，再根据左子树序列的长度，可以划分前序遍历。为了提升寻找中序遍历中根结点的位置速度，我们给中序遍历建立了一个值和结点位置对应的哈希表。&emsp;&emsp;递归函数的返回值是一棵树，我们利用根结点新建结点，再递归调用函数建立左子树和右子树，然后向上层返回根结点即可。递归中止的条件也即结点为空。&emsp;&emsp;preorder[preLeft ~ preRight] 和 inorder[inLeft ~ inRight] 分别表示了前序遍历和中序遍历的区间。（代码是为了便于理解，实际上没有用到 inRight） &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对中序遍历行了一次遍历建立哈希表，而在递归的过程中实际我们对前序遍历和中序遍历进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。哈希表的大小为 $n$，递归栈的最大深度也为 $n$。"},{"title":"Leetcode 104.二叉树的最大深度","date":"2021-06-23T10:14:00.000Z","url":"/2021/06/23/Leetcode%20104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","tags":[["C++","/tags/C/"],["BFS","/tags/BFS/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 链接： 题目分析1.广度优先搜索&emsp;&emsp;从 Leetcode 102.二叉树的层序遍历 我们可以很容易想到这个算法。层序遍历题目中对于每一层都需要新开一行进行存储，直接改成计数即可，代码比层序遍历更简单。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。 2.深度优先搜索&emsp;&emsp;搜索树的深度其实更常用的是深度优先搜索，只需要一个递归的过程即可完成，每一个结点从左右子树中选择深度更深的一边并加上自身往上返回即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。空间复杂度取决于栈的深度。在最坏情况下（树是一条链）栈的深度会达到 $n$，最好情况下（树是平衡的）则是 $O(\\log n)$。"},{"title":"Leetcode 102.二叉树的层序遍历","date":"2021-06-23T09:36:00.000Z","url":"/2021/06/23/Leetcode%20102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["C++","/tags/C/"],["BFS","/tags/BFS/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 返回其层序遍历结果： 链接： 题目分析&emsp;&emsp;我们知道，二叉树的层序遍历跟广度优先搜索的过程是一样的，所用到的数据结构都是队列。每次将队头出列，并将其左右子结点加入队尾，这样即可以按照层次的顺序得到二叉树的结果。但是阅读示例可以发现，返回的结果是二维的数组，不同层次之间需要隔开，怎么分隔呢？我们可以在每一层的开始先检查队列中的元素个数，然后按照这个数目进行循环，循环结束也即该层遍历结束。下一层的时候重复这个过程即可，直到队列为空则遍历结束。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。所有结点各入队一次出队一次。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。"},{"title":"Leetcode 101.对称二叉树","date":"2021-06-23T08:46:00.000Z","url":"/2021/06/23/Leetcode%20101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，检查它是否是镜像对称的。 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 链接： 题目分析1.递归&emsp;&emsp;什么样的树是镜像对称的？对应的结点值相同，并且他们的左右子树也刚好对称。这个定义是递归的，因此我们可以使用一个递归函数 check 来检查两个树是否对称。结点同时为空则对称，若同时不为空，则需满足结点值相同，并且左右子树互相对称。而我们只需要检查根结点的左右子树是否满足这样的对称树即可。这样的遍历是前序遍历。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历了二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。也即栈空间的最大深度。 2.迭代&emsp;&emsp;迭代算法可以模拟递归的过程。我们维护一个队列，队列中的每两个结点是对应的结点。每次检查时从队头出列两个结点，判断他们是否同时为空或者是值相同，并且将他们的左右子树按照对称关系两两加入到队列中。直到队列为空也即遍历所有的结点，仍然符合的话则为对称树。这样的遍历是层序遍历。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历了二叉树。每个结点最多进队一次，出队一次。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。"},{"title":"Leetcode 98.验证二叉搜索树","date":"2021-06-22T17:16:00.000Z","url":"/2021/06/23/Leetcode%2098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;我们知道二叉搜索树按照中序遍历的话得到的一定是升序序列。则我们根据中序遍历检查是否满足升序序列即可。我们维护了一个 pre 表示已经遍历过的最后一个结点的值，而当前结点的值必须大于 pre，出现不满足的结点则可以直接返回 false。遍历完这个结点后，我们更新 pre 的值为当前结点值。&emsp;&emsp;注意到题目中结点值 val 是 int 类型的，最小可以达到 INT_MIN（测例中真的有一个 INT_MIN）。我们设置的哨兵值要比这个值还小，因此采用了 long 类型，并赋初始值为 LONG_MIN。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。我们最多对二叉搜索树进行了一次中序遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。也即递归栈的深度，而当二叉树是一条链时，最大深度为 $n$。"},{"title":"Leetcode 96.不同的二叉搜索树","date":"2021-06-22T16:31:00.000Z","url":"/2021/06/23/Leetcode%2096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 19 链接： 题目分析&emsp;&emsp;二叉搜索树也即中序遍历是一致的（升序序列）。我们分析一下结点数为 n 时，有几种不同的情况呢？我们设根结点为第 i 个数，则在 i 的左边的所有数构成左子树，右边所有的数构成右子树。我们设结点数为 n 的二叉搜索树种数为 $f(n)$，那么其实左子树的种数就为 $f(i-1)$，右子树的种数为 $f(n-i)$。而我们一共可以有 n 个数可以成为根结点，也即有如下递推公式，其中 $f(0)=1$。 f(n)=\\sum^n_{i=1}f(i-1)*f(n-i)&emsp;&emsp;这其实就是我们曾经接触过的卡特兰数。而第 $n$ 个卡特兰数计算公式为 $\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}$。需要注意的是必须使用 long long int 类型才不会越界。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。计算卡特兰数用到了一个 $O(n)$ 的循环。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放变量。"},{"title":"Leetcode 94.二叉树的中序遍历","date":"2021-06-22T14:26:00.000Z","url":"/2021/06/22/Leetcode%2094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树的根节点 root ，返回它的 中序 遍历。 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 链接： 题目分析1.递归解法&emsp;&emsp;非常容易想到的解法，也即按照 左子树-根结点-右子树 的顺序递归遍历二叉树即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。我们遍历了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。也即栈的深度，而当二叉树是一条链时，最大深度为 $n$。 2.迭代解法&emsp;&emsp;其实我们需要做的就是将递归的栈显式地模拟出来。寻找左结点之前将根结点压栈，直到最左的结点，然后将栈顶出栈并加入到结果中，然后开始遍历右子树。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。我们遍历了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。也即栈的大小。"},{"title":"Leetcode 85.最大矩形","date":"2021-06-22T12:45:00.000Z","url":"/2021/06/22/Leetcode%2085.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":[["C++","/tags/C/"],["单调栈","/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： rows == matrix.length cols == matrix[0].length 0 &lt;= row, cols &lt;= 200 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 链接： 题目分析&emsp;&emsp;做这道题之前先看看与之关联的上一道题 Leetcode 84.柱状图中最大的矩形。我们可以发现，如果我们按照每一列的顺序维护 heights，就可以复用上一题的代码。就像下面这样。这样是可以遍历所有可能存在的矩形的，因此得到的答案就是最终答案。&emsp;&emsp;PS：下面的代码中 largestRectangleArea 函数来自上一题，使用的是单调栈的做法，具体过程可以参阅上一题题解。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是矩阵的行数和列数。我们遍历矩阵的一行进行一次处理，而处理的函数时间复杂度是 $O(n)$。因此总的时间复杂度就是 $O(mn)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是矩阵的列数。因为我们需要维护一个 heights 数组，大小为 $O(n)$，并且进行处理的 largestRectangleArea 函数也需要 $O(n)$ 的栈空间。"},{"title":"Leetcode 84.柱状图中最大的矩形","date":"2021-06-17T12:44:00.000Z","url":"/2021/06/17/Leetcode%2084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","tags":[["C++","/tags/C/"],["单调栈","/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 链接： 题目分析&emsp;&emsp;通过观察我们可以知道，对于每一个柱子，都有以它为高的矩形存在，我们只需要遍历所有这样的矩形即可得到最大矩形。每一个矩形的宽边界是哪里呢？是这个柱子两边低于它的第一个柱子。获取这个信息并不需要每次都进行遍历，我们只需要使用单调栈的做法。按照从左到右的顺序遍历，我们维护一个升序的柱子序列，则对于栈顶的柱子，它的左边界就是栈中的前一个柱子，而当我们遍历到某个柱子不符合升序序列，也即比栈顶元素小时，它就是栈顶矩形的右边界。这个时候就可以计算以栈顶为高的矩形的大小了。并且计算后可以将其出栈，这是因为它是目前遍历过的柱子中最高的值，不会对其他矩形产生影响。出栈后，如果这个柱子仍然比新的栈顶小，则仍需要继续这个过程，因此我们使用的是 while 循环。结束过程之后，我们要将这个柱子进栈。&emsp;&emsp;对于连续两个同样高度的柱子是怎么处理的呢？以它们为高的矩形应该是一样的，因此我们只需要计算其中一个即可。两个都加入栈中的话，右边那个的左边界会被认为是左边这个，因此计算得到的矩形面积会比实际小，左边那个的计算则不会受到影响。我们的结果是要求最大的矩形面积，因此偏小的那个不会对最终结果造成影响。由此可知，我们可以直接将同样高度的也加入到栈中。&emsp;&emsp;栈中存放的信息是什么？我们需要知道柱子的高度，也即矩形的高；而柱子的宽度是以它的左右边界的下标差来计算的，因此我们也需要知道柱子的下标。因此我们有两种方法，一种是直接存放柱子的下标，每次需要用到柱子高度时再通过柱子下标查询高度；另外一种是直接用一个 pair 将这两个信息存放进去。&emsp;&emsp;这个题目对于边界是怎么处理的？我们可以利用哨兵的技巧。也即在柱子序列两边添加一个高度为 0 的柱子，这样就可以直接处理边界的柱子了。可是数组不能有下标为 -1 的情况，heights[-1] 是非法的，因此我采用的是 pair 的做法，最开始就在栈中直接添加了一个 &#123;-1, 0&#125;，表示下标为 -1 的柱子高度为 0。这样的好处是栈永远不会为空，并且这个哨兵可以处理其作为左边界的情况。对于右边界的哨兵就更简单了，直接在数组最后添加一个 0 表示一个高度为 0 的柱子即可，这样到最后可以处理掉栈中剩余的所有柱子，只留下两个哨兵。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是柱子的数量。我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是柱子的数量。也即栈的开销。"},{"title":"Leetcode 79.单词搜索","date":"2021-06-17T10:41:00.000Z","url":"/2021/06/17/Leetcode%2079.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","tags":[["C++","/tags/C/"],["DFS","/tags/DFS/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例 1： 示例 2： 示例 3： 提示： m == board.length n = board[i].length 1 &lt;= m, n &lt;= 6 1 &lt;= word.length &lt;= 15 board 和 word 仅由大小写英文字母组成 链接： 题目分析&emsp;&emsp;这道题是在一个二维的表格中寻找一个单词，由于每次搜索的格子是相邻的，我们很容易可以想到 DFS（深度优先搜索）的方法。因为题目要求结点不能重复使用，我们使用一个和 board 同样大小的布尔数组 use 来标记结点是否已经被使用。我们从符合 word[0] 的某个单元格开始搜索，每次往某个方向搜索，如果这个方向的邻结点还没有被使用，并且符合我们需要的下一个字母（word[index]），则从这个结点进行下一层的搜索。当我们搜索到 word 的尽头仍然可以找到符合的字母时，则说明这个单词 word 存在于 board 中，直接返回 true，不再进行搜索。如果当前方向搜索不到则进行回溯，将标记为已使用的单元格还原为未使用，继续进行其他方向的搜索。如果经历了所有的搜索都无法找到，则结果为 false。需要注意的是，初始的 use 需要全部标记为未使用。 &emsp;&emsp;时间复杂度：$O(mn\\times3^L)$，其中 $m、n、L$ 分别为 board 的行数、列数和 word 的长度，这是一个比较宽松的上界。我们最多对整个 board 的所有单元格作为起点进行搜索，除了起点，每次搜索最多只有三个方向可以搜索（上一个结点的方向已经被使用），最大搜索长度是单词的长度。我们对于已使用的单元格或者是不符合的字母都是不会进行搜索的，有了这些剪枝实际上的时间复杂度会远远小于这个上界。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别为 board 的行数和列数。我们建立了一个 $m\\times n$ 的数组用于标记某个单元格是否已经使用。而 DFS 最大的搜索深度为单词的长度或者是搜满 board，也即 $O(\\min(L,mn))$。因此总的空间复杂度为 $O(mn)$。"},{"title":"Leetcode 78.子集","date":"2021-06-17T09:31:00.000Z","url":"/2021/06/17/Leetcode%2078.%E5%AD%90%E9%9B%86/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 示例 2： 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 链接： 题目分析&emsp;&emsp;对于 nums 中的每个数，选择或者不选择都是两种不同的情况，也即幂集的个数为 $2^n$。我们可以使用回溯的方法，不选择 nums[i] 进行递归，得到一种结果后回溯，选择 nums[i] 进行递归。每次遍历完 nums[i] 即得到一个结果，将其加入到结果数组中。 &emsp;&emsp;时间复杂度：$O(n\\times2^n)$，其中 $n$ 为 nums 数组的大小。因为总共有 $2^n$ 种结果，而对于每种结果我们需要 $O(n)$ 的时间将其加入到答案中。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为 nums 数组的大小。递归的最大深度为 $n$。"},{"title":"Leetcode 76.最小覆盖子串","date":"2021-06-16T18:33:00.000Z","url":"/2021/06/17/Leetcode%2076.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 进阶：你能设计一个在 $o(n)$ 时间内解决此问题的算法吗？ 示例 1： 示例 2： 提示： $1 &lt;= s.length, t.length &lt;= 10^5$ s 和 t 由英文字母组成 链接： 题目分析&emsp;&emsp;通过观察示例我们可以得知，覆盖 t 并不需要按照顺序，也即 s 的某个子串中只需要包含 t 中的所有字母即可。并且 t 中的字母是可以重复的，比如有两个 &#39;a&#39;，则符合条件的 s 子串也必须包含至少两个 &#39;a&#39;。那么我们可以考虑使用一个哈希表来记录 t 中的所有字母以及它们的个数，作为 s 子串需要满足的 target。&emsp;&emsp;而对于子串的问题，我们可以使用滑动窗口的思想，使用 left 和 right 两个变量记录窗口的边界，并且维护另一个哈希表 now，记录当前子串中各字符的个数，使用一个布尔变量 flag 表示 now 是否能覆盖 target。如果能够覆盖，则 left 右移，缩小窗口；如果不能覆盖，则 right 右移，扩大窗口。这样动态地维护窗口并且记录能够覆盖的最小长度，记录为答案。&emsp;&emsp;需要注意的地方有以下几点。 s 的长度小于 t 的长度时，肯定无法覆盖 t，可以直接返回空串。 left 和 right 都是从 0 开始的，其中 left 处于窗口内，right 处于窗口外，也即子串为 s[left ~ right-1]，长度刚好为 right-left。 即使 right 到了终点，也仍然存在 left 继续右移缩小窗口的可能，因此退出循环条件还必须是子串已经无法覆盖 target（也即 flag 变为 false）。 当 left 右移时（此时 flag 为 true），无需对右移后的整个哈希表进行判断，因为改变的只有 s[left]，还能不能覆盖只取决于 s[left] 的数目会不会因此而变得不足。（实际上，如果维护的是能够满足覆盖的字母种类，right 右移时也可以只检查新添字母之后，该字母数目的增加能否使得满足覆盖的字母种类已经达到了 t 的字母种类。） minlength 记录了最小子串长度，初始值赋为 INT_MAX，如果到最后这个值仍然没有被修改，则说明不存在能够覆盖 t 的子串，按照题目要求返回空串。 &emsp;&emsp;时间复杂度：$O(\\alpha|s|+|t|)$，其中 $\\alpha、s、t$ 分别是字符集的大小、字符串 s 和 t。t 的字符要加入哈希表中，而最坏情况下，s 的所有字符都需要加入哈希表一次、从哈希表删除一次，并且每次加入都需要遍历一次 target 检查是否满足覆盖，而 target 的大小也即字符集的大小。&emsp;&emsp;空间复杂度：$O(\\alpha)$，其中 $\\alpha$ 是字符集的大小。也即两张哈希表的空间开销。"},{"title":"Leetcode 75.颜色分类","date":"2021-06-16T09:41:00.000Z","url":"/2021/06/16/Leetcode%2075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 进阶： 你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 链接： 题目分析1.计数&emsp;&emsp;题目中要求使用原地算法，并且最好不用排序函数，而数字只有三种，我们可以很容易想到使用计数的方法。先遍历一次数组记录 0 和 1 的个数，剩下的就是 2，之后对整个数组进行重写即可。一共需要两次遍历。 2.双指针&emsp;&emsp;由于只有三种数字，最后的结果中 0 一定在左边，2 一定在右边。那我们只进行一次遍历，每次将 0 放到左边，2 放到右边，最后剩下的 1 就都在中间，也就完成了。我们需要两个指针 p0 和 p2 分别指示 0 和 2 的边界位置。&emsp;&emsp;注意我们是从左往右遍历，而 p2 是位于右边，因此与 p2 交换后，i 所指示的位置的新数字依然是没有处理过的，因此 i 不能自增。 3.官方题解&emsp;&emsp;官方题解中还提到了其他同样使用指针的方法。一种是单指针的方法，先遍历一次处理 0（遇到 0 就交换到最左边），再从 0 结束的位置遍历一次处理 1，一共需要两次遍历。 &emsp;&emsp;还有一种是另外一种双指针的方法，记录的是 0 和 1 的边界位置，放入 0 时两个指针同时右移（若有 1 被 0 替换还需在末尾补 1），放入 1 时 p1 右移，这种方法也是一次遍历。 复杂度分析&emsp;&emsp;以上的所有方法不管是两次遍历还是一次遍历，时间复杂度都是 $O(n)$，而作为原地算法，空间复杂度都是 $O(1)$。"},{"title":"Leetcode 72.编辑距离","date":"2021-06-16T08:24:00.000Z","url":"/2021/06/16/Leetcode%2072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 示例 2： 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 链接： 题目分析&emsp;&emsp;我们需要做的是将 word1 转换到 word2，而每一步操作都只涉及到 1 个字母的变化，一共有 3 种操作，也即插入、替换、删除。其中插入和删除的操作比较难以处理，可能会陷入死循环，有没有办法解决呢？其实 word1 的删除操作和 word2 的插入操作是等价的。比如 abcd -&gt; abc，既可以看做是左边删除了一个 d，变成 abc = abc，也可以视为右边添加了一个 d，变成 abcd = abcd，操作步数都是 1，同样能让两个单词相同。因此我们的方法有以下三种 word1 插入一个字符 word2 插入一个字符 word1 替换一个字符 &emsp;&emsp;注意到以上的操作方法次序对结果是没有影响的，因此我们可以从左到右逐步对字符进行操作，便可以使用动态规划的方法解决。我们逐步分析两个字符串，并保留操作次数最少的方法。dp[i][j] 的值表示 word1 的前 i 个字符与 word2 的前 j 个字符进行匹配需要的最少步数（也即它们的编辑距离）。而每次我们只在字符串的最后进行操作。我们分析状态转移方程，也即 dp[i][j] 的值如何确定。 如果最后一步操作是 word1 插入字符，也即进行了 dp[i][j-1] 的操作之后，我们将 word2 的第 j 个字符插入到 word1 最后。 如果最后一步操作是 word2 插入字符，也即进行了 dp[i-1][j] 的操作之后，我们将 word1 的第 i 个字符插入到 word2 最后。 如果最后一步操作是 word1 替换字符，也即进行了 dp[i-1][j-1] 的操作之后，我们将 word1 的第 i 个字符替换为 word2 的第 j 个字符（如果这两个字符本来就是相同的，则无需替换）。 &emsp;&emsp;以上的三种操作中，我们总是选取操作次数最小的那个作为 dp[i][j] 的值进行状态转移，最后就能够得到 dp[m][n] 也即 word1 转换为 word2 的最少操作数。而边界情况是什么样的？边界情况是其中某一个字符串为空的时候，操作数就是另一个字符串的字符数。也即 dp[0][j] = j，word1 为空时，word1 变为 word2 的操作就是往 word1 插入 j 个字符。同理，dp[i][0] = i。&emsp;&emsp;注意字符串的下标是从 0 开始的，因此 word1 的第 i 个字符是 word1[i-1]。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。我们进行了双层遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。也即动态规划所需的数组大小。"},{"title":"Leetcode 70.爬楼梯","date":"2021-06-15T17:03:00.000Z","url":"/2021/06/16/Leetcode%2070.%E7%88%AC%E6%A5%BC%E6%A2%AF/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 示例 2： 链接： 题目分析1.递归&emsp;&emsp;记得这道题是第一次学递归的时候就做的例题。爬 n 阶的楼梯，可以看做是爬了 n-1 阶的楼梯，最后一步再爬 1 个台阶；也可以看做是爬了 n-2 阶的楼梯，最后一步再爬 2 个台阶。而方法数就是这两种方法的和。这便是一个递归的过程，即有 $f(n)=f(n-1)+f(n-2)$。&emsp;&emsp;递归的终结条件是什么呢？还没开始爬的时候 $n=0$ 就是爬楼梯的开始，记为 1 种方法。而 $n=1$ 的时候，前一步只能爬 1 个台阶而不能爬 2 个台阶，因此方法数也是 1。&emsp;&emsp;PS：这种方法会超出时间限制。 &emsp;&emsp;时间复杂度：$O(2^n)$，其中 $n$ 为楼梯的阶数。一共 $n$ 层递归，而每一层递归我们都需要调用两次递归函数。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即递归的深度。 2.动态规划&emsp;&emsp;递归的方法虽然容易理解，代码也十分简洁，但是其实时间复杂度非常高，即使是简单题也是毫不意外地超出了时间限制。这是因为每层递归都会调用两次递归函数，而且这个操作存在的大量的重复计算，比如 $f(n-1)$ 的计算中也需要用到 $f(n-2)$。如何复用这些函数的值呢？我们可以很容易想到动态规划。&emsp;&emsp;与递归相反，我们正向地推导这个过程。上面已经推出了状态转移方程 $f(n)=f(n-1)+f(n-2)$，起始条件也即 $f(0)=1$，$f(1)=1$。我们注意到状态转移只与前两个状态有关，而最后的结果是最后一个状态，则我们可以丢弃前面的状态，只用三个变量分别存储当前的状态、前一个状态、前两个状态。result 表示 $f(n)$，one 表示 $f(n-1)$，two 表示 $f(n-2)$。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即循环的次数。&emsp;&emsp;空间复杂度：$O(1)$。经过优化，我们只需要使用三个变量来进行状态转移，因此所需空间是常数级的。 3.数学方法&emsp;&emsp;通过前面的状态转移方程和初始值我们可以发现，其实这就是一个斐波那契数列。而通过 特征方程法 是可以得到斐波那契数列的通项公式的，也即 $a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$。注意上面的通项公式是从 1 开始的，而我们的函数 $f$ 是从 0 开始的，因此在代入时需要将 n 加 1。 &emsp;&emsp;这个通项公式中包含了幂运算，具体时间复杂度取决于 CPU 的指令集，因此不分析。&emsp;&emsp;空间复杂度为 $O(1)$。 4.矩阵快速幂 - 官方题解&emsp;&emsp;来自于官方题解的方法，涉及了矩阵的知识。由于递推的关系可以视为矩阵相乘。 \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix} \\begin{bmatrix}f(n)\\\\f(n-1)\\end{bmatrix}= \\begin{bmatrix}f(n)+f(n-1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}&emsp;&emsp;则有 \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix}^n \\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}&emsp;&emsp;因此我们需要计算的就是 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^n$，可以将其拆分成 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}$，以此类推。计算的时间复杂度是 $O(\\log n)$，也即在较大的 $n$ 下，计算速度比动态规划更快。&emsp;&emsp;另外官方题解还提到了非齐次线性递推转化为矩阵快速幂的计算方法，上面的方法代码也包含其中。具体请阅读 爬楼梯 - 力扣官方题解。"},{"title":"Leetcode 64.最小路径和","date":"2021-06-15T16:18:00.000Z","url":"/2021/06/16/Leetcode%2064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 示例 2： 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 链接： 题目分析&emsp;&emsp;由于只能往右或往下走，则每一格最多来自两个方向（左边或者上边）。我们采用动态规划的方法，dp[i][j] 记录从左上角到 grid[i][j] 的最小路径和，从左到右，从上到下遍历 grid，直到右下角，得出答案 dp[m-1][n-1]。而每一格的最小路径和也即从左边或者上边选择值较小的那一个，然后加上本身的数值。&emsp;&emsp;注意左上角的最小路径和也即其本身，第一列只能来自上边，第一行只能来自左边。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是 grid 的行数和列数。动态规划的过程对 grid 进行了一次遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是 grid 的行数和列数。也即动态规划数组的大小。（可以优化到 $O(\\min(m,n))$，具体方法是只存储上一行或者上一列的 dp 值）"},{"title":"Leetcode 62.不同路径","date":"2021-06-10T12:55:00.000Z","url":"/2021/06/10/Leetcode%2062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","tags":[["C++","/tags/C/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= m, n &lt;= 100$ 题目数据保证答案小于等于 $2*10^9$ 链接： 题目分析&emsp;&emsp;这是一道很经典的数学题。机器人处在 m x n 的网格中，并且只能往右和往下移动，则从左上角移动到右下角，总的移动路程是一定的，一定是往右走了 n-1 步，往下走了 m-1 步，也即总的移动路程是 m-1+n-1。而不同的移动方案，也即是在 m-1+n-1 步中，选择其中的 m-1 往下（或者选择 n-1 步往右），也即是一个数学组合问题。答案就是 $\\binom{m-1+n-1}{m-1}$ 或 $\\binom{m-1+n-1}{n-1}$。为了减少运算量，我们可以选择 m 和 n 其中更小的那个来计算。&emsp;&emsp;虽然题目中保证答案小于等于 $2*10^9$，也即答案不会超过 int 的范围，但是在计算的过程还是会超过，需要使用 long long int 类型。 &emsp;&emsp;时间复杂度：$O(\\min(m,n))$，其中 $m、n$ 分别是网格的行数和列数。也即计算组合数的时间复杂度。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放变量。"},{"title":"Leetcode 56.合并区间","date":"2021-06-10T09:15:00.000Z","url":"/2021/06/10/Leetcode%2056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] = [start_i, end_i]$ 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 示例 2： 提示： $1 &lt;= intervals.length &lt;= 10^4$ $intervals[i].length == 2$ $0 &lt;= starti &lt;= endi &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;可以合并的区间存在着这样的性质：假设左端点靠左的区间为 interval_1，左端点靠右的区间为 interval_2，则有 interval_1-&gt;end &gt;= interval_2-&gt;start，也即存在重叠。则如果我们按照区间的左端点大小进行排序，则可以进行合并的区间一定是连续的。&emsp;&emsp;声明一个 result 数组作为结果返回，我们先将第一个区间加入结果。之后对于后面的每一个区间，我们有这样的操作：如果该区间和 result 中的最后一个区间不存在重合（满足 intervals[i]-&gt;start &gt; result[count]-&gt;end），则将其作为新区间加入到 result 中；若该区间与 result 中的最后一个区间重合，则更新 result 的最后一个区间，变成合并后的结果，也即 result[count]-&gt;end = max(result[count]-&gt;end, intervals[i]-&gt;end)。顺序遍历所有的区间后得到结果。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 为区间的个数。对所有的区间进行排序需要 $O(n\\log n)$ 的时间，而排序后只需要一次遍历，也即 $O(n)$ 的时间，因此总的时间复杂度为 $O(n\\log n)$。&emsp;&emsp;空间复杂度：$O(\\log n)$，其中 $n$ 为区间的个数。作为答案返回的数组不计入所需空间，则所需的额外空间也即排序所需要的空间。"},{"title":"Leetcode 55.跳跃游戏","date":"2021-06-10T08:50:00.000Z","url":"/2021/06/10/Leetcode%2055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","tags":[["C++","/tags/C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 示例 2： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $0 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;这道题目可以使用贪心的思想。对于某个位置 y 是否可以到达，需要满足两个条件：前面的某个位置 x 可以到达，x 可以跳跃到 y，也即有 x + nums[x] &gt;= y。那我们可以遍历数组，贪心地获取当前可以到达的最远位置，直到遍历到所有的可到达位置，若可以到达的最远位置没有超过数组的最后一个下标，则数组的最后一个下标不可达。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们最多只需要遍历一遍数组。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 53.最大子序和","date":"2021-06-09T09:04:00.000Z","url":"/2021/06/09/Leetcode%2053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析1.动态规划&emsp;&emsp;我们用 dp[i] 表示以 nums[i] 结尾的最大子序列和。那么 dp[i] 只有两种情况，第一种是 nums[i] 加上 dp[i-1] 所表示的那一段，第二种是 nums[i] 单独作为新的一段。而我们只需要保留这两种中较大的那一个。也即状态转移方程为 dp[i] = max&#123;dp[i-1]+nums[i], nums[i]&#125;。而我们所要求的结果也即 dp 数组中最大的值。&emsp;&emsp;另外我们通过观察可以发现，每一个 dp[i] 只取决于 dp[i-1]，并且在遍历的时候便可以边记录最大值，则其实我们无需建立一个 dp 数组，只需要一个变量 pre 来表示每一个 dp[i-1] 即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。 2.分治法 - 官方题解&emsp;&emsp;这是题目中提到的更为精妙的进阶方法，没有想到，参阅了官方题解 最大子序和 - 力扣官方题解。主要思路是利用了线段树，对于每一个区间 [l, r]，维护了 4 个变量，分别是 $lSum$，表示 [l, r] 中以 l 为左端点的最大子序和。 $rSum$，表示 [l, r] 中以 r 为右端点的最大子序和。 $iSum$，表示 [l, r] 的区间和。 $mSum$，表示 [l, r] 中最大子序和。 &emsp;&emsp;对于每一个区间 [l, r] 这些变量的赋值都来自于 [l, m] 和 [m+1, r] 的这些变量，也即分治后递归回升的整合。具体整合方法为 $iSum = iSum_l + iSum_r$，也即左右子区间的和即为该区间的和。 $lSum = max(lSum_l, iSum_l+lSum_r)$，也即要不是左区间的 $lSum$，要不是整个左区间加上右区间的 $lSum$。 $rSum = max(rSum_r, iSum_r+rSum_l)$，同理，要不是右区间的 $rSum$，要不是整个右区间加上左区间的 $rSum$。 $mSum = max(mSum_l, mSum_r, rSum_l+lSum_r)$，也即如果 $mSum$ 不跨越 m，则可以是左区间或者是右区间的 $mSum$，如果跨越 m，则是左区间的 $rSum$ 加上右区间的 $lSum$。 &emsp;&emsp;最后递归到最外层，求出 [0, nums.size()-1] 区间的 $mSum$ 即可。 &emsp;&emsp;时间复杂度：$O(n)$，这样的方法下其实相当于是进行了一颗二叉树的先序遍历。&emsp;&emsp;空间复杂度：$O(\\log n)$，也即递归的深度。 &emsp;&emsp;这样的方法下使用了递归，实际运行的时间比动态规划更长，也需要更多的空间，但是它的意义是它可以解决任意区间下的最大子序和问题，并且建立成为一颗树之后，所有的子区间信息都可以用堆的方法来存储，就可以在 $O(\\log n)$ 的时间内找到任意区间的答案。并且假如序列中的某些值发生修改，只需要对有影响的区间值进行修改维护，所需的时间只要 $O(\\log n)$，便可以继续使用。这样的特性对于大规模的查询优势便十分明显。"},{"title":"Leetcode 49.字母异位词分组","date":"2021-06-09T08:30:00.000Z","url":"/2021/06/09/Leetcode%2049.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 链接： 题目分析&emsp;&emsp;题目中要求我们给字符串分类，很容易可以想到哈希的思想。我们可以建立一个哈希表，把一组字母异位词放到同一个 key 里作为哈希表的值。那么如何选取 key 值呢？观察字母异位词的共同点，它们的字母是相同的，但排列不同，也即是说，经过排序，它们会变成同一个字符串。则我们可以将这个排序好的字符串作为这一组字母异位词的 key 值。遍历所有的字符串加入哈希表之后，哈希表中的每一个 key 即对于一组字母异位词，将哈希表转化为结果即可。 &emsp;&emsp;时间复杂度：$O(nk\\log k)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。因为我们总共需要添加 $n$ 个字符串，而每个字符串需要 $O(k\\log k)$ 的时间排序，$O(1)$ 的时间加入到哈希表中，$O(k)$ 的时间复制到结果中。因此最后的总时间复杂度为 $O(nk\\log k)$。&emsp;&emsp;空间复杂度：$O(nk)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。也即哈希表的开销。 官方题解&emsp;&emsp;官方题解中将字符串加入到 vector 中的使用的函数都是 emplace_back，通过搜索学习发现原来是 C++11 的新特性，这个函数是将参数而不是对象传递给构造函数，而构造函数直接在容器空间中构造元素，因此省去了一次构造临时对象的过程，减少了内存开销。"},{"title":"Leetcode 48.旋转图像","date":"2021-06-08T17:21:00.000Z","url":"/2021/06/09/Leetcode%2048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","tags":[["C++","/tags/C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 示例 2： 示例 3： 示例 4： 提示： matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 链接： 题目分析&emsp;&emsp;题目要求我们使用原地算法，也即直接对矩阵进行操作。通过观察我们可以发现，顺时针旋转 90 度，也即每 4 个位置进行了依次更替。如下图所示。 &emsp;&emsp;一共有多少组需要进行这样的更替呢？其实也就是矩阵的 1/4。下面以 4 × 4 和 5 × 5 的矩阵为例展示需要旋转的范围。我们只需要以左上角的色块为起点，对每一个位置进行对应位置的依次更替即可。需要注意依次更替的坐标对应关系，还有矩阵宽度为奇数时的划分方式（中心块无需更替）。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 为矩阵的宽度。我们其实就是对矩阵的每个位置进行了相应的更替，需要操作的子矩阵大小为 $O(\\lfloor{\\frac{n+1}{2}}\\rfloor\\times\\lfloor{\\frac{n}{2}}\\rfloor)=O(n^2)$，每次操作 5 步，为常数。&emsp;&emsp;空间复杂度：$O(1)$。原地算法，只用到了常数的额外空间。 官方题解&emsp;&emsp;官方题解中提到了另外一种巧妙的方法，也即利用翻转代替旋转。先将矩阵上下翻转，再按左上到右下的主对角线翻转，也可以得到答案。 "},{"title":"Leetcode 46.全排列","date":"2021-06-08T15:40:00.000Z","url":"/2021/06/08/Leetcode%2046.%E5%85%A8%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 6$ $-10 &lt;= nums[i] &lt;= 10$ nums 中的所有整数 互不相同 链接： 题目分析&emsp;&emsp;全排列也即题目中所给数字填在不同的位置构成的所有情况，我们可以按顺序从左到右填上数字，利用回溯的方法即可穷举所有的情况。我们需要填入的数字也即 nums 数组，如何标记已经填入的数字呢？一个方法是维护一个布尔数组用于记录，将已填入的数字标记为 true。每次填入时按顺序遍历，寻找未填入的数字进行填入，并更新这个标记。回溯之后记得将标记回溯为 false。 &emsp;&emsp;上面的代码我们可以发现，每一次填数时，都需要遍历 flag 数组寻找未填入的数字，这样需要的时间更长，也需要额外的空间，有没有什么办法可以不需要这个标记数组呢？答案是肯定的。我们可以将 nums 数组分割为两个部分，一部分表示已经填入的数，一部分表示未填入的数，每次填入一个数，就将其与分割线的位置交换，例如 &#123;2, 3, | 4, 5, 6&#125; 这样的数组，下一个填入 6 时就将 4 与 6 交换，并且移动分割线，变成 &#123;2, 3, 6, | 5, 4&#125;，这样每次只需要从分割线的位置开始遍历就可以了，并且不需要额外的空间进行标记。值得注意的是，这样的交换会打乱数组的顺序，所以最后输出的结果并不是按照字典序来排列的。题目中说明可以按照任意顺序返回答案，因此可以这样做，如果有要求按照字典序，则只能按照上面的做法。 &emsp;&emsp;时间复杂度：$O(n\\times n!)$，其中 $n$ 是数组的大小。因为我们遍历了所有的排列，全排列的个数为 $n!$。 而对于每一个解，我们都需要 $O(n)$ 的时间将其复制到答案数组中，因此总的时间复杂度为 $O(n\\times n!)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。因为作为答案返回的数组不计入所需空间中，而我们需要的额外空间即递归调用的深度，最大深度为 $n$。 官方题解&emsp;&emsp;看完官方题解才发现，我们在动态维护的 nums 数组，左边表示的已填入的数字就是按照填入的顺序进行排列的，因此可以不用额外的一个 now 数组对结果进行存储，在填完所有的数字后 nums 即为这种排列本身，将其复制到答案中即可。 "},{"title":"Leetcode 42.接雨水","date":"2021-06-08T06:37:00.000Z","url":"/2021/06/08/Leetcode%2042.%E6%8E%A5%E9%9B%A8%E6%B0%B4/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 示例 2： 提示： 链接： 题目分析&emsp;&emsp;这道题有点像 Leetcode 11.盛最多水的容器，因此也是考虑用双指针的做法。与那道题不同的是，这里的每个柱子并不是没有厚度的“壁”，而且对于所有的“坑”都会盛上水，而不是只选取其中两个壁之间盛水。但是思路应该是一致的，我们可以从两边往中间搜索。这是因为观察可以发现，每个较低的柱子，只要两边有高于它的柱子，则可以填上水直到和较低的一边柱子平齐。而我们在利用双指针搜索的时候，优先扩展较低的那边，则可以保证未搜索的区域不会影响已搜索区域填水的高度。&emsp;&emsp;具体的算法是，维护两个变量记录左边已搜索区域的最大高度 maxleft 和右边已搜索区域的最大高度 maxright，而 left 和 right 分别记录当前搜索的左右指针（下标）。如果当前是左边的最大高度 maxleft 较小，则扩展左边，若出现了更高的柱子则更新 maxleft，较低的柱子则填上雨水直到和 maxleft 平齐，也即更新 water 值；同样的，如果是 maxright 较小，则扩展右边，相应地更新 maxright 或者 water 值。最后两个指针相遇的时候搜索结束，得到结果。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 官方题解&emsp;&emsp;下面的代码是官方题解中双指针的代码，减少了一次判断，将更新 max 值和 water 值（这里是变量 ans)整合到了一起。相应的指针相遇条件有所不同（因为我们上面的代码更新完 max 值也对指针进行了移动，因此指向的永远是未搜索的区域，必须两个指针已经重合后错开才算搜索完毕）。&emsp;&emsp;官方题解中还有动态规划和栈等其他解法，也可以提供一定的解决思路，时间复杂度都是一样的 $O(n)$，但是动态规划和栈解法均需要 $O(n)$ 的空间。感兴趣的可以阅读 接雨水 - 力扣官方题解。 "},{"title":"Leetcode 39.组合总数","date":"2021-06-07T17:45:00.000Z","url":"/2021/06/08/Leetcode%2039.%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 示例 2： 提示： $1 &lt;= candidates.length &lt;= 30$ $1 &lt;= candidates[i] &lt;= 200$ candidate 中的每个元素都是独一无二的。 $1 &lt;= target &lt;= 500$ 链接： 题目分析&emsp;&emsp;题目要求所有的可行解，则依然可以使用回溯的方法来进行搜索遍历，也即对于每一个数 candidates[i]，都可以选择是否将其加入结果中，然后再转化为搜索 target-candidates[i] 的问题。为了避免产生重复解，我们按照 candidates 的顺序添加，也即若当前选择不添加 candidates[i]，则转化的子问题也不能再添加 candidates[i]。注意到题目中的数字可以无限制重复选取，则我们每次都需要保持从上一次添加的数字开始（也即上一次添加的数字仍然可以添加）。每当 target 为 0，意味着当前添加的数字的和为 target，也即找到了一组解，将其添加到结果列表中。&emsp;&emsp;而为了加快搜索速度，我们可以进行剪枝。比如我们可以先对 candidates 进行排序，当 target 已经小于当前想添加的数字时，也肯定小于后面所有的数字，则都不会是结果，则可以直接跳出循环返回。 &emsp;&emsp;时间复杂度：$O(S)$，$S$ 是可行解的长度之和。我们遍历了所有的可行解得到结果，而对于不可行的情况马上剪枝，则时间复杂度是可行解的长度之和。因为这道题确实比较难给出一个较紧密的上界。对于每个数字选或者不选，一共拥有非常多的可能，这是指数级别的。但是我们进行的剪枝可以排除掉非常多的情况，因此实际的运行情况不好以target 的大小或者是 candidates 的大小界定。&emsp;&emsp;空间复杂度：$O(target)$。作为结果返回的数组不计入所需空间中，而所有的数字都是正整数，则最大的可行解长度也就是 target 的值（全由 1 构成可行解），这也是我们栈递归的最大深度，因此空间复杂度为 $O(target)$。"},{"title":"Leetcode 34.在排序数组中查找元素的第一个和最后一个位置","date":"2021-06-07T17:06:00.000Z","url":"/2021/06/08/Leetcode%2034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 10^5$ $-10^9 &lt;= nums[i] &lt;= 10^9$ nums 是一个非递减数组 $-10^9 &lt;= target &lt;= 10^9$ 链接： 题目分析&emsp;&emsp;这个题目仍然可以使用二分查找的思路，但是由于我们要找到的是 target 值在数组中的开始位置和结束位置，则我们可以转变一下思路，变成寻找到小于 target 的最大数和大于 target 的最小数，则若还有数存在它们中间，那就是 target 了。下面给出的代码中，ansleft 表示小于 target 的最大数下标，ansright 表示大于 target 的最小数下标，这两个数允许超出数组的界限，也即可以为 -1 或者 nums.size()，这样可以应对 target 在数组边界的情况。我们先寻找 ansleft，再从 ansleft 的右边寻找 ansright，这样既缩小了搜索范围，又可以保证 ansright 大于 ansleft。注意最后返回结果之前检查一下夹在中间的值是不是 target 就可以了。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 33.搜索旋转排序数组","date":"2021-06-07T16:12:00.000Z","url":"/2021/06/08/Leetcode%2033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 5000$ $-10^4 &lt;= nums[i] &lt;= 10^4$ nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 $-10^4 &lt;= target &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;对于有序数组的搜索我们一般都是使用二分查找的方法，但是题目中的数组经过了一次旋转，只是局部有序，是否还仍然能使用二分查找的方法呢？答案是肯定的。通过观察我们可以发现，我们在任意位置将旋转后的数组分割为两个部分，则仍然可以保证至少其中一部分是有序的。判断是否有序只需要将该部分的头尾两个值进行比较即可，非常便捷。那么便有以下情况。&emsp;&emsp;左边有序，也即 nums[0] &lt;= nums[mid]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。&emsp;&emsp;右边有序，也即 nums[mid] &lt;= nums[n-1]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 32.最长有效括号","date":"2021-06-03T12:39:00.000Z","url":"/2021/06/03/Leetcode%2032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述： 给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 示例 2： 示例 3： 提示： 0&lt;=s.length&lt;=3∗1040 &lt;= s.length &lt;= 3 * 10^40&lt;=s.length&lt;=3∗104 s[i] 为 '(' 或 ')' 链接：  题目分析 1.动态规划 我们用 dp[i] 表示以 s[i] 作为结尾的最长有效括号串长度。则可以得到以下性质，当 s[i] 为 ( 时，dp[i] = 0，这是因为有效的括号串一定是以右括号结尾的。而当 s[i] 为 ) 时最长有效括号串是怎么样的呢？ 假若 s[i-1] 为 (，则我们可以认为这个括号串是 dp[i-2] 的括号串加上了一个 ()，这样的括号串仍然是有效括号串，并且长度增加了2。即有 dp[i] = dp[i-2] + 2。 假若 s[i-1] 为 )，则 s[i-1] 应该和 dp[i-1] 所表示的部分相匹配，如下图所示。而若 s[i] 能够匹配，则只能是匹配到 s[i-dp[i-1]-1] 为 (，与此同时，dp[i-dp[i-1]-2] 所表示的部分也能一并加入到有效括号串中。最后一共为 dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2。 而我们所要求的答案，便是 dp 数组中的最大值了。按照上面分析的状态转移公式遍历一次括号串即可。需要注意的是，以上的分析都是默认没有越界的情况，因此实际编写代码时均需要首先对这些下标是否存在进行判断。 时间复杂度：O(n)O(n)O(n)，其中 nnn 为括号串的长度。因为我们只需要遍历一次字符串并更新 dp 数组即可得到结果。 空间复杂度：O(n)O(n)O(n)，其中 nnn 为括号串的长度。即为 dp 数组的大小。 2.括号计数 通过观察我们可以发现，只要左括号和右括号的数量一致，并且右括号不先于未匹配的左括号出现，换句话说，就是从左往右遍历时，左括号数量总是大于等于右括号数量，这样的括号串一定是有效的，这是因为只存在一种括号。则我们可以只维护两个计数器，分别表示左括号和右括号的数量，从左往右遍历一次字符串，每次遇到左括号就将左括号计数加1；遇到右括号就将右括号计数加1，并且进行以下判断：①若右括号数量等于左括号，则这是有效的括号串，长度为左右括号数量之和。②若左括号数量小于右括号，则说明出现了无法匹配的右括号，此时需要将左右括号的计数都重置为0，也即抛弃之前的部分，重新进行匹配。 而对于左括号始终多于右括号的情况，例子 (()，我们没有一种状态是左括号数量等于右括号。则我们从右往左遍历，用类似的方法，让左右括号的含义交换即可解决。 注意左右括号数量不相等时是不能保证有效的，例子 ()(()，这个时候左括号数量 3，右括号数量 2，有效的括号串长度并不是 right*2=4。 时间复杂度：O(n)O(n)O(n)，其中 nnn 为括号串的长度。因为我们只需要分别从左和从右遍历两次字符串并更新计数器即可得到结果。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量的空间。"},{"title":"Leetcode 31.下一个排列","date":"2021-06-02T10:31:00.000Z","url":"/2021/06/02/Leetcode%2031.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["字典序","/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 100 链接： 题目分析&emsp;&emsp;首先我们要分析 “字典序” 中下一个排列是什么，下一个排列是比当前排列大的最小的排列。&emsp;&emsp;为了获取到比当前排列 “大” 的排列，则表明在从左往右数的某一位中，新排列的数字比原排列的大，而在此之前所有的数字均与原排列一样。由于越往右表示的权重越小，则为了使新排列尽可能的 “小”，我们应该令改变的数字尽可能地靠右。另一方面，改变的数字必须从原数字的右边选取，并且必须比原数字大。那么靠右的极限是什么？应该是后面的每个数的右边均不存在比自己小的数了，也即意味着，右边的数是降序排列（包含相同）的。我们只需要从数组最后往前找，找到第一个降序的数（不包含相同），这样就找到了需要换数字的某一位数（最右的降序排列反着找就是升序排列，而我们要找到第一个不符合的数），我们把这个下标记为 left。&emsp;&emsp;为了使新排列尽可能的小，我们需要换的数字也必须尽可能的小，因此我们需要在右边的降序排列中找到比 nums[left] 大，但是又尽可能地小的数。也即从数组最后往前找，找到第一个比 nums[left] 大的数（此时相当于是升序查找的，因此可以保证尽可能地小），我们把这个数记为 nums[right]。&emsp;&emsp;将 nums[right] 与 nums[left] 交换后，已经可以保证新排列比原排列大，为了使新排列尽可能地小，我们需要另 nums[left] 之后的序列变为升序序列，这样是最小的情况。而我们进行交换的时候，有 nums[right-1] &gt;= nums[right] &gt; nums[left] &gt;= nums[right+1]，则可以保证将 nums[left] 交换到 nums[right] 原本的位置后，右边的降序序列仍然是降序序列，则使用一个 reverse 函数将这部分反转为升序序列即可。同时的，这个函数是由双指针实现的，可以保证题目要求的原地修改。 &emsp;&emsp;对于题目中的边界情况有 ①原数组是降序排列（最大排列），这个时候寻找不到 nums[left]，也即寻找到的 left 值为 -1。而我们需要反转的区间原本应该是 left+1 ~ end，刚好 left 为 -1 时，反转区间从 0 开始，也即将整个数组进行反转，成为升序排列（最小排列），符合题意。②原数组只有一个数，这种情况其实等同于上一种情况，只是最大排列和最小排列是相同的，将其进行反转也不会改变什么，因此不需要进行单独处理。因此最后的代码如下。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只进行了两次扫描，一次反转操作，这些操作的时间复杂度均为 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个变量存放交换的数字位置，一个变量用于数组反转。"},{"title":"Leetcode 23.合并K个升序链表","date":"2021-06-02T08:40:00.000Z","url":"/2021/06/02/Leetcode%2023.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 示例 2： 示例 3： 提示： $k == lists.length$ $0 &lt;= k &lt;= 10^4$ $0 &lt;= lists[i].length &lt;= 500$ $-10^4 &lt;= lists[i][j] &lt;= 10^4$ $lists[i]$ 按 升序 排列 $lists[i].length$ 的总和不超过 $10^4$ 链接： 题目分析&emsp;&emsp;这道题是 Leetcode 21.合并两个有序链表 的升级版，原题链接以及相关题解都已经在这篇文章里面。 1. 顺序逐一合并&emsp;&emsp;根据我们对两个有序链表合并的思路，我们很容易想到，可以将其拆分成 k-1 个两链表合并的过程，逐一进行合并即可。代码中的 mergeTwoLists 函数即为合并两个有序链表的题解。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。这是由于对于每一次合并时间复杂度都是两个链表的长度和，而对于第 $i$ 次合并 lists[0] 的长度应该为 $i\\times n$，而 lists[i] 的长度为 $n$，一共需要合并 $k-1$ 次，则总的时间复杂度为 $O(\\sum^{k-1}_{i=1}(i+1)\\times n)=O(\\frac{(k+2)(k-1)}{2}\\times n)=O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。同两个链表合并，没有用到与 $k、n$ 规模相关的辅助空间。 2.分治合并&emsp;&emsp;从方法1中，我们可以发现，作为答案进行返回的 lists[0] 数组在每一次合并的时候都要遍历一次，这样的遍历是比较多余的，我们可以采用分治的思想进行优化。每一轮对每两条链表进行合并，得到 $\\frac{k}{2}$ 条链表，然后再继续合并得到 $\\frac{k}{4}$ 条链表，以此类推直到所有的链表合并完毕。下面所给的代码中已略去 mergeTwoLists 函数。 &emsp;&emsp;时间复杂度：$O(kn\\log k)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。对于第 $i$ 轮合并，每一条链表长度为 $2^{i-1}n$，则每一组合并的时间代价为 $O(2^in)$，一共有 $\\displaystyle\\frac{k}{2^i}$ 组。则总时间复杂度为 $O(\\sum^{\\infty}_{i=1}\\frac{k}{2^i}\\times2^in)=O(kn\\log k)$。&emsp;&emsp;空间复杂度：$O(\\log k)$，其中 $k$ 表示链表的数目。这是由于在分治合并中递归层数是 $\\log k$。 3.K个链表一起合并&emsp;&emsp;类似于合并两个链表的双指针思路，我们可以直接使用k个指针分别指向k条链表，每一次合并时进行比较并将最小的加入到答案链表中。实际上这是我第一个想到的解法，然而这样的方法每一次加入都需要进行比较，每一次比较都必须遍历k条链表（即便为空也进行判断），并且没有任何剪枝，时间复杂度是非常高的，最后以 952ms 的运行时间勉强通过了测例。&emsp;&emsp;代码中的 flag 表示了当前是否获得第一个非空链表的头结点，这个结点值作为每一轮比较的初值；当所有的链表都为空时也即合并完毕。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共有 $kn$ 个结点需要进行添加，而每一次添加都需要对 $k$ 个链表的头结点进行遍历比较得到最小值，因此时间复杂度为 $O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。对于每一次添加我们只需要维护两个变量分别记录最小值以及最小值所在的链表。 4.合并后排序再连接&emsp;&emsp;简单粗暴的解法，直接按顺序读取所有的结点到数组中存放，然后对整个数组进行排序，之后再逐一连接起来。出乎意料的是，这样的运行时间其实蛮快的。真是暴力而又省事的解法。 &emsp;&emsp;时间复杂度：$O(kn\\log(kn))$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共 $kn$ 个结点，将其逐一添加到数组中需要 $kn$ 的时间代价，而后进行排序我们认为是 $O(kn\\log(kn))$ 的，其实他们已经相对有序，相当于已经进行了一部分的分治排序，sort 函数底层如果有实现相对于的优化的话实际耗时是比较短的。最后重连接的时候也需要 $kn$ 的时间代价。&emsp;&emsp;空间复杂度：$O(kn)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。我们开辟了一个新的数组用来存放 $kn$ 个结点。"},{"title":"Leetcode 22.括号生成","date":"2021-05-24T05:49:00.000Z","url":"/2021/05/24/Leetcode%2022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 8 链接： 题目分析&emsp;&emsp;类似于 Leetcode 17.电话号码的字母组合，我们要获得所有的括号排列组合，则可以使用回溯的方法，维护一个字符串，每次加入一个左括号或者右括号，直到所有的括号添加完毕得到一个结果，再回溯删除，添加另外一种括号，如此穷举得到所有的结果。我们使用 n 来记录还未添加的左括号数目，使用 left 来记录还未匹配的左括号数目，则可以添加左括号的条件是 n &gt; 0，可以添加右括号的条件是 left &gt; 0，当 n == 0 &amp;&amp; left == 0 时表明所有的括号已经添加并且匹配完毕，则得到一种结果。 &emsp;&emsp;时间复杂度：$O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$，其中 $n$ 是需要生成的括号对数目。这是由于 generateParenthesis(n) 的数目是第 $n$ 个卡特兰数 $\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}$，而这个数字由 $\\displaystyle\\frac{4^n}{n\\sqrt{n}}$ 渐进界定。我们每得到一种结果，都需要耗费 $O(n)$ 的时间将其添加到答案数组中，因此总的时间复杂度为 $O(\\displaystyle\\frac{4^n}{n\\sqrt{n}}\\times n) = O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是需要生成的括号对数目。因为返回结果不计入空间开销，而其他开销主要取决于栈递归的层数，最大层数为 $2n$，每次递归调用的空间开销为 $O(1)$，因此空间复杂度为 $O(n)$。 &emsp;&emsp;PS：相关阅读：卡特兰数-百度百科"},{"title":"Leetcode 21.合并两个有序链表","date":"2021-05-23T17:42:00.000Z","url":"/2021/05/24/Leetcode%2021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 示例 2： 示例 3： 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 链接： 题目分析&emsp;&emsp;合并两个升序链表，只需要用两个指针分别遍历两个链表，每次将值小的那个结点添加到合并链表中即可。如果一个链表为空，则直接返回另一个链表（当两个都为空时返回的也是空）。当迭代到某一个链表为空之后，只需将另外一个链表剩下的部分接到最后即可。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别为两个链表的大小。因为我们最多只对两个链表进行了一次遍历便可以完成合并的操作。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。 官方题解&emsp;&emsp;思路与上面相同，但是我们可以使用一个哨兵结点 prehead 作为开头，这样就可以不用额外判断合并后的链表是以哪个链表作为头结点，从而代码可以合并到后面迭代的循环中，更为简洁。这里的 prev 相当于上面的 tail。 "},{"title":"Leetcode 20.有效的括号","date":"2021-05-23T17:07:00.000Z","url":"/2021/05/24/Leetcode%2020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= s.length &lt;= 10^4$ s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 链接： 题目分析&emsp;&emsp;使用栈解决即可。遇到左括号入栈，遇到右括号判断当前栈顶元素是否是相匹配的括号，匹配则进行出栈，不匹配则直接返回 false。需要注意的是当栈为空时调用 top() 函数会出错，并且最后遍历完成之后若栈中还剩余有未匹配的左括号也说明结果为 false。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是括号串的长度。因为我们对该串进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是括号串的长度。我们维护了一个栈存放未匹配的括号，这个栈的最大大小为 $n$。 官方题解&emsp;&emsp;官方题解也是同样用栈的思路，但是建立了一个哈希表进行匹配，代码显得漂亮一点。另外有一点是匹配的括号串一定是偶数个，如果括号串字符数为奇数则可以直接返回 false。 "},{"title":"Leetcode 19.删除链表的倒数第N个结点","date":"2021-05-23T16:30:00.000Z","url":"/2021/05/24/Leetcode%2019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 链接： 题目分析&emsp;&emsp;最简单的办法当然是先对链表进行一次遍历得到长度，然后再得到需要删除的结点位置，第二次遍历到该位置并进行删除，如此一共需要进行两趟扫描。但是如果我们采用前后双指针的做法，让前指针先走 $n$ 步，之后两个指针再一起前进，则当前指针到达链表末尾的时候，后指针就到了需要删除的位置，这样只进行一趟扫描就可以解决问题。&emsp;&emsp;由于删除链表结点的操作是令前置结点的 next 指向其后置结点，则实际上我们搜索到删除结点的前置结点就停下更方便删除，因此循环退出条件也变为前指针的 next 是否已经指向空而不是前指针本身为空。&emsp;&emsp;注意到，如果 $n$ 的值等于链表长度，也即需要删除的结点是头结点时，头结点没有前置结点，则直接返回头结点的后置结点即可。而这种情况下前指针走了 $n$ 步刚好为空，可以作为判断的条件。&emsp;&emsp;PS：代码中含有的注释部分是另一种写法，包括了释放删除结点的内存。 &emsp;&emsp;时间复杂度：$O(L)$，其中 $L$ 是链表的长度。我们总共对链表进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。"},{"title":"Leetcode 17.电话号码的字母组合","date":"2021-05-22T18:52:00.000Z","url":"/2021/05/23/Leetcode%2017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 示例 2： 示例 3： 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 链接： 题目分析&emsp;&emsp;题目要求返回所有的可能情况，则我们可以使用回溯的方法，维护一个字符串，不断将数字代表的字母加入到字符串中，得到一种结果后再进行回溯，删除加入的字母，将数字代表的另一个字母加入到字符串中，这样便可以穷举所有的可能结果。而数字与字母的对应关系可以使用一个哈希表解决。注意当输入的串为空串时，也要返回一个空的字符串数组作为结果。 &emsp;&emsp;时间复杂度：$O(3^m\\times4^n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，也即 2、3、4、5、6、8 数字的数量，$n$ 是输入中对应 4 个字母的数字个数，也即 7、9 数字的数量。这是因为我们需要遍历所有可能的字母组合。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，$n$ 是输入中对应 4 个字母的数字个数。因为返回值不计入空间复杂度中，而其他开销还有哈希表和递归调用中的层数开销。哈希表大小是固定的，可以视为常数；而最大递归层数为 $m+n$。"},{"title":"Leetcode 15.三数之和","date":"2021-05-22T14:22:00.000Z","url":"/2021/05/22/Leetcode%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 3000$ $-10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;对于三个数字的和，我们可以拆分为一个数字和另外两个数字的和，这两个数的和等于另外一个数的相反数就可以让三个数的和为 0。而对于两数之和的问题，我们进行排序后便可以用双指针的思想，从两端向中间寻找从而降低复杂度。&emsp;&emsp;首先对整个数组进行排序。然后我们先确定第一个数的位置，并得到另外两个数的目标和 target，之后我们使用两个指针 left 和 right 分别初始化到剩下的数组两端，并计算他们的和，如果小于 target，则 left 往右移动，若大于 target，则 right 往左移动。每找到一组和为 target 的元组就和第一个数一起加入到结果数组中。&emsp;&emsp;需要注意的问题是，题目要求三元组不能重复。所以我们在进行遍历的时候，如果和前一个数相同，就跳过，继续往后寻找。而每次找到某个三元组之后，直接令 left 往右而 right 往左，因为他们不能再构成一组不重复的解了。因为第一个数字也是从左到右确定的，并且是三元组中的最小值，因此也不会造成重复。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是数组的长度。外层循环确定第一个数的位置，而内层循环中使用双指针搜索，一共只对剩下的数组进行了一次遍历，因此一共两层遍历，时间复杂度为 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(\\log n)$ 或 $O(n)$，其中 $n$ 是数组的长度。一般计算空间复杂度的时候会忽略作为答案进行输出的空间。而我们需要对数组进行排序，如果传入的数组不允许更改，则我们需要复制一个副本进行排序，则需要 $O(n)$ 的空间。如果可以直接对原数组进行排序，则只需要额外的 $O(\\log n)$ 空间进行排序。"},{"title":"Leetcode 11.盛最多水的容器","date":"2021-05-22T13:08:00.000Z","url":"/2021/05/22/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你 $n$ 个非负整数 $a_1，a_2，…，a_n$，每个数代表坐标中的一个点 $(i, a_i)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$ 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $n = height.length$ $2 &lt;= n &lt;= 3 * 10^4$ $0 &lt;= height[i] &lt;= 3 * 10^4$ 链接： 题目分析1.暴力解法&emsp;&emsp;直接对数组进行双层遍历，两个变量分别表示容器的两边下标。那么水容量就是短边乘上容器宽，记录最大容量即可。不出意外，这样的算法超时了。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 2.暴力解法改进&emsp;&emsp;考虑到，如果我们遍历的时候，从两边往中间遍历，宽是不断变小的，如果边也在同时变小的话，那么肯定不是最大的容量，对于这样的情况是可以进行剪枝的。于是我们稍微修改了遍历的顺序，容器左壁从左边开始遍历，容器右壁从右边开始遍历。分别记录左右边最大值，小于这个值的情况就可以直接进行剪枝了。内层遍历结束后，我们需要将右壁的最大值归为 0 再进行下一个内层遍历。经过剪枝后刚好能够通过测试，并不优良，因为本质上还是双层遍历。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。虽然经过剪枝，但本质上还是双层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 3.双指针解法&emsp;&emsp;其实上面的暴力解法改进的思路已经非常接近双指针的思路了。上面的暴力解法都是先确定左壁再遍历右壁进行计算，但实际上，容器高只取决于短的那条边。那么如果我们还是从左右两边往中间遍历，是不是可以按照实际情况选择移动左壁还是右壁呢？实际上我们应该移动短的那边就可以了。因为进行移动的话，容器宽变小了，而容器高却还是取决于短边，移动长边不会增加还可能更少，因此一定不会使容量更大。而移动短边的话，可能提高了容器高的值，就可能使容量增大。所以我们实际上只需要进行一层遍历，两个指针开始时分别在数组两端表示两个容器壁，而后短边不断向对方移动，每次移动的时候判断容积是否变大，变大则更新结果，最后直到两个容器壁相遇则结束。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 表示数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。"},{"title":"Leetcode 10.正则表达式匹配","date":"2021-05-22T11:46:00.000Z","url":"/2021/05/22/Leetcode%2010.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 &#39;.&#39; 匹配任意单个字符 &#39;*&#39; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。 示例 1： 示例 2: 示例 3： 示例 4： 示例 5： 提示： $0 &lt;= s.length &lt;= 20$ $0 &lt;= p.length &lt;= 30$ s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 链接： 题目分析&emsp;&emsp;对于字符串 s 和 p，我们是逐步匹配的。对于普通字符是一对一匹配，采用一个匹配函数判断即可，对于 . 匹配任意字符的情况也可以在这里得到解决。我们可以采用动态规划的思路，dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。注意 s 和 p 的下标都是从 0 开始的，因此 s 的第 i 个字符是 s[i-1]。那应该有以下的状态转移方程。 若 $p[j-1]\\neq *$ dp[i][j] = \\begin{cases} dp[i-1][j-1], & s[i-1] = p[j-1] \\\\ flase, & s[i-1]\\neq p[j-1] \\end{cases} &emsp;&emsp;而当出现了字符 * 时，表示我们可以对 p[j-1] 匹配任意次，也包括 0 次。这时候，我们可以分情况，如果是匹配 0 次，则相当于我们直接把 p[j] 和 p[j-1] 去掉。如果是匹配 1 次或多次，我们可以直接认为是匹配 1 次，然后将 s[i] 去掉，而 p[j] 和 p[j-1] 继续保留到下次匹配中。这样的话可以得到下面的状态转移方程。 若 $p[j-1]= *$ dp[i][j] = \\begin{cases} dp[i-1][j]\\quad or\\quad dp[i][j-2], & s[i-1] = p[j-2] \\\\ dp[i][j-2], & s[i-1]\\neq p[j-2] \\end{cases} &emsp;&emsp;我们最后的答案也即 dp[s.size()][p.size()]，也就是两个字符串完全匹配的结果。&emsp;&emsp;对于边界条件，我们规定 dp[0][0] = true，也即两个空串是匹配的。而由于 p 中可能开头就存在 a* 而匹配到 s 中空串的情况，i 需从 0 开始。另外代码中存在着一定的冗余，例如 p 中的 a* 必须视为一个整体，但是我们在逐步匹配中，首先直接让 a 进行了匹配，这样的匹配是多余的。但是对于这样的情况，在检查到 * 时，我们的状态转移和 dp[x][j-1] 完全没有关系，因此不对最后结果产生任何影响。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。因为动态规划的状态总数是 $(m+1)*n$，而对于每个状态转移的时间复杂度是 $O(1)$。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。即存储动态规划状态所需要的空间。"},{"title":"Leetcode 5.最长回文子串","date":"2021-05-22T09:41:00.000Z","url":"/2021/05/22/Leetcode%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= s.length &lt;= 1000$ s 仅由数字和英文字母（大写和/或小写）组成 链接： 题目分析1.暴力遍历解法&emsp;&emsp;最容易想到的解法，就是分割每一个子串，并用函数判断这个子串是否是回文串，如果是则更新到结果中。对所有的子串进行判断会超时，我们可以进行稍微的改进，也就是只从比当前结果长的子串开始判断，因为比当前结果短的子串即使是回文串也不会是答案，这样可以节省大量的时间。 &emsp;&emsp;时间复杂度：$O(n^3)$，其中 $n$ 是字符串的长度。因为我们一共需要判断 $O(n^2)$ 个数的子串，而每个子串判断时间是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。进行判断时并没有真的分割出子串，只是对下标进行记录，一共需要常数个变量进行记录。 2.动态规划解法&emsp;&emsp;对于某一个子串，只需要满足它的首尾去掉是一个回文串，而首尾本身也是相同的字符，那么它也是一个回文串。也即有dp[left, right] = dp[left+1][right-1] &amp;&amp; s[left]==s[right]。其中 dp[left][right] 记录了由 s[left] 到 s[right] 的子串是一个回文串。需要注意的是，动态规划的转移方程是从短的子串向长的子串转移，则我们应该从短的字符串向长的字符串进行循环。而对于边界条件，子串字符个数为 1 时一定是一个回文串；子串字符个数为 2 时，两个字符相同时是一个回文串。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。因为动态规划的状态总数是 $O(n^2)$ ，而状态转移时间是 $O(1)$。&emsp;&emsp;空间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。即存储动态规划状态所需要的空间。 3.中心扩展解法&emsp;&emsp;类似于动态规划方法的状态转移思路，我们可以从某一个中心出发，向字符串两端不断扩展匹配是否是相同字符，这样可以得到某一个位置为中心时最大的回文子串长度，若比当前记录的长度更长则进行记录即可，反过来说，其实动态规划的边界情况也就是中心扩展解法的“回文中心”。而每次选择回文中心，有一个字符或者是两个字符的情况，我们要对其分别进行扩展。&emsp;&emsp;注意到我们进行扩展的子函数中循环是首先有对 s[left] 和 s[right] 是否相同进行判断的，这样字符个数为 1 时一定相同，而字符个数为 2 时是否相同也同时进行了判断，因此不必再单独判断字符为 2 时的边界情况。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。我们一共需要扩展 $n$ 个长度为 1 的回文中心和 $n-1$ 个长度为 2 的回文中心，而对于每次扩展，最大长度为 $n/2$。因此总的时间复杂度为 $O((n+n-1)*n/2)=O(n^2)$。&emsp;&emsp;空间复杂度：$O(1)$。进行扩展时只需要进行判断并记录，一共需要常数个变量进行记录。"},{"title":"Leetcode 4.寻找两个正序数组的中位数","date":"2021-05-20T12:32:00.000Z","url":"/2021/05/20/Leetcode%204.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $nums1.length == m$ $nums2.length == n$ $0 &lt;= m &lt;= 1000$ $0 &lt;= n &lt;= 1000$ $1 &lt;= m + n &lt;= 2000$ $-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6$ 链接： 题目分析1.合并数组解法&emsp;&emsp;由于这是两个已经有序的数组，很容易想到归并排序。也就是将两个数组合并成一个，然后再返回处在中间的数字即可。注意合并的时候要考虑某一个数组已经遍历完毕的情况，另外对于奇数个数字和偶数个数字，中位数的计算也不同。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为顺序遍历了两个数组进行合并，合并后返回中位数的过程是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为开辟了一个新数组用来存放合并后的数组。 2.合并数组解法改进&emsp;&emsp;由于我们只需要寻找中位数，其实可以不用将真的将两个数组合并，只需要按顺序寻找到中位数就可以了。由于奇数和偶数计算中位数方式的不同，我们用变量 right 来记录当前第 cnt 小的数，而用 left 来记录上一个 right 也即第 cnt-1 小的数。遍历次数 cnt 为 $(m+n)/2+1$，这样当 $(m+n)$ 为奇数时，我们找到了第 $(m+n)/2+1$ 小的数也即中位数，返回 right；当 $(m+n)$ 为偶数时，left 是第 $(m+n)/2$ 小的数，right 是第 $(m+n)/2+1$ 小的数，中位数是这两个数的平均值，返回 (left+right)/2.0。（这也是变量命名的含义，中位数是左右两个数的平均值） &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。思路和上面一致，但是只需要遍历一半，因为我们只需要找到中位数就可以停止了。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对遍历结果进行记录。 3.二分查找解法&emsp;&emsp;由于数组都是有序的，而我们只需要找到处在中间的那个数，可以考虑用二分查找的方法加快搜索速度。一个思路是对于 nums1、nums2 两个数组，我们要寻找第 k 小的数，则每个数组都寻找第 k/2 个数，假设分别为 nums1[k/2-1] 和 nums2[k/2-1]，比较他们的大小。 若 nums1[k/2-1] &gt;= nums2[k/2-1]，则说明 nums2[k/2-1] 最多也只能比 nums1[0 ~ k/2-2] 和 nums2[0 ~ k/2-2] 都大，最多只有 $(k/2-1)+(k/2-1)=k-2$ 个数比它小，则它小于第 k 小的数，也即 nums2[0 ~ k/2-1] 都可以进行排除。 若 nums1[k/2-1] &lt; nums2[k/2-1]，则相应排除 nums1[0 ~ k/2-1]。 &emsp;&emsp;在剩下的数组中，我们就要找第 k-(k/2) 小的数了。如此二分排除下去就能够得到答案，我们可以采用循环的写法，依然将 k-(k/2) 当做下一个 k。这样的算法下，也有几种特殊情况。 数组中剩下的数字已经不够 k/2 个，这个时候，我们只需要选取数组最后一个数字作为比较对象，若进行排除则整个数组排除即可。当然，相应的，我们排除的数字个数可能就不再是 k/2，更新 k 值的时候需要注意。 如果一个数组已经全部排除，则说明中位数存在于另外一个数组中，我们直接返回另外一个数组中第 k 个数即可。 若 k 为 1，则到了循环的终点，我们返回两个数组中首元素值更小的那个数即可。 &emsp;&emsp;时间复杂度：$O(log(m+n))$，其中 $m、n$ 分别是两个数组的大小。因为初始 $k=(m+n)/2$ 或 $k=(m+n)/2+1$，而每一次搜索会将范围减半。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对搜索结果进行记录。 4.划分数组解法&emsp;&emsp;从另一个角度想，中位数其实就是将数组分割为两个相等长度的子集。而数组的长度我们是知道的，则每个子集的长度我们也是知道的。则我们在 i 处将 nums1 分割为两部分时，相应也就知道了在 nums2 中的哪一处分割为两部分，假设为 j。如果满足 nums1[i-1] &lt;= nums2[j] 且 nums1[i] &gt;= nums2[j-1]。即左半部分为 nums1[0 ~ i-1] 和 nums2[0 ~ j-1]，右半部分为 nums1[i ~ m-1] 和 nums2[j ~ n-1]。此时可以满足左边的所有值都小于右边，则中位数就找到了。这样我们只需要对其中某一个数组进行二分查找，时间复杂度会更低一些。 若 m+n 为偶数，则我们应该有 $i+j=m-i+n-j$。 中位数是 (max(nums1[i-1], nums2[j-1])+min(nums1[i], nums2[j]))/2。 若 m+n 为奇数，则我们应该有 $i+j=m-i+n-j+1$。（左半部分多一个数） 中位数是 max(nums1[i-1], nums2[j-1])。 根据上面两点可以得到 $j = \\lfloor\\frac{m+n+1}{2}\\rfloor-i$。 我们令 nums1 的长度小于 nums2 的长度，则可以保证 $j\\in[0,n]$。 如果 nums1 长度大于 nums2 则交换两个数组即可。 对于整个数组都存在某半部分的情况，我们可以令 nums1[-1]=nums2[-1]=INT_MIN，nums1[m]=nums2[n]=INT_MAX。这样不会对左半部分的最大值或者右半部分的最小值产生影响。 &emsp;&emsp;PS:：代码来自官方题解。 &emsp;&emsp;时间复杂度：$O(log(min(m,n)))$，其中 $m、n$ 分别是两个数组的大小。这是因为我们只对长度较小的那个数组进行了二分查找。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对查找结果进行记录。"},{"title":"Leetcode 3.无重复字符的最长子串","date":"2021-05-19T09:41:00.000Z","url":"/2021/05/19/Leetcode%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 示例 2: 示例 3: 示例 4: 提示： $0 &lt;= s.length &lt;= 5 * 10^4$ $s$ 由英文字母、数字、符号和空格组成 链接： 题目分析&emsp;&emsp;由于题目要求寻找的子串是连续的，则我们可以使用滑动窗口的思想。也就是说，right 向右遍历添加字符进入窗口，而当添加的字符与窗口中已有字符重复时，我们将左边的字符移出窗口，直到字符不再重复。而我们维护这样一个窗口，若窗口是目前最大长度时，对这个长度进行记录即可。查找字符是否存在使用一个哈希表解决。注意字符串为空的情况直接返回 0。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是字符串的长度。滑动窗口的两头指针分别遍历了一次字符串。&emsp;&emsp;空间复杂度：$O(|\\Sigma|)$，$\\Sigma$ 是字符串中出现过的字符集，$|\\Sigma|$ 表示字符集的大小。因为我们需要维护字符串出现过的字符构成的哈希表。"},{"title":"Leetcode 2.两数相加","date":"2021-05-19T09:02:00.000Z","url":"/2021/05/19/Leetcode%202.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":[["C++","/tags/C/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1： 示例2： 示例3： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 链接： 题目分析&emsp;&emsp;类似于大数加法，链表中的数字是逆序存储的，刚好就像我们列竖式计算的过程，直接将每一位相加，并将进位 carry 存储即可。结果中的某一位为 res[i] = (l1[i] + l2[i] + carry) % 10 而 carry = (l1[i] + l2[i] + carry) / 10。而对于不一样长的链表，我们只需认为短链表的结点值为 0。迭代遍历整个链表并将结果不断增加到结果链表中得到答案。需要注意的点是，若两个链表的所有结点都已经遍历完毕而仍然有进位，需要将进位也添加到结果链表中；对于链表的迭代，一定要先判断指针是否已经为空。 &emsp;&emsp;时间复杂度：$O(max(m,n))$，其中 $m、n$ 分别是两个链表的长度。因为只需遍历一次链表，而对于每个结点处理的时间开销为 $O(1)$。&emsp;&emsp;空间复杂度：$O(1)$。返回值不计入空间开销，而我们只需要一个变量存储进位值，无需其他额外开销。"},{"title":"Leetcode 1.两数之和","date":"2021-05-19T08:20:00.000Z","url":"/2021/05/19/Leetcode%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 示例 1： 示例 2： 示例 3： 提示： $2 &lt;= nums.length &lt;= 10^3$ $-10^9 &lt;= nums[i] &lt;= 10^9$ $-10^9 &lt;= target &lt;= 10^9$ 只会存在一个有效答案 链接： 题目分析1.暴力解法&emsp;&emsp;我们可以直接对数组进行双层遍历，对于整数 nums[i]，寻找数组中是否存在另外一个整数 nums[j] 使得他们的和为 target，如果存在则返回答案。当然，由于我们在寻找 nums[j] 时，位于 nums[i] 前面的元素已经和 nums[i] 匹配过，而且每个元素不能使用两次，因此向后寻找元素进行匹配即可。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 是数组元素数目。最坏情况下对任意两个元素都需进行比较。&emsp;&emsp;空间复杂度：$O(1)$。只需进行求和比较，无需额外的空间。 2.哈希表解法&emsp;&emsp;从暴力解法我们可以注意到，我们对查找的要求较高。如果能够快速找到 target-nums[i] 的数组下标，则可以较快完成目标。我们考虑使用 unordered_map 存放元素及其下标。依然是遍历整个数组，对于每个元素 nums[i]，查找 target-nums[i] 是否存在于哈希表中，如果有，则返回 target-nums[i] 的下标以及 i；如果没有，则将 nums[i] 的值和下标添加到哈希表中。&emsp;&emsp;对于重复元素，case1：有三个或以上，则说明这些重复元素并不构成解（因为只会存在一个有效答案），没有影响；case2：有两个，且为解，则只能两个重复元素的和刚好为 target（因为只会存在一个有效答案），对于这种情况，第二个重复元素并未进入哈希表就已经作为答案进行返回；case3：有两个，且不为解，没有影响。因此对于重复元素直接进行插入覆盖不会产生问题。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是数组元素数目。只进行一次遍历，哈希表每次查找的时间复杂度为 $O(1)$。&emsp;&emsp;空间复杂度：$O(n)$，$n$ 是数组元素数目。主要为建立哈希表的开销。"},{"title":"C++华容道","date":"2019-07-25T16:00:00.000Z","url":"/2019/07/26/C++%E5%8D%8E%E5%AE%B9%E9%81%93/","tags":[["C++","/tags/C/"],["程序设计","/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"],["Project","/tags/Project/"]],"categories":[["Project","/categories/Project/"]],"content":"引言&emsp;&emsp;快乐的暑假就需要折腾来充实自己，折腾的第一项是自己写一些游戏，第一个project选择了华容道。 华容道 （中国民间智力游戏） &emsp;&emsp;华容道是古老的中国民间益智游戏，以其变化多端、百玩不厌的特点与魔方、独立钻石棋一起被国外智力专家并称为“智力游戏界的三个不可思议”。它与七巧板、九连环等中国传统益智玩具还有个代名词叫作“中国的难题”。据《资治通鉴》注释中说“从此道可至华容也”。华容道原是中国古代的一个地名，相传当年曹操曾经败走此地。由于当时的华容道是一片沼泽，所以曹操大军要割草填地，不少士兵更惨被活埋，惨烈非常。 &emsp;&emsp;通过移动各个棋子，帮助曹操从初始位置移到棋盘最下方中部，从出口逃走。不允许跨越棋子，还要设法用最少的步数把曹操移到出口。曹操逃出华容道的最大障碍是关羽，关羽立马华容道，一夫当关，万夫莫开。关羽与曹操当然是解开这一游戏的关键。四个刘备军兵是最灵活的，也最容易对付，如何发挥他们的作用也要充分考虑周全。“华容道”有一个带二十个小方格的棋盘，代表华容道。 --来源：百度百科 &emsp;&emsp;详见 华容道-百度百科 &emsp;&emsp;初步考虑使用打印字符来代表棋子。使用getch()函数来获取键盘输入，然后通过算法得出相应的棋子坐标变化，并重新打印。&emsp;&emsp;游戏中采用 wasd 进行移动，空格键切换选择状态。当状态为未锁定时，wasd 为切换人物；当状态为锁定时，wasd 为移动人物。 代码目录 color.h&emsp;&emsp;此段代码对输出流进行了重载，可以通过调用函数 cout &lt;&lt; red 直接将控制台输出颜色转变为红色，其他颜色同理。&emsp;&emsp;代码来源于CSDN，感谢。 piece.h&emsp;&emsp;首先定义一个piece类，表示棋子。&emsp;&emsp;其含有变量lx、ly、rx、ry，分别表示棋子的左上角横纵坐标以及右下角横纵坐标；变量status表示棋子的状态，0表示未选中状态，1表示选中状态，2表示锁定状态。代码如下。 &emsp;&emsp;2.0版本时加入了多个关卡，主要区别是棋子的初始位置不同。因此定义一个chapter类，表示一个关卡。变量name储存关卡名字，变量status表示选中/未选中状态。代码如下。 &emsp;&emsp;main.cpp 中的 main 函数定义了 chapter a[12]、piece hrd[10]，分别表示12个关卡和10枚棋子，并在各个函数中以指针形式进行通讯。 &emsp;&emsp;1.0版本选择的关卡是横刀立马，各棋子初状态如下： &emsp;&emsp;于是定义各棋子的编号如下： 棋子 张飞 曹操 马超 黄忠 关羽 赵云 兵1 兵2 兵3 兵4 编号 0 1 2 3 4 5 6 7 8 9 &emsp;&emsp;我们定义5×4棋盘中左上角的坐标为（0，0），以此得出棋盘上各位置的坐标。&emsp;&emsp;我们初定提供12个关卡，按照各关卡各棋子的初始坐标，我们可以按照如下代码定义两个结构体的初始化函数。其中 coordinatex、coordinatey 函数初始化的值均为左上角坐标。 &emsp;&emsp;我们设定初始选择的关卡是横刀立马，于是其变量status的值为true，初始状态的选择在曹操身上，于是hrd[1].status的值为1。&emsp;&emsp;值得一提的是，变量lx、ly、rx、ry存放的是在控制台打印的实际坐标，我们在控制打印棋盘的单位格子大小为3×6，于是可以看到四个变量初始化的代码块进行了相应的坐标换算。X、Y表示棋盘即墙体的初始打印位置（左上角），以方便棋盘的整体移动，为后续调整棋盘在控制台的位置提供了较大的便利。在这里我们可以直接在文件头部进行define，后续需移动整个棋盘时修改X、Y的值即可。 print.h&emsp;&emsp;需包含的头文件如下，同时仍然对X、Y进行定义。 &emsp;&emsp;首先我们有函数gotoxy，可以将运行窗口的光标移动到（x，y）的位置。调用此函数之后再进行打印可以实现在需要的位置打印。其中x为横向（列数），y为纵向（行数） &emsp;&emsp;该头文件的函数一览： &emsp;&emsp;函数 printTimes、changeColor 代码如下。设定未选择状态为白色，选择状态为蓝色，锁定状态为红色。 &emsp;&emsp;函数 printSelectionScreen、printchapter 代码如下。初始化关卡选择并进行打印。打印位置通过不断运行观察调整得到。 &emsp;&emsp;打印效果如图 &emsp;&emsp;函数 printMap、printWall 代码如下。 &emsp;&emsp;printWall 函数打印墙体效果如图。 &emsp;&emsp;函数 printpiece 代码如下。提供了打印各棋子的总接口。选择打印颜色也在此处完成。 &emsp;&emsp;函数 printZF 代码如下。在（x，y）处开始打印棋子，一行一行打印。（x，y）为左上角坐标。此处提供一个打印示例，其他各棋子的打印函数也大抵如此。 &emsp;&emsp;打印棋子初始状态及关卡名称后的效果如图。 &emsp;&emsp;函数 erasepiece 代码如下。提供了擦除各型号大小棋子的总接口。不同棋子对应各自大小的擦除函数。 &emsp;&emsp;示例擦除函数代码如下。在对应位置打印空格即可实现棋子的擦除。注意每格大小3×6（高×宽） &emsp;&emsp;至此，print.h 头文件已经完成。 control.h&emsp;&emsp;需包含的头文件有 conio.h 和 print.h 。其中 conio.h 头文件用于获取键盘输入。仍然对 X、Y 进行宏定义。&emsp;&emsp;该头文件所包含的函数一览： &emsp;&emsp;函数 choosecontrol 的代码如下。返回值为选择的关卡编号。可以利用此值进行棋盘初始化。 &emsp;&emsp;getch()函数为获取一次键盘输入。当输入wasd时，我们需要改变相应的关卡。以 case &#39;w&#39; 为例。 &emsp;&emsp;获取输入后我们对关卡状态进行更新，并且重新打印，体现在了游戏界面上。 &emsp;&emsp;函数 clickcontrol 代码如下。获取键盘输入并调用相应函数，作为总控制中心。&emsp;&emsp;返回值为 10000 时表示回到选择关卡界面，返回值为 10001 时表示当前关卡重新开始，返回值为 1 表示继续进行游戏。值得一提的是，down 函数是有 bool 返回值的，因为游戏胜利的最后一步一定是曹操从下方缺口逃出。因此 down 函数的返回值表示当前关卡通过与否。若通关返回 true，相应地 clickcontrol 函数返回 10086 。 &emsp;&emsp;函数 click 代码如下。通过循环不断调用 clickcontrol 函数，若需回到主界面，则返回 true （通关也是返回主界面），若需当前关卡重新开始，则返回 false 。当 clickcontrol 返回 10086 即关卡胜利时，我们可以知道游戏的最后一步一定是曹操出现在缺口上，于是可以重新打印曹操使曹操“越过棋盘”，并打印游戏通关恭喜字句，同时使用 getchar() 函数使游戏暂停。 &emsp;&emsp;游戏通关效果如图。 &emsp;&emsp;函数 space 代码如下。使用循环检测10枚棋子中处于选择/锁定状态的，切换其状态，并对其重新进行打印（颜色改变）。 &emsp;&emsp;函数 movejudge 代码如下。我们定义棋子的时候记录了其左上角及右下角。当棋子空间 judge 不与棋子 i 重合时，我们返回 true 。由于棋子占领的空间是矩形，因此未重合时，应该至少两个棋子占领的 x 范围或者 y 范围没有交集。 &emsp;&emsp;接下来看看 up 函数。 &emsp;&emsp;可以看到，核心难点即在于对于不同大小的棋子，我们该如何在切换棋子的时候，选择到尽可能符合认知的那枚棋子，而且还要保证所有的棋子都一定能被选择到。该程序还有不足之处便是只能选择严格在其正上方最靠近的棋子，若仍然不止一枚的话只会打印编号靠前的第一枚。如以下这种情况，关羽进行up操作，只会选择两个兵中编号靠前的那一个。 兵 兵 关羽 &emsp;&emsp;其他的 down、left、right 函数基本如上，只需改变相应的变量名和一些常量值，这里便不再赘述。&emsp;&emsp;此外，down 函数中增加了一行代码如下。当曹操到达这个位置（缺口上方）之后按下down时，曹操逃脱，游戏胜利，返回 true 。注意此行代码必须在处于低端格子直接返回之前，因为此时的曹操也同样是处于低端格子。 &emsp;&emsp;至此，control.h 完成。 main.cpp&emsp;&emsp;main.cpp 的代码如下。上面已经说到，click 的返回值为 true 时返回选择界面，返回值为 false 时重新打印关卡。在主函数中得到了体现。另外，主函数的另一个功能是声明了关卡和棋子，并以指针形式传入各函数进行相应操作。 &emsp;&emsp;至此便完成了所有的代码。 历程 v 0.5 &emsp;2019-7-20还没有想好用 wasd 进行切换人物的算法，于是先写出了一个用 space 换人，wasd 移动的版本，由于人物有10个之多，用 space 按照编号顺序切换人物显得非常僵硬，于是不算为第一个版本，算是一个未完成品吧。 v 1.0 &emsp;2019-7-21实现了 wasd 切换人物，空格切换选择/锁定状态，大大提高游戏操作的流畅性。 v 2.0 &emsp;2019-7-22加入了不同的关卡，因此对整套代码进行重构，使用较易理解的5×4坐标，便于后续关卡的加入。 win7版 &emsp;2019-7-23发现win7控制台打印的字符大小与win10不同，字符打印的方框没有重合。修改了打印函数即解决问题。 Future 考虑可以锁定时直接移动。因为移动的选择只有一个或两个。 五虎将只需满足大小为1×2，横竖并不是严格定义的。重构定义代码才能加入更多的关卡。 学习鼠标捕捉并采用鼠标操作。 重构后加入界面 下载&emsp;&emsp;采用photoshop为游戏制作了图标，文件已存放在 这里 。可自行下载并添加到工程中。 &emsp;&emsp;所有代码已经存放到  ，可自行下载查看。 写在最后&emsp;&emsp;很开心，考试月萌生的暑假要好好学习的想法在刚考完试浪完之后还是能开始实施（寒假的时候也有想法但是最终浪过去了）。写完这个项目的代码之后决定要写成博客于是又挖了新坑。花了好几天部署了博客，当然要好好感谢坎爷，基本是克隆了坎爷的博客然后再进行修改的。然后书写这个博客又花了两天，写出来和讲出来的区别还是很大的啊，markdown也是以前没怎么接触（其实以前在matrix上写题目说明用的就是markdown的格式，但是只写过一点点。而且当时也不知道那是什么），书写的确花了不少时间。不过经过这些天来的摸索以后应该就是轻车熟路了。&emsp;&emsp;回头想想，这几天接触学习了好多新东西啊。在路上总是好事。"},{"title":"Hello World","date":"2019-07-23T16:00:00.000Z","url":"/2019/07/24/helloworld/","tags":[["test","/tags/test/"]],"categories":[["Test","/categories/Test/"]],"content":"第一篇博客，作为测试。 那就按照惯例编写一个hello world吧。 试一试 $\\LaTeX$ 公式能不能正常显示 斐波那契数列通项公式：$a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$ "}]