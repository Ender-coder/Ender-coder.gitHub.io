[{"title":"Leetcode 75.颜色分类","date":"2021-06-16T09:41:00.000Z","url":"/2021/06/16/Leetcode%2075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 进阶： 你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 链接： 题目分析1.计数&emsp;&emsp;题目中要求使用原地算法，并且最好不用排序函数，而数字只有三种，我们可以很容易想到使用计数的方法。先遍历一次数组记录 0 和 1 的个数，剩下的就是 2，之后对整个数组进行重写即可。一共需要两次遍历。 2.双指针&emsp;&emsp;由于只有三种数字，最后的结果中 0 一定在左边，2 一定在右边。那我们只进行一次遍历，每次将 0 放到左边，2 放到右边，最后剩下的 1 就都在中间，也就完成了。我们需要两个指针 p0 和 p2 分别指示 0 和 2 的边界位置。&emsp;&emsp;注意我们是从左往右遍历，而 p2 是位于右边，因此与 p2 交换后，i 所指示的位置的新数字依然是没有处理过的，因此 i 不能自增。 3.官方题解&emsp;&emsp;官方题解中还提到了其他同样使用指针的方法。一种是单指针的方法，先遍历一次处理 0（遇到 0 就交换到最左边），再从 0 结束的位置遍历一次处理 1，一共需要两次遍历。 &emsp;&emsp;还有一种是另外一种双指针的方法，记录的是 0 和 1 的边界位置，放入 0 时两个指针同时右移（若有 1 被 0 替换还需在末尾补 1），放入 1 时 p1 右移，这种方法也是一次遍历。 复杂度分析&emsp;&emsp;以上的所有方法不管是两次遍历还是一次遍历，时间复杂度都是 $O(n)$，而作为原地算法，空间复杂度都是 $O(1)$。"},{"title":"Leetcode 72.编辑距离","date":"2021-06-16T08:24:00.000Z","url":"/2021/06/16/Leetcode%2072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 示例 2： 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 链接： 题目分析&emsp;&emsp;我们需要做的是将 word1 转换到 word2，而每一步操作都只涉及到 1 个字母的变化，一共有 3 种操作，也即插入、替换、删除。其中插入和删除的操作比较难以处理，可能会陷入死循环，有没有办法解决呢？其实 word1 的删除操作和 word2 的插入操作是等价的。比如 abcd -&gt; abc，既可以看做是左边删除了一个 d，变成 abc = abc，也可以视为右边添加了一个 d，变成 abcd = abcd，操作步数都是 1，同样能让两个单词相同。因此我们的方法有以下三种 word1 插入一个字符 word2 插入一个字符 word1 替换一个字符 &emsp;&emsp;注意到以上的操作方法次序对结果是没有影响的，因此我们可以从左到右逐步对字符进行操作，便可以使用动态规划的方法解决。我们逐步分析两个字符串，并保留操作次数最少的方法。dp[i][j] 的值表示 word1 的前 i 个字符与 word2 的前 j 个字符进行匹配需要的最少步数（也即它们的编辑距离）。而每次我们只在字符串的最后进行操作。我们分析状态转移方程，也即 dp[i][j] 的值如何确定。 如果最后一步操作是 word1 插入字符，也即进行了 dp[i][j-1] 的操作之后，我们将 word2 的第 j 个字符插入到 word1 最后。 如果最后一步操作是 word2 插入字符，也即进行了 dp[i-1][j] 的操作之后，我们将 word1 的第 i 个字符插入到 word2 最后。 如果最后一步操作是 word1 替换字符，也即进行了 dp[i-1][j-1] 的操作之后，我们将 word1 的第 i 个字符替换为 word2 的第 j 个字符（如果这两个字符本来就是相同的，则无需替换）。 &emsp;&emsp;以上的三种操作中，我们总是选取操作次数最小的那个作为 dp[i][j] 的值进行状态转移，最后就能够得到 dp[m][n] 也即 word1 转换为 word2 的最少操作数。而边界情况是什么样的？边界情况是其中某一个字符串为空的时候，操作数就是另一个字符串的字符数。也即 dp[0][j] = j，word1 为空时，word1 变为 word2 的操作就是往 word1 插入 j 个字符。同理，dp[i][0] = i。&emsp;&emsp;注意字符串的下标是从 0 开始的，因此 word1 的第 i 个字符是 word1[i-1]。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。我们进行了双层遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。也即动态规划所需的数组大小。"},{"title":"Leetcode 70.爬楼梯","date":"2021-06-15T17:03:00.000Z","url":"/2021/06/16/Leetcode%2070.%E7%88%AC%E6%A5%BC%E6%A2%AF/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 示例 2： 链接： 题目分析1.递归&emsp;&emsp;记得这道题是第一次学递归的时候就做的例题。爬 n 阶的楼梯，可以看做是爬了 n-1 阶的楼梯，最后一步再爬 1 个台阶；也可以看做是爬了 n-2 阶的楼梯，最后一步再爬 2 个台阶。而方法数就是这两种方法的和。这便是一个递归的过程，即有 $f(n)=f(n-1)+f(n-2)$。&emsp;&emsp;递归的终结条件是什么呢？还没开始爬的时候 $n=0$ 就是爬楼梯的开始，记为 1 种方法。而 $n=1$ 的时候，前一步只能爬 1 个台阶而不能爬 2 个台阶，因此方法数也是 1。&emsp;&emsp;PS：这种方法会超出时间限制。 &emsp;&emsp;时间复杂度：$O(2^n)$，其中 $n$ 为楼梯的阶数。一共 $n$ 层递归，而每一层递归我们都需要调用两次递归函数。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即递归的深度。 2.动态规划&emsp;&emsp;递归的方法虽然容易理解，代码也十分简洁，但是其实时间复杂度非常高，即使是简单题也是毫不意外地超出了时间限制。这是因为每层递归都会调用两次递归函数，而且这个操作存在的大量的重复计算，比如 $f(n-1)$ 的计算中也需要用到 $f(n-2)$。如何复用这些函数的值呢？我们可以很容易想到动态规划。&emsp;&emsp;与递归相反，我们正向地推导这个过程。上面已经推出了状态转移方程 $f(n)=f(n-1)+f(n-2)$，起始条件也即 $f(0)=1$，$f(1)=1$。我们注意到状态转移只与前两个状态有关，而最后的结果是最后一个状态，则我们可以丢弃前面的状态，只用三个变量分别存储当前的状态、前一个状态、前两个状态。result 表示 $f(n)$，one 表示 $f(n-1)$，two 表示 $f(n-2)$。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即循环的次数。&emsp;&emsp;空间复杂度：$O(1)$。经过优化，我们只需要使用三个变量来进行状态转移，因此所需空间是常数级的。 3.数学方法&emsp;&emsp;通过前面的状态转移方程和初始值我们可以发现，其实这就是一个斐波那契数列。而通过 特征方程法 是可以得到斐波那契数列的通项公式的，也即 $a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$。注意上面的通项公式是从 1 开始的，而我们的函数 $f$ 是从 0 开始的，因此在代入时需要将 n 加 1。 &emsp;&emsp;这个通项公式中包含了幂运算，具体时间复杂度取决于 CPU 的指令集，因此不分析。&emsp;&emsp;空间复杂度为 $O(1)$。 4.矩阵快速幂 - 官方题解&emsp;&emsp;来自于官方题解的方法，涉及了矩阵的知识。由于递推的关系可以视为矩阵相乘。 \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix} \\begin{bmatrix}f(n)\\\\f(n-1)\\end{bmatrix}= \\begin{bmatrix}f(n)+f(n-1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}&emsp;&emsp;则有 \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix}^n \\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}&emsp;&emsp;因此我们需要计算的就是 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^n$，可以将其拆分成 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}$，以此类推。计算的时间复杂度是 $O(\\log n)$，也即在较大的 $n$ 下，计算速度比动态规划更快。&emsp;&emsp;另外官方题解还提到了非齐次线性递推转化为矩阵快速幂的计算方法，上面的方法代码也包含其中。具体请阅读 爬楼梯 - 力扣官方题解。"},{"title":"Leetcode 64.最小路径和","date":"2021-06-15T16:18:00.000Z","url":"/2021/06/16/Leetcode%2064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述： 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 示例 2： 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 链接：  题目分析 由于只能往右或往下走，则每一格最多来自两个方向（左边或者上边）。我们采用动态规划的方法，dp[i][j] 记录从左上角到 grid[i][j] 的最小路径和，从左到右，从上到下遍历 grid，直到右下角，得出答案 dp[m-1][n-1]。而每一格的最小路径和也即从左边或者上边选择值较小的那一个，然后加上本身的数值。 注意左上角的最小路径和也即其本身，第一列只能来自上边，第一行只能来自左边。 时间复杂度：O(mn)O(mn)O(mn)，其中 m、nm、nm、n 分别是 grid 的行数和列数。动态规划的过程对 grid 进行了一次遍历。 空间复杂度：O(mn)O(mn)O(mn)，其中 m、nm、nm、n 分别是 grid 的行数和列数。也即动态规划数组的大小。（可以优化到 O(min⁡(m,n))O(\\min(m,n))O(min(m,n))，具体方法是只存储上一行或者上一列的 dp 值）"},{"title":"Leetcode 62.不同路径","date":"2021-06-10T12:55:00.000Z","url":"/2021/06/10/Leetcode%2062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","tags":[["C++","/tags/C/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： 1&lt;=m,n&lt;=1001 &lt;= m, n &lt;= 1001&lt;=m,n&lt;=100 题目数据保证答案小于等于 2∗1092*10^92∗109 链接：  题目分析 这是一道很经典的数学题。机器人处在 m x n 的网格中，并且只能往右和往下移动，则从左上角移动到右下角，总的移动路程是一定的，一定是往右走了 n-1 步，往下走了 m-1 步，也即总的移动路程是 m-1+n-1。而不同的移动方案，也即是在 m-1+n-1 步中，选择其中的 m-1 往下（或者选择 n-1 步往右），也即是一个数学组合问题。答案就是 (m−1+n−1m−1)\\binom{m-1+n-1}{m-1}(m−1m−1+n−1​) 或 (m−1+n−1n−1)\\binom{m-1+n-1}{n-1}(n−1m−1+n−1​)。为了减少运算量，我们可以选择 m 和 n 其中更小的那个来计算。 虽然题目中保证答案小于等于 2∗1092*10^92∗109，也即答案不会超过 int 的范围，但是在计算的过程还是会超过，需要使用 long long int 类型。 时间复杂度：O(min⁡(m,n))O(\\min(m,n))O(min(m,n))，其中 m、nm、nm、n 分别是网格的行数和列数。也即计算组合数的时间复杂度。 空间复杂度：O(1)O(1)O(1)。我们只需要常数的空间存放变量。"},{"title":"Leetcode 56.合并区间","date":"2021-06-10T09:15:00.000Z","url":"/2021/06/10/Leetcode%2056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] = [start_i, end_i]$ 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 示例 2： 提示： $1 &lt;= intervals.length &lt;= 10^4$ $intervals[i].length == 2$ $0 &lt;= starti &lt;= endi &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;可以合并的区间存在着这样的性质：假设左端点靠左的区间为 interval_1，左端点靠右的区间为 interval_2，则有 interval_1-&gt;end &gt;= interval_2-&gt;start，也即存在重叠。则如果我们按照区间的左端点大小进行排序，则可以进行合并的区间一定是连续的。&emsp;&emsp;声明一个 result 数组作为结果返回，我们先将第一个区间加入结果。之后对于后面的每一个区间，我们有这样的操作：如果该区间和 result 中的最后一个区间不存在重合（满足 intervals[i]-&gt;start &gt; result[count]-&gt;end），则将其作为新区间加入到 result 中；若该区间与 result 中的最后一个区间重合，则更新 result 的最后一个区间，变成合并后的结果，也即 result[count]-&gt;end = max(result[count]-&gt;end, intervals[i]-&gt;end)。顺序遍历所有的区间后得到结果。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 为区间的个数。对所有的区间进行排序需要 $O(n\\log n)$ 的时间，而排序后只需要一次遍历，也即 $O(n)$ 的时间，因此总的时间复杂度为 $O(n\\log n)$。&emsp;&emsp;空间复杂度：$O(\\log n)$，其中 $n$ 为区间的个数。作为答案返回的数组不计入所需空间，则所需的额外空间也即排序所需要的空间。"},{"title":"Leetcode 55.跳跃游戏","date":"2021-06-10T08:50:00.000Z","url":"/2021/06/10/Leetcode%2055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","tags":[["C++","/tags/C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 示例 2： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $0 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;这道题目可以使用贪心的思想。对于某个位置 y 是否可以到达，需要满足两个条件：前面的某个位置 x 可以到达，x 可以跳跃到 y，也即有 x + nums[x] &gt;= y。那我们可以遍历数组，贪心地获取当前可以到达的最远位置，直到遍历到所有的可到达位置，若可以到达的最远位置没有超过数组的最后一个下标，则数组的最后一个下标不可达。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们最多只需要遍历一遍数组。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 53.最大子序和","date":"2021-06-09T09:04:00.000Z","url":"/2021/06/09/Leetcode%2053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析1.动态规划&emsp;&emsp;我们用 dp[i] 表示以 nums[i] 结尾的最大子序列和。那么 dp[i] 只有两种情况，第一种是 nums[i] 加上 dp[i-1] 所表示的那一段，第二种是 nums[i] 单独作为新的一段。而我们只需要保留这两种中较大的那一个。也即状态转移方程为 dp[i] = max&#123;dp[i-1]+nums[i], nums[i]&#125;。而我们所要求的结果也即 dp 数组中最大的值。&emsp;&emsp;另外我们通过观察可以发现，每一个 dp[i] 只取决于 dp[i-1]，并且在遍历的时候便可以边记录最大值，则其实我们无需建立一个 dp 数组，只需要一个变量 pre 来表示每一个 dp[i-1] 即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。 2.分治法 - 官方题解&emsp;&emsp;这是题目中提到的更为精妙的进阶方法，没有想到，参阅了官方题解 最大子序和 - 力扣官方题解。主要思路是利用了线段树，对于每一个区间 [l, r]，维护了 4 个变量，分别是 $lSum$，表示 [l, r] 中以 l 为左端点的最大子序和。 $rSum$，表示 [l, r] 中以 r 为右端点的最大子序和。 $iSum$，表示 [l, r] 的区间和。 $mSum$，表示 [l, r] 中最大子序和。 &emsp;&emsp;对于每一个区间 [l, r] 这些变量的赋值都来自于 [l, m] 和 [m+1, r] 的这些变量，也即分治后递归回升的整合。具体整合方法为 $iSum = iSum_l + iSum_r$，也即左右子区间的和即为该区间的和。 $lSum = max(lSum_l, iSum_l+lSum_r)$，也即要不是左区间的 $lSum$，要不是整个左区间加上右区间的 $lSum$。 $rSum = max(rSum_r, iSum_r+rSum_l)$，同理，要不是右区间的 $rSum$，要不是整个右区间加上左区间的 $rSum$。 $mSum = max(mSum_l, mSum_r, rSum_l+lSum_r)$，也即如果 $mSum$ 不跨越 m，则可以是左区间或者是右区间的 $mSum$，如果跨越 m，则是左区间的 $rSum$ 加上右区间的 $lSum$。 &emsp;&emsp;最后递归到最外层，求出 [0, nums.size()-1] 区间的 $mSum$ 即可。 &emsp;&emsp;时间复杂度：$O(n)$，这样的方法下其实相当于是进行了一颗二叉树的先序遍历。&emsp;&emsp;空间复杂度：$O(\\log n)$，也即递归的深度。 &emsp;&emsp;这样的方法下使用了递归，实际运行的时间比动态规划更长，也需要更多的空间，但是它的意义是它可以解决任意区间下的最大子序和问题，并且建立成为一颗树之后，所有的子区间信息都可以用堆的方法来存储，就可以在 $O(\\log n)$ 的时间内找到任意区间的答案。并且假如序列中的某些值发生修改，只需要对有影响的区间值进行修改维护，所需的时间只要 $O(\\log n)$，便可以继续使用。这样的特性对于大规模的查询优势便十分明显。"},{"title":"Leetcode 49.字母异位词分组","date":"2021-06-09T08:30:00.000Z","url":"/2021/06/09/Leetcode%2049.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 链接： 题目分析&emsp;&emsp;题目中要求我们给字符串分类，很容易可以想到哈希的思想。我们可以建立一个哈希表，把一组字母异位词放到同一个 key 里作为哈希表的值。那么如何选取 key 值呢？观察字母异位词的共同点，它们的字母是相同的，但排列不同，也即是说，经过排序，它们会变成同一个字符串。则我们可以将这个排序好的字符串作为这一组字母异位词的 key 值。遍历所有的字符串加入哈希表之后，哈希表中的每一个 key 即对于一组字母异位词，将哈希表转化为结果即可。 &emsp;&emsp;时间复杂度：$O(nk\\log k)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。因为我们总共需要添加 $n$ 个字符串，而每个字符串需要 $O(k\\log k)$ 的时间排序，$O(1)$ 的时间加入到哈希表中，$O(k)$ 的时间复制到结果中。因此最后的总时间复杂度为 $O(nk\\log k)$。&emsp;&emsp;空间复杂度：$O(nk)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。也即哈希表的开销。 官方题解&emsp;&emsp;官方题解中将字符串加入到 vector 中的使用的函数都是 emplace_back，通过搜索学习发现原来是 C++11 的新特性，这个函数是将参数而不是对象传递给构造函数，而构造函数直接在容器空间中构造元素，因此省去了一次构造临时对象的过程，减少了内存开销。"},{"title":"Leetcode 48.旋转图像","date":"2021-06-08T17:21:00.000Z","url":"/2021/06/09/Leetcode%2048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","tags":[["C++","/tags/C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 示例 2： 示例 3： 示例 4： 提示： matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 链接： 题目分析&emsp;&emsp;题目要求我们使用原地算法，也即直接对矩阵进行操作。通过观察我们可以发现，顺时针旋转 90 度，也即每 4 个位置进行了依次更替。如下图所示。 &emsp;&emsp;一共有多少组需要进行这样的更替呢？其实也就是矩阵的 1/4。下面以 4 × 4 和 5 × 5 的矩阵为例展示需要旋转的范围。我们只需要以左上角的色块为起点，对每一个位置进行对应位置的依次更替即可。需要注意依次更替的坐标对应关系，还有矩阵宽度为奇数时的划分方式（中心块无需更替）。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 为矩阵的宽度。我们其实就是对矩阵的每个位置进行了相应的更替，需要操作的子矩阵大小为 $O(\\lfloor{\\frac{n+1}{2}}\\rfloor\\times\\lfloor{\\frac{n}{2}}\\rfloor)=O(n^2)$，每次操作 5 步，为常数。&emsp;&emsp;空间复杂度：$O(1)$。原地算法，只用到了常数的额外空间。 官方题解&emsp;&emsp;官方题解中提到了另外一种巧妙的方法，也即利用翻转代替旋转。先将矩阵上下翻转，再按左上到右下的主对角线翻转，也可以得到答案。 "},{"title":"Leetcode 46.全排列","date":"2021-06-08T15:40:00.000Z","url":"/2021/06/08/Leetcode%2046.%E5%85%A8%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 6$ $-10 &lt;= nums[i] &lt;= 10$ nums 中的所有整数 互不相同 链接： 题目分析&emsp;&emsp;全排列也即题目中所给数字填在不同的位置构成的所有情况，我们可以按顺序从左到右填上数字，利用回溯的方法即可穷举所有的情况。我们需要填入的数字也即 nums 数组，如何标记已经填入的数字呢？一个方法是维护一个布尔数组用于记录，将已填入的数字标记为 true。每次填入时按顺序遍历，寻找未填入的数字进行填入，并更新这个标记。回溯之后记得将标记回溯为 false。 &emsp;&emsp;上面的代码我们可以发现，每一次填数时，都需要遍历 flag 数组寻找未填入的数字，这样需要的时间更长，也需要额外的空间，有没有什么办法可以不需要这个标记数组呢？答案是肯定的。我们可以将 nums 数组分割为两个部分，一部分表示已经填入的数，一部分表示未填入的数，每次填入一个数，就将其与分割线的位置交换，例如 &#123;2, 3, | 4, 5, 6&#125; 这样的数组，下一个填入 6 时就将 4 与 6 交换，并且移动分割线，变成 &#123;2, 3, 6, | 5, 4&#125;，这样每次只需要从分割线的位置开始遍历就可以了，并且不需要额外的空间进行标记。值得注意的是，这样的交换会打乱数组的顺序，所以最后输出的结果并不是按照字典序来排列的。题目中说明可以按照任意顺序返回答案，因此可以这样做，如果有要求按照字典序，则只能按照上面的做法。 &emsp;&emsp;时间复杂度：$O(n\\times n!)$，其中 $n$ 是数组的大小。因为我们遍历了所有的排列，全排列的个数为 $n!$。 而对于每一个解，我们都需要 $O(n)$ 的时间将其复制到答案数组中，因此总的时间复杂度为 $O(n\\times n!)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。因为作为答案返回的数组不计入所需空间中，而我们需要的额外空间即递归调用的深度，最大深度为 $n$。 官方题解&emsp;&emsp;看完官方题解才发现，我们在动态维护的 nums 数组，左边表示的已填入的数字就是按照填入的顺序进行排列的，因此可以不用额外的一个 now 数组对结果进行存储，在填完所有的数字后 nums 即为这种排列本身，将其复制到答案中即可。 "},{"title":"Leetcode 42.接雨水","date":"2021-06-08T06:37:00.000Z","url":"/2021/06/08/Leetcode%2042.%E6%8E%A5%E9%9B%A8%E6%B0%B4/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 示例 2： 提示： 链接： 题目分析&emsp;&emsp;这道题有点像 Leetcode 11.盛最多水的容器，因此也是考虑用双指针的做法。与那道题不同的是，这里的每个柱子并不是没有厚度的“壁”，而且对于所有的“坑”都会盛上水，而不是只选取其中两个壁之间盛水。但是思路应该是一致的，我们可以从两边往中间搜索。这是因为观察可以发现，每个较低的柱子，只要两边有高于它的柱子，则可以填上水直到和较低的一边柱子平齐。而我们在利用双指针搜索的时候，优先扩展较低的那边，则可以保证未搜索的区域不会影响已搜索区域填水的高度。&emsp;&emsp;具体的算法是，维护两个变量记录左边已搜索区域的最大高度 maxleft 和右边已搜索区域的最大高度 maxright，而 left 和 right 分别记录当前搜索的左右指针（下标）。如果当前是左边的最大高度 maxleft 较小，则扩展左边，若出现了更高的柱子则更新 maxleft，较低的柱子则填上雨水直到和 maxleft 平齐，也即更新 water 值；同样的，如果是 maxright 较小，则扩展右边，相应地更新 maxright 或者 water 值。最后两个指针相遇的时候搜索结束，得到结果。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 官方题解&emsp;&emsp;下面的代码是官方题解中双指针的代码，减少了一次判断，将更新 max 值和 water 值（这里是变量 ans)整合到了一起。相应的指针相遇条件有所不同（因为我们上面的代码更新完 max 值也对指针进行了移动，因此指向的永远是未搜索的区域，必须两个指针已经重合后错开才算搜索完毕）。&emsp;&emsp;官方题解中还有动态规划和栈等其他解法，也可以提供一定的解决思路，时间复杂度都是一样的 $O(n)$，但是动态规划和栈解法均需要 $O(n)$ 的空间。感兴趣的可以阅读 接雨水 - 力扣官方题解。 "},{"title":"Leetcode 39.组合总数","date":"2021-06-07T17:45:00.000Z","url":"/2021/06/08/Leetcode%2039.%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 示例 2： 提示： $1 &lt;= candidates.length &lt;= 30$ $1 &lt;= candidates[i] &lt;= 200$ candidate 中的每个元素都是独一无二的。 $1 &lt;= target &lt;= 500$ 链接： 题目分析&emsp;&emsp;题目要求所有的可行解，则依然可以使用回溯的方法来进行搜索遍历，也即对于每一个数 candidates[i]，都可以选择是否将其加入结果中，然后再转化为搜索 target-candidates[i] 的问题。为了避免产生重复解，我们按照 candidates 的顺序添加，也即若当前选择不添加 candidates[i]，则转化的子问题也不能再添加 candidates[i]。注意到题目中的数字可以无限制重复选取，则我们每次都需要保持从上一次添加的数字开始（也即上一次添加的数字仍然可以添加）。每当 target 为 0，意味着当前添加的数字的和为 target，也即找到了一组解，将其添加到结果列表中。&emsp;&emsp;而为了加快搜索速度，我们可以进行剪枝。比如我们可以先对 candidates 进行排序，当 target 已经小于当前想添加的数字时，也肯定小于后面所有的数字，则都不会是结果，则可以直接跳出循环返回。 &emsp;&emsp;时间复杂度：$O(S)$，$S$ 是可行解的长度之和。我们遍历了所有的可行解得到结果，而对于不可行的情况马上剪枝，则时间复杂度是可行解的长度之和。因为这道题确实比较难给出一个较紧密的上界。对于每个数字选或者不选，一共拥有非常多的可能，这是指数级别的。但是我们进行的剪枝可以排除掉非常多的情况，因此实际的运行情况不好以target 的大小或者是 candidates 的大小界定。&emsp;&emsp;空间复杂度：$O(target)$。作为结果返回的数组不计入所需空间中，而所有的数字都是正整数，则最大的可行解长度也就是 target 的值（全由 1 构成可行解），这也是我们栈递归的最大深度，因此空间复杂度为 $O(target)$。"},{"title":"Leetcode 34.在排序数组中查找元素的第一个和最后一个位置","date":"2021-06-07T17:06:00.000Z","url":"/2021/06/08/Leetcode%2034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 10^5$ $-10^9 &lt;= nums[i] &lt;= 10^9$ nums 是一个非递减数组 $-10^9 &lt;= target &lt;= 10^9$ 链接： 题目分析&emsp;&emsp;这个题目仍然可以使用二分查找的思路，但是由于我们要找到的是 target 值在数组中的开始位置和结束位置，则我们可以转变一下思路，变成寻找到小于 target 的最大数和大于 target 的最小数，则若还有数存在它们中间，那就是 target 了。下面给出的代码中，ansleft 表示小于 target 的最大数下标，ansright 表示大于 target 的最小数下标，这两个数允许超出数组的界限，也即可以为 -1 或者 nums.size()，这样可以应对 target 在数组边界的情况。我们先寻找 ansleft，再从 ansleft 的右边寻找 ansright，这样既缩小了搜索范围，又可以保证 ansright 大于 ansleft。注意最后返回结果之前检查一下夹在中间的值是不是 target 就可以了。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 33.搜索旋转排序数组","date":"2021-06-07T16:12:00.000Z","url":"/2021/06/08/Leetcode%2033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 5000$ $-10^4 &lt;= nums[i] &lt;= 10^4$ nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 $-10^4 &lt;= target &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;对于有序数组的搜索我们一般都是使用二分查找的方法，但是题目中的数组经过了一次旋转，只是局部有序，是否还仍然能使用二分查找的方法呢？答案是肯定的。通过观察我们可以发现，我们在任意位置将旋转后的数组分割为两个部分，则仍然可以保证至少其中一部分是有序的。判断是否有序只需要将该部分的头尾两个值进行比较即可，非常便捷。那么便有以下情况。&emsp;&emsp;左边有序，也即 nums[0] &lt;= nums[mid]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。&emsp;&emsp;右边有序，也即 nums[mid] &lt;= nums[n-1]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 32.最长有效括号","date":"2021-06-03T12:39:00.000Z","url":"/2021/06/03/Leetcode%2032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= s.length &lt;= 3 * 10^4$ s[i] 为 &#39;(&#39; 或 &#39;)&#39; 链接： 题目分析1.动态规划&emsp;&emsp;我们用 dp[i] 表示以 s[i] 作为结尾的最长有效括号串长度。则可以得到以下性质，当 s[i] 为 ( 时，dp[i] = 0，这是因为有效的括号串一定是以右括号结尾的。而当 s[i] 为 ) 时最长有效括号串是怎么样的呢？&emsp;&emsp;假若 s[i-1] 为 (，则我们可以认为这个括号串是 dp[i-2] 的括号串加上了一个 ()，这样的括号串仍然是有效括号串，并且长度增加了2。即有 dp[i] = dp[i-2] + 2。&emsp;&emsp;假若 s[i-1] 为 )，则 s[i-1] 应该和 dp[i-1] 所表示的部分相匹配，如下图所示。而若 s[i] 能够匹配，则只能是匹配到 s[i-dp[i-1]-1] 为 (，与此同时，dp[i-dp[i-1]-2] 所表示的部分也能一并加入到有效括号串中。最后一共为 dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2。 &emsp;&emsp;而我们所要求的答案，便是 dp 数组中的最大值了。按照上面分析的状态转移公式遍历一次括号串即可。需要注意的是，以上的分析都是默认没有越界的情况，因此实际编写代码时均需要首先对这些下标是否存在进行判断。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为括号串的长度。因为我们只需要遍历一次字符串并更新 dp 数组即可得到结果。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为括号串的长度。即为 dp 数组的大小。 2.括号计数&emsp;&emsp;通过观察我们可以发现，只要左括号和右括号的数量一致，并且右括号不先于未匹配的左括号出现，换句话说，就是从左往右遍历时，左括号数量总是大于等于右括号数量，这样的括号串一定是有效的，这是因为只存在一种括号。则我们可以只维护两个计数器，分别表示左括号和右括号的数量，从左往右遍历一次字符串，每次遇到左括号就将左括号计数加1；遇到右括号就将右括号计数加1，并且进行以下判断：①若右括号数量等于左括号，则这是有效的括号串，长度为左右括号数量之和。②若左括号数量小于右括号，则说明出现了无法匹配的右括号，此时需要将左右括号的计数都重置为0，也即抛弃之前的部分，重新进行匹配。&emsp;&emsp;而对于左括号始终多于右括号的情况，例子 (()，我们没有一种状态是左括号数量等于右括号。则我们从右往左遍历，用类似的方法，让左右括号的含义交换即可解决。&emsp;&emsp;注意左右括号数量不相等时是不能保证有效的，例子 ()(()，这个时候左括号数量 3，右括号数量 2，有效的括号串长度并不是 right*2=4。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为括号串的长度。因为我们只需要分别从左和从右遍历两次字符串并更新计数器即可得到结果。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 31.下一个排列","date":"2021-06-02T10:31:00.000Z","url":"/2021/06/02/Leetcode%2031.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["字典序","/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 100 链接： 题目分析&emsp;&emsp;首先我们要分析 “字典序” 中下一个排列是什么，下一个排列是比当前排列大的最小的排列。&emsp;&emsp;为了获取到比当前排列 “大” 的排列，则表明在从左往右数的某一位中，新排列的数字比原排列的大，而在此之前所有的数字均与原排列一样。由于越往右表示的权重越小，则为了使新排列尽可能的 “小”，我们应该令改变的数字尽可能地靠右。另一方面，改变的数字必须从原数字的右边选取，并且必须比原数字大。那么靠右的极限是什么？应该是后面的每个数的右边均不存在比自己小的数了，也即意味着，右边的数是降序排列（包含相同）的。我们只需要从数组最后往前找，找到第一个降序的数（不包含相同），这样就找到了需要换数字的某一位数（最右的降序排列反着找就是升序排列，而我们要找到第一个不符合的数），我们把这个下标记为 left。&emsp;&emsp;为了使新排列尽可能的小，我们需要换的数字也必须尽可能的小，因此我们需要在右边的降序排列中找到比 nums[left] 大，但是又尽可能地小的数。也即从数组最后往前找，找到第一个比 nums[left] 大的数（此时相当于是升序查找的，因此可以保证尽可能地小），我们把这个数记为 nums[right]。&emsp;&emsp;将 nums[right] 与 nums[left] 交换后，已经可以保证新排列比原排列大，为了使新排列尽可能地小，我们需要另 nums[left] 之后的序列变为升序序列，这样是最小的情况。而我们进行交换的时候，有 nums[right-1] &gt;= nums[right] &gt; nums[left] &gt;= nums[right+1]，则可以保证将 nums[left] 交换到 nums[right] 原本的位置后，右边的降序序列仍然是降序序列，则使用一个 reverse 函数将这部分反转为升序序列即可。同时的，这个函数是由双指针实现的，可以保证题目要求的原地修改。 &emsp;&emsp;对于题目中的边界情况有 ①原数组是降序排列（最大排列），这个时候寻找不到 nums[left]，也即寻找到的 left 值为 -1。而我们需要反转的区间原本应该是 left+1 ~ end，刚好 left 为 -1 时，反转区间从 0 开始，也即将整个数组进行反转，成为升序排列（最小排列），符合题意。②原数组只有一个数，这种情况其实等同于上一种情况，只是最大排列和最小排列是相同的，将其进行反转也不会改变什么，因此不需要进行单独处理。因此最后的代码如下。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只进行了两次扫描，一次反转操作，这些操作的时间复杂度均为 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个变量存放交换的数字位置，一个变量用于数组反转。"},{"title":"Leetcode 23.合并K个升序链表","date":"2021-06-02T08:40:00.000Z","url":"/2021/06/02/Leetcode%2023.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 示例 2： 示例 3： 提示： $k == lists.length$ $0 &lt;= k &lt;= 10^4$ $0 &lt;= lists[i].length &lt;= 500$ $-10^4 &lt;= lists[i][j] &lt;= 10^4$ $lists[i]$ 按 升序 排列 $lists[i].length$ 的总和不超过 $10^4$ 链接： 题目分析&emsp;&emsp;这道题是 Leetcode 21.合并两个有序链表 的升级版，原题链接以及相关题解都已经在这篇文章里面。 1. 顺序逐一合并&emsp;&emsp;根据我们对两个有序链表合并的思路，我们很容易想到，可以将其拆分成 k-1 个两链表合并的过程，逐一进行合并即可。代码中的 mergeTwoLists 函数即为合并两个有序链表的题解。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。这是由于对于每一次合并时间复杂度都是两个链表的长度和，而对于第 $i$ 次合并 lists[0] 的长度应该为 $i\\times n$，而 lists[i] 的长度为 $n$，一共需要合并 $k-1$ 次，则总的时间复杂度为 $O(\\sum^{k-1}_{i=1}(i+1)\\times n)=O(\\frac{(k+2)(k-1)}{2}\\times n)=O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。同两个链表合并，没有用到与 $k、n$ 规模相关的辅助空间。 2.分治合并&emsp;&emsp;从方法1中，我们可以发现，作为答案进行返回的 lists[0] 数组在每一次合并的时候都要遍历一次，这样的遍历是比较多余的，我们可以采用分治的思想进行优化。每一轮对每两条链表进行合并，得到 $\\frac{k}{2}$ 条链表，然后再继续合并得到 $\\frac{k}{4}$ 条链表，以此类推直到所有的链表合并完毕。下面所给的代码中已略去 mergeTwoLists 函数。 &emsp;&emsp;时间复杂度：$O(kn\\log k)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。对于第 $i$ 轮合并，每一条链表长度为 $2^{i-1}n$，则每一组合并的时间代价为 $O(2^in)$，一共有 $\\displaystyle\\frac{k}{2^i}$ 组。则总时间复杂度为 $O(\\sum^{\\infty}_{i=1}\\frac{k}{2^i}\\times2^in)=O(kn\\log k)$。&emsp;&emsp;空间复杂度：$O(\\log k)$，其中 $k$ 表示链表的数目。这是由于在分治合并中递归层数是 $\\log k$。 3.K个链表一起合并&emsp;&emsp;类似于合并两个链表的双指针思路，我们可以直接使用k个指针分别指向k条链表，每一次合并时进行比较并将最小的加入到答案链表中。实际上这是我第一个想到的解法，然而这样的方法每一次加入都需要进行比较，每一次比较都必须遍历k条链表（即便为空也进行判断），并且没有任何剪枝，时间复杂度是非常高的，最后以 952ms 的运行时间勉强通过了测例。&emsp;&emsp;代码中的 flag 表示了当前是否获得第一个非空链表的头结点，这个结点值作为每一轮比较的初值；当所有的链表都为空时也即合并完毕。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共有 $kn$ 个结点需要进行添加，而每一次添加都需要对 $k$ 个链表的头结点进行遍历比较得到最小值，因此时间复杂度为 $O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。对于每一次添加我们只需要维护两个变量分别记录最小值以及最小值所在的链表。 4.合并后排序再连接&emsp;&emsp;简单粗暴的解法，直接按顺序读取所有的结点到数组中存放，然后对整个数组进行排序，之后再逐一连接起来。出乎意料的是，这样的运行时间其实蛮快的。真是暴力而又省事的解法。 &emsp;&emsp;时间复杂度：$O(kn\\log(kn))$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共 $kn$ 个结点，将其逐一添加到数组中需要 $kn$ 的时间代价，而后进行排序我们认为是 $O(kn\\log(kn))$ 的，其实他们已经相对有序，相当于已经进行了一部分的分治排序，sort 函数底层如果有实现相对于的优化的话实际耗时是比较短的。最后重连接的时候也需要 $kn$ 的时间代价。&emsp;&emsp;空间复杂度：$O(kn)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。我们开辟了一个新的数组用来存放 $kn$ 个结点。"},{"title":"Leetcode 22.括号生成","date":"2021-05-24T05:49:00.000Z","url":"/2021/05/24/Leetcode%2022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 8 链接： 题目分析&emsp;&emsp;类似于 Leetcode 17.电话号码的字母组合，我们要获得所有的括号排列组合，则可以使用回溯的方法，维护一个字符串，每次加入一个左括号或者右括号，直到所有的括号添加完毕得到一个结果，再回溯删除，添加另外一种括号，如此穷举得到所有的结果。我们使用 n 来记录还未添加的左括号数目，使用 left 来记录还未匹配的左括号数目，则可以添加左括号的条件是 n &gt; 0，可以添加右括号的条件是 left &gt; 0，当 n == 0 &amp;&amp; left == 0 时表明所有的括号已经添加并且匹配完毕，则得到一种结果。 &emsp;&emsp;时间复杂度：$O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$，其中 $n$ 是需要生成的括号对数目。这是由于 generateParenthesis(n) 的数目是第 $n$ 个卡特兰数 $\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}$，而这个数字由 $\\displaystyle\\frac{4^n}{n\\sqrt{n}}$ 渐进界定。我们每得到一种结果，都需要耗费 $O(n)$ 的时间将其添加到答案数组中，因此总的时间复杂度为 $O(\\displaystyle\\frac{4^n}{n\\sqrt{n}}\\times n) = O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是需要生成的括号对数目。因为返回结果不计入空间开销，而其他开销主要取决于栈递归的层数，最大层数为 $2n$，每次递归调用的空间开销为 $O(1)$，因此空间复杂度为 $O(n)$。 &emsp;&emsp;PS：相关阅读：卡特兰数-百度百科"},{"title":"Leetcode 21.合并两个有序链表","date":"2021-05-23T17:42:00.000Z","url":"/2021/05/24/Leetcode%2021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 示例 2： 示例 3： 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 链接： 题目分析&emsp;&emsp;合并两个升序链表，只需要用两个指针分别遍历两个链表，每次将值小的那个结点添加到合并链表中即可。如果一个链表为空，则直接返回另一个链表（当两个都为空时返回的也是空）。当迭代到某一个链表为空之后，只需将另外一个链表剩下的部分接到最后即可。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别为两个链表的大小。因为我们最多只对两个链表进行了一次遍历便可以完成合并的操作。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。 官方题解&emsp;&emsp;思路与上面相同，但是我们可以使用一个哨兵结点 prehead 作为开头，这样就可以不用额外判断合并后的链表是以哪个链表作为头结点，从而代码可以合并到后面迭代的循环中，更为简洁。这里的 prev 相当于上面的 tail。 "},{"title":"Leetcode 20.有效的括号","date":"2021-05-23T17:07:00.000Z","url":"/2021/05/24/Leetcode%2020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= s.length &lt;= 10^4$ s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 链接： 题目分析&emsp;&emsp;使用栈解决即可。遇到左括号入栈，遇到右括号判断当前栈顶元素是否是相匹配的括号，匹配则进行出栈，不匹配则直接返回 false。需要注意的是当栈为空时调用 top() 函数会出错，并且最后遍历完成之后若栈中还剩余有未匹配的左括号也说明结果为 false。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是括号串的长度。因为我们对该串进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是括号串的长度。我们维护了一个栈存放未匹配的括号，这个栈的最大大小为 $n$。 官方题解&emsp;&emsp;官方题解也是同样用栈的思路，但是建立了一个哈希表进行匹配，代码显得漂亮一点。另外有一点是匹配的括号串一定是偶数个，如果括号串字符数为奇数则可以直接返回 false。 "},{"title":"Leetcode 19.删除链表的倒数第N个结点","date":"2021-05-23T16:30:00.000Z","url":"/2021/05/24/Leetcode%2019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 链接： 题目分析&emsp;&emsp;最简单的办法当然是先对链表进行一次遍历得到长度，然后再得到需要删除的结点位置，第二次遍历到该位置并进行删除，如此一共需要进行两趟扫描。但是如果我们采用前后双指针的做法，让前指针先走 $n$ 步，之后两个指针再一起前进，则当前指针到达链表末尾的时候，后指针就到了需要删除的位置，这样只进行一趟扫描就可以解决问题。&emsp;&emsp;由于删除链表结点的操作是令前置结点的 next 指向其后置结点，则实际上我们搜索到删除结点的前置结点就停下更方便删除，因此循环退出条件也变为前指针的 next 是否已经指向空而不是前指针本身为空。&emsp;&emsp;注意到，如果 $n$ 的值等于链表长度，也即需要删除的结点是头结点时，头结点没有前置结点，则直接返回头结点的后置结点即可。而这种情况下前指针走了 $n$ 步刚好为空，可以作为判断的条件。&emsp;&emsp;PS：代码中含有的注释部分是另一种写法，包括了释放删除结点的内存。 &emsp;&emsp;时间复杂度：$O(L)$，其中 $L$ 是链表的长度。我们总共对链表进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。"},{"title":"Leetcode 17.电话号码的字母组合","date":"2021-05-22T18:52:00.000Z","url":"/2021/05/23/Leetcode%2017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 示例 2： 示例 3： 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 链接： 题目分析&emsp;&emsp;题目要求返回所有的可能情况，则我们可以使用回溯的方法，维护一个字符串，不断将数字代表的字母加入到字符串中，得到一种结果后再进行回溯，删除加入的字母，将数字代表的另一个字母加入到字符串中，这样便可以穷举所有的可能结果。而数字与字母的对应关系可以使用一个哈希表解决。注意当输入的串为空串时，也要返回一个空的字符串数组作为结果。 &emsp;&emsp;时间复杂度：$O(3^m\\times4^n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，也即 2、3、4、5、6、8 数字的数量，$n$ 是输入中对应 4 个字母的数字个数，也即 7、9 数字的数量。这是因为我们需要遍历所有可能的字母组合。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，$n$ 是输入中对应 4 个字母的数字个数。因为返回值不计入空间复杂度中，而其他开销还有哈希表和递归调用中的层数开销。哈希表大小是固定的，可以视为常数；而最大递归层数为 $m+n$。"},{"title":"Leetcode 15.三数之和","date":"2021-05-22T14:22:00.000Z","url":"/2021/05/22/Leetcode%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 3000$ $-10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;对于三个数字的和，我们可以拆分为一个数字和另外两个数字的和，这两个数的和等于另外一个数的相反数就可以让三个数的和为 0。而对于两数之和的问题，我们进行排序后便可以用双指针的思想，从两端向中间寻找从而降低复杂度。&emsp;&emsp;首先对整个数组进行排序。然后我们先确定第一个数的位置，并得到另外两个数的目标和 target，之后我们使用两个指针 left 和 right 分别初始化到剩下的数组两端，并计算他们的和，如果小于 target，则 left 往右移动，若大于 target，则 right 往左移动。每找到一组和为 target 的元组就和第一个数一起加入到结果数组中。&emsp;&emsp;需要注意的问题是，题目要求三元组不能重复。所以我们在进行遍历的时候，如果和前一个数相同，就跳过，继续往后寻找。而每次找到某个三元组之后，直接令 left 往右而 right 往左，因为他们不能再构成一组不重复的解了。因为第一个数字也是从左到右确定的，并且是三元组中的最小值，因此也不会造成重复。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是数组的长度。外层循环确定第一个数的位置，而内层循环中使用双指针搜索，一共只对剩下的数组进行了一次遍历，因此一共两层遍历，时间复杂度为 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(\\log n)$ 或 $O(n)$，其中 $n$ 是数组的长度。一般计算空间复杂度的时候会忽略作为答案进行输出的空间。而我们需要对数组进行排序，如果传入的数组不允许更改，则我们需要复制一个副本进行排序，则需要 $O(n)$ 的空间。如果可以直接对原数组进行排序，则只需要额外的 $O(\\log n)$ 空间进行排序。"},{"title":"Leetcode 11.盛最多水的容器","date":"2021-05-22T13:08:00.000Z","url":"/2021/05/22/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你 $n$ 个非负整数 $a_1，a_2，…，a_n$，每个数代表坐标中的一个点 $(i, a_i)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$ 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $n = height.length$ $2 &lt;= n &lt;= 3 * 10^4$ $0 &lt;= height[i] &lt;= 3 * 10^4$ 链接： 题目分析1.暴力解法&emsp;&emsp;直接对数组进行双层遍历，两个变量分别表示容器的两边下标。那么水容量就是短边乘上容器宽，记录最大容量即可。不出意外，这样的算法超时了。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 2.暴力解法改进&emsp;&emsp;考虑到，如果我们遍历的时候，从两边往中间遍历，宽是不断变小的，如果边也在同时变小的话，那么肯定不是最大的容量，对于这样的情况是可以进行剪枝的。于是我们稍微修改了遍历的顺序，容器左壁从左边开始遍历，容器右壁从右边开始遍历。分别记录左右边最大值，小于这个值的情况就可以直接进行剪枝了。内层遍历结束后，我们需要将右壁的最大值归为 0 再进行下一个内层遍历。经过剪枝后刚好能够通过测试，并不优良，因为本质上还是双层遍历。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。虽然经过剪枝，但本质上还是双层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 3.双指针解法&emsp;&emsp;其实上面的暴力解法改进的思路已经非常接近双指针的思路了。上面的暴力解法都是先确定左壁再遍历右壁进行计算，但实际上，容器高只取决于短的那条边。那么如果我们还是从左右两边往中间遍历，是不是可以按照实际情况选择移动左壁还是右壁呢？实际上我们应该移动短的那边就可以了。因为将进行移动的话，容器宽变小了，而容器高却还是取决于短边，移动长边不会增加还可能更少，因此一定不会使容量更大。而移动短边的话，可能提高了容器高的值，就可能使容量增大。所以我们实际上只需要进行一层遍历，两个指针开始时分别在数组两端表示两个容器壁，而后短边不断向对方移动，每次移动的时候判断容积是否变大，变大则更新结果，最后直到两个容器壁相遇则结束。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 表示数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。"},{"title":"Leetcode 10.正则表达式匹配","date":"2021-05-22T11:46:00.000Z","url":"/2021/05/22/Leetcode%2010.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 &#39;.&#39; 匹配任意单个字符 &#39;*&#39; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。 示例 1： 示例 2: 示例 3： 示例 4： 示例 5： 提示： $0 &lt;= s.length &lt;= 20$ $0 &lt;= p.length &lt;= 30$ s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 链接： 题目分析&emsp;&emsp;对于字符串 s 和 p，我们是逐步匹配的。对于普通字符是一对一匹配，采用一个匹配函数判断即可，对于 . 匹配任意字符的情况也可以在这里得到解决。我们可以采用动态规划的思路，dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。注意 s 和 p 的下标都是从 0 开始的，因此 s 的第 i 个字符是 s[i-1]。那应该有以下的状态转移方程。 若 $p[j-1]\\neq *$ dp[i][j] = \\begin{cases} dp[i-1][j-1], & s[i-1] = p[j-1] \\\\ flase, & s[i-1]\\neq p[j-1] \\end{cases} &emsp;&emsp;而当出现了字符 * 时，表示我们可以对 p[j-1] 匹配任意次，也包括 0 次。这时候，我们可以分情况，如果是匹配 0 次，则相当于我们直接把 p[j] 和 p[j-1] 去掉。如果是匹配 1 次或多次，我们可以直接认为是匹配 1 次，然后将 s[i] 去掉，而 p[j] 和 p[j-1] 继续保留到下次匹配中。这样的话可以得到下面的状态转移方程。 若 $p[j-1]= *$ dp[i][j] = \\begin{cases} dp[i-1][j]\\quad or\\quad dp[i][j-2], & s[i-1] = p[j-2] \\\\ dp[i][j-2], & s[i-1]\\neq p[j-2] \\end{cases} &emsp;&emsp;我们最后的答案也即 dp[s.size()][p.size()]，也就是两个字符串完全匹配的结果。&emsp;&emsp;对于边界条件，我们规定 dp[0][0] = true，也即两个空串是匹配的。而由于 p 中可能开头就存在 a* 而匹配到 s 中空串的情况，i 需从 0 开始。另外代码中存在着一定的冗余，例如 p 中的 a* 必须视为一个整体，但是我们在逐步匹配中，首先直接让 a 进行了匹配，这样的匹配是多余的。但是对于这样的情况，在检查到 * 时，我们的状态转移和 dp[x][j-1] 完全没有关系，因此不对最后结果产生任何影响。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。因为动态规划的状态总数是 $(m+1)*n$，而对于每个状态转移的时间复杂度是 $O(1)$。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。即存储动态规划状态所需要的空间。"},{"title":"Leetcode 5.最长回文子串","date":"2021-05-22T09:41:00.000Z","url":"/2021/05/22/Leetcode%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= s.length &lt;= 1000$ s 仅由数字和英文字母（大写和/或小写）组成 链接： 题目分析1.暴力遍历解法&emsp;&emsp;最容易想到的解法，就是分割每一个子串，并用函数判断这个子串是否是回文串，如果是则更新到结果中。对所有的子串进行判断会超时，我们可以进行稍微的改进，也就是只从比当前结果长的子串开始判断，因为比当前结果短的子串即使是回文串也不会是答案，这样可以节省大量的时间。 &emsp;&emsp;时间复杂度：$O(n^3)$，其中 $n$ 是字符串的长度。因为我们一共需要判断 $O(n^2)$ 个数的子串，而每个子串判断时间是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。进行判断时并没有真的分割出子串，只是对下标进行记录，一共需要常数个变量进行记录。 2.动态规划解法&emsp;&emsp;对于某一个子串，只需要满足它的首尾去掉是一个回文串，而首尾本身也是相同的字符，那么它也是一个回文串。也即有dp[left, right] = dp[left+1][right-1] &amp;&amp; s[left]==s[right]。其中 dp[left][right] 记录了由 s[left] 到 s[right] 的子串是一个回文串。需要注意的是，动态规划的转移方程是从短的子串向长的子串转移，则我们应该从短的字符串向长的字符串进行循环。而对于边界条件，子串字符个数为 1 时一定是一个回文串；子串字符个数为 2 时，两个字符相同时是一个回文串。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。因为动态规划的状态总数是 $O(n^2)$ ，而状态转移时间是 $O(1)$。&emsp;&emsp;空间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。即存储动态规划状态所需要的空间。 3.中心扩展解法&emsp;&emsp;类似于动态规划方法的状态转移思路，我们可以从某一个中心出发，向字符串两端不断扩展匹配是否是相同字符，这样可以得到某一个位置为中心时最大的回文子串长度，若比当前记录的长度更长则进行记录即可，反过来说，其实动态规划的边界情况也就是中心扩展解法的“回文中心”。而每次选择回文中心，有一个字符或者是两个字符的情况，我们要对其分别进行扩展。&emsp;&emsp;注意到我们进行扩展的子函数中循环是首先有对 s[left] 和 s[right] 是否相同进行判断的，这样字符个数为 1 时一定相同，而字符个数为 2 时是否相同也同时进行了判断，因此不必再单独判断字符为 2 时的边界情况。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。我们一共需要扩展 $n$ 个长度为 1 的回文中心和 $n-1$ 个长度为 2 的回文中心，而对于每次扩展，最大长度为 $n/2$。因此总的时间复杂度为 $O((n+n-1)*n/2)=O(n^2)$。&emsp;&emsp;空间复杂度：$O(1)$。进行扩展时只需要进行判断并记录，一共需要常数个变量进行记录。"},{"title":"Leetcode 4.寻找两个正序数组的中位数","date":"2021-05-20T12:32:00.000Z","url":"/2021/05/20/Leetcode%204.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $nums1.length == m$ $nums2.length == n$ $0 &lt;= m &lt;= 1000$ $0 &lt;= n &lt;= 1000$ $1 &lt;= m + n &lt;= 2000$ $-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6$ 链接： 题目分析1.合并数组解法&emsp;&emsp;由于这是两个已经有序的数组，很容易想到归并排序。也就是将两个数组合并成一个，然后再返回处在中间的数字即可。注意合并的时候要考虑某一个数组已经遍历完毕的情况，另外对于奇数个数字和偶数个数字，中位数的计算也不同。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为顺序遍历了两个数组进行合并，合并后返回中位数的过程是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为开辟了一个新数组用来存放合并后的数组。 2.合并数组解法改进&emsp;&emsp;由于我们只需要寻找中位数，其实可以不用将真的将两个数组合并，只需要按顺序寻找到中位数就可以了。由于奇数和偶数计算中位数方式的不同，我们用变量 right 来记录当前第 cnt 小的数，而用 left 来记录上一个 right 也即第 cnt-1 小的数。遍历次数 cnt 为 $(m+n)/2+1$，这样当 $(m+n)$ 为奇数时，我们找到了第 $(m+n)/2+1$ 小的数也即中位数，返回 right；当 $(m+n)$ 为偶数时，left 是第 $(m+n)/2$ 小的数，right 是第 $(m+n)/2+1$ 小的数，中位数是这两个数的平均值，返回 (left+right)/2.0。（这也是变量命名的含义，中位数是左右两个数的平均值） &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。思路和上面一致，但是只需要遍历一半，因为我们只需要找到中位数就可以停止了。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对遍历结果进行记录。 3.二分查找解法&emsp;&emsp;由于数组都是有序的，而我们只需要找到处在中间的那个数，可以考虑用二分查找的方法加快搜索速度。一个思路是对于 nums1、nums2 两个数组，我们要寻找第 k 小的数，则每个数组都寻找第 k/2 个数，假设分别为 nums1[k/2-1] 和 nums2[k/2-1]，比较他们的大小。 若 nums1[k/2-1] &gt;= nums2[k/2-1]，则说明 nums2[k/2-1] 最多也只能比 nums1[0 ~ k/2-2] 和 nums2[0 ~ k/2-2] 都大，最多只有 $(k/2-1)+(k/2-1)=k-2$ 个数比它小，则它小于第 k 小的数，也即 nums2[0 ~ k/2-1] 都可以进行排除。 若 nums1[k/2-1] &lt; nums2[k/2-1]，则相应排除 nums1[0 ~ k/2-1]。 &emsp;&emsp;在剩下的数组中，我们就要找第 k-(k/2) 小的数了。如此二分排除下去就能够得到答案，我们可以采用循环的写法，依然将 k-(k/2) 当做下一个 k。这样的算法下，也有几种特殊情况。 数组中剩下的数字已经不够 k/2 个，这个时候，我们只需要选取数组最后一个数字作为比较对象，若进行排除则整个数组排除即可。当然，相应的，我们排除的数字个数可能就不再是 k/2，更新 k 值的时候需要注意。 如果一个数组已经全部排除，则说明中位数存在于另外一个数组中，我们直接返回另外一个数组中第 k 个数即可。 若 k 为 1，则到了循环的终点，我们返回两个数组中首元素值更小的那个数即可。 &emsp;&emsp;时间复杂度：$O(log(m+n))$，其中 $m、n$ 分别是两个数组的大小。因为初始 $k=(m+n)/2$ 或 $k=(m+n)/2+1$，而每一次搜索会将范围减半。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对搜索结果进行记录。 4.划分数组解法&emsp;&emsp;从另一个角度想，中位数其实就是将数组分割为两个相等长度的子集。而数组的长度我们是知道的，则每个子集的长度我们也是知道的。则我们在 i 处将 nums1 分割为两部分时，相应也就知道了在 nums2 中的哪一处分割为两部分，假设为 j。如果满足 nums1[i-1] &lt;= nums2[j] 且 nums1[i] &gt;= nums2[j-1]。即左半部分为 nums1[0 ~ i-1] 和 nums2[0 ~ j-1]，右半部分为 nums1[i ~ m-1] 和 nums2[j ~ n-1]。此时可以满足左边的所有值都小于右边，则中位数就找到了。这样我们只需要对其中某一个数组进行二分查找，时间复杂度会更低一些。 若 m+n 为偶数，则我们应该有 $i+j=m-i+n-j$。 中位数是 (max(nums1[i-1], nums2[j-1])+min(nums1[i], nums2[j]))/2。 若 m+n 为奇数，则我们应该有 $i+j=m-i+n-j+1$。（左半部分多一个数） 中位数是 max(nums1[i-1], nums2[j-1])。 根据上面两点可以得到 $j = \\lfloor\\frac{m+n+1}{2}\\rfloor-i$。 我们令 nums1 的长度小于 nums2 的长度，则可以保证 $j\\in[0,n]$。 如果 nums1 长度大于 nums2 则交换两个数组即可。 对于整个数组都存在某半部分的情况，我们可以令 nums1[-1]=nums2[-1]=INT_MIN，nums1[m]=nums2[n]=INT_MAX。这样不会对左半部分的最大值或者右半部分的最小值产生影响。 &emsp;&emsp;PS:：代码来自官方题解。 &emsp;&emsp;时间复杂度：$O(log(min(m,n)))$，其中 $m、n$ 分别是两个数组的大小。这是因为我们只对长度较小的那个数组进行了二分查找。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对查找结果进行记录。"},{"title":"Leetcode 3.无重复字符的最长子串","date":"2021-05-19T09:41:00.000Z","url":"/2021/05/19/Leetcode%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 示例 2: 示例 3: 示例 4: 提示： $0 &lt;= s.length &lt;= 5 * 10^4$ $s$ 由英文字母、数字、符号和空格组成 链接： 题目分析&emsp;&emsp;由于题目要求寻找的子串是连续的，则我们可以使用滑动窗口的思想。也就是说，right 向右遍历添加字符进入窗口，而当添加的字符与窗口中已有字符重复时，我们将左边的字符移出窗口，直到字符不再重复。而我们维护这样一个窗口，若窗口是目前最大长度时，对这个长度进行记录即可。查找字符是否存在使用一个哈希表解决。注意字符串为空的情况直接返回 0。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是字符串的长度。滑动窗口的两头指针分别遍历了一次字符串。&emsp;&emsp;空间复杂度：$O(|\\Sigma|)$，$\\Sigma$ 是字符串中出现过的字符集，$|\\Sigma|$ 表示字符集的大小。因为我们需要维护字符串出现过的字符构成的哈希表。"},{"title":"Leetcode 2.两数相加","date":"2021-05-19T09:02:00.000Z","url":"/2021/05/19/Leetcode%202.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1： 示例2： 示例3： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 链接： 题目分析&emsp;&emsp;类似于大数加法，链表中的数字是逆序存储的，刚好就像我们列竖式计算的过程，直接将每一位相加，并将进位 carry 存储即可。结果中的某一位为 res[i] = (l1[i] + l2[i] + carry) % 10 而 carry = (l1[i] + l2[i] + carry) / 10。而对于不一样长的链表，我们只需认为短链表的结点值为 0。迭代遍历整个链表并将结果不断增加到结果链表中得到答案。需要注意的点是，若两个链表的所有结点都已经遍历完毕而仍然有进位，需要将进位也添加到结果链表中；对于链表的迭代，一定要先判断指针是否已经为空。 &emsp;&emsp;时间复杂度：$O(max(m,n))$，其中 $m、n$ 分别是两个链表的长度。因为只需遍历一次链表，而对于每个结点处理的时间开销为 $O(1)$。&emsp;&emsp;空间复杂度：$O(1)$。返回值不计入空间开销，而我们只需要一个变量存储进位值，无需其他额外开销。"},{"title":"Leetcode 1.两数之和","date":"2021-05-19T08:20:00.000Z","url":"/2021/05/19/Leetcode%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 示例 1： 示例 2： 示例 3： 提示： $2 &lt;= nums.length &lt;= 10^3$ $-10^9 &lt;= nums[i] &lt;= 10^9$ $-10^9 &lt;= target &lt;= 10^9$ 只会存在一个有效答案 链接： 题目分析1.暴力解法&emsp;&emsp;我们可以直接对数组进行双层遍历，对于整数 nums[i]，寻找数组中是否存在另外一个整数 nums[j] 使得他们的和为 target，如果存在则返回答案。当然，由于我们在寻找 nums[j] 时，位于 nums[i] 前面的元素已经和 nums[i] 匹配过，而且每个元素不能使用两次，因此向后寻找元素进行匹配即可。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 是数组元素数目。最坏情况下对任意两个元素都需进行比较。&emsp;&emsp;空间复杂度：$O(1)$。只需进行求和比较，无需额外的空间。 2.哈希表解法&emsp;&emsp;从暴力解法我们可以注意到，我们对查找的要求较高。如果能够快速找到 target-nums[i] 的数组下标，则可以较快完成目标。我们考虑使用 unordered_map 存放元素及其下标。依然是遍历整个数组，对于每个元素 nums[i]，查找 target-nums[i] 是否存在于哈希表中，如果有，则返回 target-nums[i] 的下标以及 i；如果没有，则将 nums[i] 的值和下标添加到哈希表中。&emsp;&emsp;对于重复元素，case1：有三个或以上，则说明这些重复元素并不构成解（因为只会存在一个有效答案），没有影响；case2：有两个，且为解，则只能两个重复元素的和刚好为 target（因为只会存在一个有效答案），对于这种情况，第二个重复元素并未进入哈希表就已经作为答案进行返回；case3：有两个，且不为解，没有影响。因此对于重复元素直接进行插入覆盖不会产生问题。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是数组元素数目。只进行一次遍历，哈希表每次查找的时间复杂度为 $O(1)$。&emsp;&emsp;空间复杂度：$O(n)$，$n$ 是数组元素数目。主要为建立哈希表的开销。"},{"title":"C++华容道","date":"2019-07-25T16:00:00.000Z","url":"/2019/07/26/C++%E5%8D%8E%E5%AE%B9%E9%81%93/","tags":[["C++","/tags/C/"],["程序设计","/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"],["Project","/tags/Project/"]],"categories":[["Project","/categories/Project/"]],"content":"引言&emsp;&emsp;快乐的暑假就需要折腾来充实自己，折腾的第一项是自己写一些游戏，第一个project选择了华容道。 华容道 （中国民间智力游戏） &emsp;&emsp;华容道是古老的中国民间益智游戏，以其变化多端、百玩不厌的特点与魔方、独立钻石棋一起被国外智力专家并称为“智力游戏界的三个不可思议”。它与七巧板、九连环等中国传统益智玩具还有个代名词叫作“中国的难题”。据《资治通鉴》注释中说“从此道可至华容也”。华容道原是中国古代的一个地名，相传当年曹操曾经败走此地。由于当时的华容道是一片沼泽，所以曹操大军要割草填地，不少士兵更惨被活埋，惨烈非常。 &emsp;&emsp;通过移动各个棋子，帮助曹操从初始位置移到棋盘最下方中部，从出口逃走。不允许跨越棋子，还要设法用最少的步数把曹操移到出口。曹操逃出华容道的最大障碍是关羽，关羽立马华容道，一夫当关，万夫莫开。关羽与曹操当然是解开这一游戏的关键。四个刘备军兵是最灵活的，也最容易对付，如何发挥他们的作用也要充分考虑周全。“华容道”有一个带二十个小方格的棋盘，代表华容道。 --来源：百度百科 &emsp;&emsp;详见 华容道-百度百科 &emsp;&emsp;初步考虑使用打印字符来代表棋子。使用getch()函数来获取键盘输入，然后通过算法得出相应的棋子坐标变化，并重新打印。&emsp;&emsp;游戏中采用 wasd 进行移动，空格键切换选择状态。当状态为未锁定时，wasd 为切换人物；当状态为锁定时，wasd 为移动人物。 代码目录 color.h&emsp;&emsp;此段代码对输出流进行了重载，可以通过调用函数 cout &lt;&lt; red 直接将控制台输出颜色转变为红色，其他颜色同理。&emsp;&emsp;代码来源于CSDN，感谢。 piece.h&emsp;&emsp;首先定义一个piece类，表示棋子。&emsp;&emsp;其含有变量lx、ly、rx、ry，分别表示棋子的左上角横纵坐标以及右下角横纵坐标；变量status表示棋子的状态，0表示未选中状态，1表示选中状态，2表示锁定状态。代码如下。 &emsp;&emsp;2.0版本时加入了多个关卡，主要区别是棋子的初始位置不同。因此定义一个chapter类，表示一个关卡。变量name储存关卡名字，变量status表示选中/未选中状态。代码如下。 &emsp;&emsp;main.cpp 中的 main 函数定义了 chapter a[12]、piece hrd[10]，分别表示12个关卡和10枚棋子，并在各个函数中以指针形式进行通讯。 &emsp;&emsp;1.0版本选择的关卡是横刀立马，各棋子初状态如下： &emsp;&emsp;于是定义各棋子的编号如下： 棋子 张飞 曹操 马超 黄忠 关羽 赵云 兵1 兵2 兵3 兵4 编号 0 1 2 3 4 5 6 7 8 9 &emsp;&emsp;我们定义5×4棋盘中左上角的坐标为（0，0），以此得出棋盘上各位置的坐标。&emsp;&emsp;我们初定提供12个关卡，按照各关卡各棋子的初始坐标，我们可以按照如下代码定义两个结构体的初始化函数。其中 coordinatex、coordinatey 函数初始化的值均为左上角坐标。 &emsp;&emsp;我们设定初始选择的关卡是横刀立马，于是其变量status的值为true，初始状态的选择在曹操身上，于是hrd[1].status的值为1。&emsp;&emsp;值得一提的是，变量lx、ly、rx、ry存放的是在控制台打印的实际坐标，我们在控制打印棋盘的单位格子大小为3×6，于是可以看到四个变量初始化的代码块进行了相应的坐标换算。X、Y表示棋盘即墙体的初始打印位置（左上角），以方便棋盘的整体移动，为后续调整棋盘在控制台的位置提供了较大的便利。在这里我们可以直接在文件头部进行define，后续需移动整个棋盘时修改X、Y的值即可。 print.h&emsp;&emsp;需包含的头文件如下，同时仍然对X、Y进行定义。 &emsp;&emsp;首先我们有函数gotoxy，可以将运行窗口的光标移动到（x，y）的位置。调用此函数之后再进行打印可以实现在需要的位置打印。其中x为横向（列数），y为纵向（行数） &emsp;&emsp;该头文件的函数一览： &emsp;&emsp;函数 printTimes、changeColor 代码如下。设定未选择状态为白色，选择状态为蓝色，锁定状态为红色。 &emsp;&emsp;函数 printSelectionScreen、printchapter 代码如下。初始化关卡选择并进行打印。打印位置通过不断运行观察调整得到。 &emsp;&emsp;打印效果如图 &emsp;&emsp;函数 printMap、printWall 代码如下。 &emsp;&emsp;printWall 函数打印墙体效果如图。 &emsp;&emsp;函数 printpiece 代码如下。提供了打印各棋子的总接口。选择打印颜色也在此处完成。 &emsp;&emsp;函数 printZF 代码如下。在（x，y）处开始打印棋子，一行一行打印。（x，y）为左上角坐标。此处提供一个打印示例，其他各棋子的打印函数也大抵如此。 &emsp;&emsp;打印棋子初始状态及关卡名称后的效果如图。 &emsp;&emsp;函数 erasepiece 代码如下。提供了擦除各型号大小棋子的总接口。不同棋子对应各自大小的擦除函数。 &emsp;&emsp;示例擦除函数代码如下。在对应位置打印空格即可实现棋子的擦除。注意每格大小3×6（高×宽） &emsp;&emsp;至此，print.h 头文件已经完成。 control.h&emsp;&emsp;需包含的头文件有 conio.h 和 print.h 。其中 conio.h 头文件用于获取键盘输入。仍然对 X、Y 进行宏定义。&emsp;&emsp;该头文件所包含的函数一览： &emsp;&emsp;函数 choosecontrol 的代码如下。返回值为选择的关卡编号。可以利用此值进行棋盘初始化。 &emsp;&emsp;getch()函数为获取一次键盘输入。当输入wasd时，我们需要改变相应的关卡。以 case &#39;w&#39; 为例。 &emsp;&emsp;获取输入后我们对关卡状态进行更新，并且重新打印，体现在了游戏界面上。 &emsp;&emsp;函数 clickcontrol 代码如下。获取键盘输入并调用相应函数，作为总控制中心。&emsp;&emsp;返回值为 10000 时表示回到选择关卡界面，返回值为 10001 时表示当前关卡重新开始，返回值为 1 表示继续进行游戏。值得一提的是，down 函数是有 bool 返回值的，因为游戏胜利的最后一步一定是曹操从下方缺口逃出。因此 down 函数的返回值表示当前关卡通过与否。若通关返回 true，相应地 clickcontrol 函数返回 10086 。 &emsp;&emsp;函数 click 代码如下。通过循环不断调用 clickcontrol 函数，若需回到主界面，则返回 true （通关也是返回主界面），若需当前关卡重新开始，则返回 false 。当 clickcontrol 返回 10086 即关卡胜利时，我们可以知道游戏的最后一步一定是曹操出现在缺口上，于是可以重新打印曹操使曹操“越过棋盘”，并打印游戏通关恭喜字句，同时使用 getchar() 函数使游戏暂停。 &emsp;&emsp;游戏通关效果如图。 &emsp;&emsp;函数 space 代码如下。使用循环检测10枚棋子中处于选择/锁定状态的，切换其状态，并对其重新进行打印（颜色改变）。 &emsp;&emsp;函数 movejudge 代码如下。我们定义棋子的时候记录了其左上角及右下角。当棋子空间 judge 不与棋子 i 重合时，我们返回 true 。由于棋子占领的空间是矩形，因此未重合时，应该至少两个棋子占领的 x 范围或者 y 范围没有交集。 &emsp;&emsp;接下来看看 up 函数。 &emsp;&emsp;可以看到，核心难点即在于对于不同大小的棋子，我们该如何在切换棋子的时候，选择到尽可能符合认知的那枚棋子，而且还要保证所有的棋子都一定能被选择到。该程序还有不足之处便是只能选择严格在其正上方最靠近的棋子，若仍然不止一枚的话只会打印编号靠前的第一枚。如以下这种情况，关羽进行up操作，只会选择两个兵中编号靠前的那一个。 兵 兵 关羽 &emsp;&emsp;其他的 down、left、right 函数基本如上，只需改变相应的变量名和一些常量值，这里便不再赘述。&emsp;&emsp;此外，down 函数中增加了一行代码如下。当曹操到达这个位置（缺口上方）之后按下down时，曹操逃脱，游戏胜利，返回 true 。注意此行代码必须在处于低端格子直接返回之前，因为此时的曹操也同样是处于低端格子。 &emsp;&emsp;至此，control.h 完成。 main.cpp&emsp;&emsp;main.cpp 的代码如下。上面已经说到，click 的返回值为 true 时返回选择界面，返回值为 false 时重新打印关卡。在主函数中得到了体现。另外，主函数的另一个功能是声明了关卡和棋子，并以指针形式传入各函数进行相应操作。 &emsp;&emsp;至此便完成了所有的代码。 历程 v 0.5 &emsp;2019-7-20还没有想好用 wasd 进行切换人物的算法，于是先写出了一个用 space 换人，wasd 移动的版本，由于人物有10个之多，用 space 按照编号顺序切换人物显得非常僵硬，于是不算为第一个版本，算是一个未完成品吧。 v 1.0 &emsp;2019-7-21实现了 wasd 切换人物，空格切换选择/锁定状态，大大提高游戏操作的流畅性。 v 2.0 &emsp;2019-7-22加入了不同的关卡，因此对整套代码进行重构，使用较易理解的5×4坐标，便于后续关卡的加入。 win7版 &emsp;2019-7-23发现win7控制台打印的字符大小与win10不同，字符打印的方框没有重合。修改了打印函数即解决问题。 Future 考虑可以锁定时直接移动。因为移动的选择只有一个或两个。 五虎将只需满足大小为1×2，横竖并不是严格定义的。重构定义代码才能加入更多的关卡。 学习鼠标捕捉并采用鼠标操作。 重构后加入界面 下载&emsp;&emsp;采用photoshop为游戏制作了图标，文件已存放在 这里 。可自行下载并添加到工程中。 &emsp;&emsp;所有代码已经存放到  ，可自行下载查看。 写在最后&emsp;&emsp;很开心，考试月萌生的暑假要好好学习的想法在刚考完试浪完之后还是能开始实施（寒假的时候也有想法但是最终浪过去了）。写完这个项目的代码之后决定要写成博客于是又挖了新坑。花了好几天部署了博客，当然要好好感谢坎爷，基本是克隆了坎爷的博客然后再进行修改的。然后书写这个博客又花了两天，写出来和讲出来的区别还是很大的啊，markdown也是以前没怎么接触（其实以前在matrix上写题目说明用的就是markdown的格式，但是只写过一点点。而且当时也不知道那是什么），书写的确花了不少时间。不过经过这些天来的摸索以后应该就是轻车熟路了。&emsp;&emsp;回头想想，这几天接触学习了好多新东西啊。在路上总是好事。"},{"title":"Hello World","date":"2019-07-23T16:00:00.000Z","url":"/2019/07/24/helloworld/","tags":[["test","/tags/test/"]],"categories":[["Test","/categories/Test/"]],"content":"第一篇博客，作为测试。 那就按照惯例编写一个hello world吧。 试一试 $\\LaTeX$ 公式能不能正常显示 斐波那契数列通项公式：$a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$ "}]