[{"title":"智力题：赛马问题","date":"2021-09-03T16:04:00.000Z","url":"/2021/09/04/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/","categories":[["智力题","/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/"]],"content":"题目描述：一共有 25 匹马，每匹马的速度是固定的，一共有 5 条赛道（也就是说一场比赛最多 5 匹马参加）。最少几场比赛才能选出最快的那匹马？前三呢？ 题目分析：&emsp;&emsp;通过题目我们可以知道马之间的比较是具有传递性的，也就是说 A 比 B 快，B 比 C 快，可以得到 A 比 C 快。那么我们要充分利用每一次比赛得到的 4 个快慢关系。&emsp;&emsp;先将 25 匹马分为 5 组进行 5 次比赛，可以得到 A1 &gt; A2 &gt; A3 &gt; A4 &gt; A5 B1 &gt; B2 &gt; B3 &gt; B4 &gt; B5 C1 &gt; C2 &gt; C3 &gt; C4 &gt; C5 D1 &gt; D2 &gt; D3 &gt; D4 &gt; D5 E1 &gt; E2 &gt; E3 &gt; E4 &gt; E5 &emsp;&emsp;我们再把每个小组的第一名进行一场比赛，假设有 A1 &gt; B1 &gt; C1 &gt; D1 &gt; E1。这个时候就可以知道 A1 是所有马中最快的了。一共需要 6 场比赛。&emsp;&emsp;这个时候我们来分析前三有哪些可能。利用比较的传递关系，只要知道有任意三匹更快的马，那么这匹马就可以淘汰了。比如 A4 和 A5 至少比 A1、A2、A3 慢，那么可以淘汰。B3 ~ B5 则肯定比 A1、B1、B2 慢，可以淘汰。同理 C 组只有 C1 有可能前三，而 D、E 两组则可以全部淘汰。这个时候只需要对 A2、A3、B1、B2、C1 进行一场比赛就可以知道第二和第三名。一共需要 7 场比赛。 如果是要选出前五呢？&emsp;&emsp;通过前面的 7 场比赛，我们也已经知道了前三。 假设前三是 A1、A2、A3，则四五名的可能有 A4、A5、B1、B2、C1，只需再进行一场比赛。 假设前三是 A1、A2、B1，则四五名的可能有 A3、A4、B2、B3、C1、C2、D1，不过在第 7 场比赛中我们是知道 A3、B2、C1 的大小关系的。因此它们中最慢的一个可以直接淘汰，并且同组更慢的马也可以直接淘汰，剩下的 5 匹马再进行一场比赛即可。 假设前三是 A1、B1、C1，则四五名的可能有 A2、A3、B2、B3、C2、C3、D1、D2、E1，一共 9 个可能，而在第 7 场比赛中我们已经知道 A3、B2 的相对排名，可以淘汰掉它们中较慢的一个（较慢的那个肯定也慢于 A2，所以至少慢于两个可能的四五名，若 B2 淘汰则 B3 也可以淘汰），剩下的马无法再进行淘汰，仍然多于 5 匹，则至少还需要 2 场比赛。 &emsp;&emsp;通过以上的分析我们可以知道，至多再多 2 场比赛就可以选出前五。共 9 场。 如果是 64 匹马 8 条赛道选前四呢？&emsp;&emsp;按照同样的思路，先分为 8 组，进行 8 场比赛，再进行小组排名第一的 1 场比赛，一共 9 场比赛可以选出第一名。&emsp;&emsp;剩下的二三四名的可能选择有 A2、A3、A4、B1、B2、B3、C1、C2、D1 一共 9 匹马，则我们不让 A2 参赛，剩下的 8 匹马进行一场比赛，若 A3 在这场比赛中第一，则说明 A2 是全场第二，一共就是 10 场比赛。否则还需加赛一场确定 A2 的排名，一共是 11 场比赛。 总结&emsp;&emsp;通过这些例题我们可以知道，做法就是利用比较的传递性，可以很快地淘汰后面的马匹，从而快速缩小查找范围，达到减少比赛场次的目的。"},{"title":"数据库原理 知识总结（更新中）","date":"2021-08-31T12:18:00.000Z","url":"/2021/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;关于 数据库原理 知识体系的总结。 概述 关系数据库 "},{"title":"操作系统原理 知识总结","date":"2021-08-31T12:18:00.000Z","url":"/2021/08/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;关于 操作系统原理 知识体系的总结。 大纲 硬件结构 图灵机 冯诺依曼模型 存储器 CPU 缓存 软中断 内存管理 虚拟内存 内存分段 内存分页 段页式内存管理 Linux 内存管理 硬件结构图灵机 有⼀条「纸带」，纸带由⼀个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序。 有⼀个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写⼊到纸带的格子。 读写头上有⼀些部件，比如存储单元、控制单元以及运算单元： 储单元用于存放数据。 控制单元用于识别字符是数据还是指令，以及控制程序的流程等。 运算单元用于执行运算指令。 冯诺依曼模型&emsp;&emsp;遵循图灵机的设计，提出用电子元件构造计算机，并约定了用⼆进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输⼊设备、输出设备、总线。 中央处理器 32 位和 64 位 CPU 最主要区别在于⼀次能计算多少字节数据。 32 位 CPU ⼀次可以计算 4 个字节。 64 位 CPU ⼀次可以计算 8 个字节。 这里的 32 位和 64 位，通常称为 CPU 的位宽。 CPU 内部还有⼀些组件，常见的有寄存器、控制单元和逻辑运算单元等。 控制单元：负责控制 CPU ⼯作。 逻辑运算单元：负责计算。 寄存器：存储计算时的数据。 通用寄存器，用来存放需要进行运算的数据，⽐如需要进行加和运算的两个数据。 程序计数器，用来存储 CPU 要执行下⼀条指令「所在的内存地址」，注意不是存储了下⼀条要执行的指令，此时指令还在内存中，程序计数器只是存储了下⼀条指令的地址。 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这⾥。 内存 数据存储的单位是⼀个⼆进制位（bit），即 0 或 1。 最⼩的存储单位是字节（byte），1 字节等于 8 位。 内存存储区域是线性的，类似数组，所以内存的读写任何⼀个数据的速度都是⼀样的。 输入输出设备 输入设备向计算机输入数据。 计算机经过计算后，将数据输出给输出设备。 总线 总线用于 CPU 和内存以及其他设备之间的通讯。 地址总线：用于指定 CPU 将要操作的内存地址。 数据总线：用于读写内存的数据。 控制总线：用于发送和接收信号，如中断、设备复位信号等。 存储器 CPU 寄存器 数量在几十到几百之间 存储一定字节的数据（32 位 4 字节，64 位 8 字节） 一般要求在半个 CPU 时钟周期内完成读写 CPU Cache（SRAM，静态随机存储器） 通电才能存储数据 L1-Cache 每个 CPU 核心都有一个 访问时间通常需要 2~4 个时钟周期 大小在几十 KB 到几百 KB 指令与数据分开存放 L2-Cache 每个 CPU 核心都有一个 访问时间通常需要 10~20 个时钟周期 大小在几百 KB 到几 MB L3-Cache 通常是多个 CPU 核心共用 访问时间通常需要 20~60 个时钟周期 大小在几 MB 到几十 MB 内存（DRAM，动态随机存储器） 密度更高，功耗更低，容量更大，造价更便宜 访问时间大概在 200~300 个时钟周期之间 定时刷新电容才能存储数据 SSD/HDD 硬盘 断电后数据依然存在 SSD 访问时间是内存的 10~1000 倍 HDD 访问时间是内存的 10w 倍左右 从上到下访问速度由快到慢，单位存储能耗由高到低、成本价格由高到低。 CPU 缓存缓存一致性 数据不止有读操作还有写操作，如何将 Cache 中的数据同步到内存中呢？ 写直达：同时写入 Cache 和内存中 写回：发生写操作时只写入到 Cache Block 中，整块替换时才写入内存 缓存一致性问题：多核心的 CPU 拥有自己的 L1/L2 Cache，需要保持一致性 写传播：某个核心更新数据时需要传播给其他核心 事务的串行化：某个核心里对数据的操作顺序，需要在其他核心看来是一样的 MESI 协议 基于总线嗅探，需监听总线，修改数据需在总线上广播 Modified：已修改，可以直接自己改 Exclusive：独占，可以直接自己改，变共享的时候需要同步给别人 Shared：共享，要改需广播，让别人变成 I，自己变成 M Invalid：已失效，不能改 伪共享问题 CPU Cache 缓存数据的时候并不是一个一个读取的，而是一次读取一小块，称为 Cache Line。 多个线程同时读写同一个 Cache Line 的不同变量，原本没有关联，缺因为处于同一个 Cache 而导致 CPU Cache 失效。这个现象称为伪共享。 解决这个问题的思路就是对于多个线程共享的热点数据（经常会修改的数据），应该避免这些数据刚好在同一个 Cache Line 中。 在 Linux 内核中，存在着一个宏定义，使得变量在 Cache Line 中对齐。其实就是用空间换时间的思路，浪费一定的 Cache 空间，让变量处于不同的 Cache Line 中。 在应用层面中，也有使用「字节填充 + 继承」的方式来避免伪共享问题。 软中断 硬中断：打断 CPU 正在执行的任务，处理硬件请求，主要负责耗时短的工作。 软中断：由内核触发，完成硬中断未完成的工作，通常是耗时较长的任务，特点是延迟执行，一般是以内核线程的方式执行，例如网络收发、定时事件。另外，一些内核自定义事件也属于软中断，例如内核调度、RCU 锁等等。 内核 内核是应用和硬件设备连接的桥梁，应用程序只需关心与内核的交互，不用关心硬件的细节。 内核的基本能力 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力。 管理内存，决定内存的分配和回收，也就是内存管理的能力。 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力。 提供系统调用，如果应用程序需要更高权限运行的服务，那么就需要系统调用，它是用户程序与操作系统之间的接口。 操作系统的内存分区 内核空间，这个内存空间只有内核程序可以访问。 用户空间，这个内存空间专门给应用程序使用。 宏内核 内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。 整个内核就是一个完整的可执行程序，且拥有最高的权限。 微内核 内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。 这样服务于服务之间是隔离的，单个服务出现故障或者遭受攻击也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。 功能少，可移植性高，相比宏内核的缺点在于不在内核中的驱动程序却需要频繁调用底层能力，因此需要频繁地在用户态和内核态之间进行切换，增加了系统开销。 混合类型内核 架构比较像微内核，内核里面会有一个最小版本的内核，然后其他模块在这个基础上搭建。 实现的时候与宏内核类似，把整个内核做成一个完整的程序，大部分服务都在内核中，就像一个宏内核包裹着一个微内核。 Linux 内核 设计理念 MutiTask，多任务 任务可以并发（单核 CPU）或并行（多核 CPU） SMP，对称多处理 每个 CPU 的地位相同，对资源的使用权限相同，共享内存 ELF，可执行文件链接格式 编译 → 汇编 → 链接 → ELF 文件 → 转载 → 运行 Monolithic Kernel，宏内核 系统内核的所有模块都运行在内核态 Windows 内核 采用混合型内核。 可执行文件格式与 Linux 不同，称为可移植执行文件（PE）。 内存管理虚拟内存&emsp;&emsp;我们把进程所使用的地址隔离开，让操作系统为每个进程分配独立的一套虚拟地址，而操作系统会提供一种机制（CPU 芯片中的内存管理单元（MMU）），将不同进程的虚拟地址和不同内存的物理地址映射起来，这个过程对于进程来说是不可见的。这样做的好处是不同的进程同时运行的时候，操作的是不同的物理地址，不会产生冲突。 我们程序所使用的内存地址叫做虚拟内存地址。 实际存在硬件里面的空间地址叫物理内存地址。 内存分段概述&emsp;&emsp;分段是较早提出的内存管理方式。&emsp;&emsp;程序是由若干个逻辑分段组成的，例如代码分段、数据分段、栈段、堆段。不同的段具有不同的属性，可以利用分段的形式将它们分离出来。&emsp;&emsp;分段机制下，虚拟地址由两部分组成，段选择子和段内偏移量。 段选择子：保存在段寄存器里。 段号：段表的索引。 特权等标志位。 段内偏移量：位于 0 与段界限之间。 段基地址加上段内偏移量得到物理内存地址。 段表：保存段的基地址、段的界限和特权等级等。 缺点 内存碎片 外部内存碎片：产生了多个不连续的小物理内存，新的程序无法被转载。 内存交换：写到硬盘上，再写回内存，将不连续的小内存合并。 内部内存碎片：程序所有的内存都转载到了物理内存，但有些并不常用。 内存交换效率低 硬盘的访问速度很慢，频繁的内存交换效率低。 内存分页概述&emsp;&emsp;内存分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间就称为页。（Linux 中一个页大小 4KB）&emsp;&emsp;虚拟地址与物理地址之间通过页表来映射。当进程要访问的虚拟地址在页表中找不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存，更新进程页表，再返回用户空间，恢复进程运行。&emsp;&emsp;分页机制下，虚拟地址由两部分组成，页号和页内偏移。 页号：页表的索引。 页内偏移：位于 0 与页大小之间。 页表：保存物理页每页所在的物理内存的基地址。 基地址和页内偏移组成物理内存地址。 优点 解决内存碎片问题 内存空间是预先划分的，不会产生间隙非常小的内存。内存释放也是以页为单位。 解决内存交换效率低问题 内存空间不够时，利用 LRU 将其他进程中内存页面释放掉（写入硬盘），称为换出，而需要的时候再加载进来，称为换入。这样一次磁盘 IO 只有几页，不会花费大量时间。 加载程序时无需一次性全部加载 在程序运行中需要用到对应的虚拟内存的指令和数据时再装载页。 多级页表 简单分页（单页表）中存在缺陷 操作系统中可以同时运行非常多的进程，这意味着页表非常的庞大。 32 位操作系统，4GB 虚拟内存空间需要 4MB 大小的页表。 每个进程都有自己的页表，总和就非常庞大了。 多级页表 例如分二级，一级页表 4KB，二级页表 4MB，但一个进程通常无需这么多内存。 一级页表 4KB 已经覆盖所有内存，如果某一个页表项没有被用到，可以不用创建对应的二级页表，这样二级页表总和就远小于 4MB 了。 64 位系统分成了四级目录 全局页目录项 PGD 上层页目录项 PUD 中间页目录项 PMD 页表项 PTE TLB 多级页表解决空间的问题，但带来了时间的开销。 程序是有局部性的，某段时间内执行所访问的存储空间通常只局限于某个内存区域。 我们可以将最常访问的几个页表项存储到访问速度更快的硬件，也就是 CPU 中专门用于存放最常访问页表项的 Cache，也就是 TLB。 TLB 也称为页表缓存、转址旁路缓存、快表。 段页式内存管理 分段和分页机制是可以结合起来的，也就是段页式内存管理。 先将程序划分为多个有逻辑意义的段（先分段）。 再把每个段划分为多个页（再分页）。 地址结构由段号、段内页号、页内偏移三部分组成。 每一个程序一张段表，每个段一张页表，段表中的地址是页表的起始地址。 Linux 内存管理Intel 处理器 早期的 Intel 处理器使用段式内存管理。 不久后实现页式内存管理，但是这个页式内存管理是建立在段式内存管理的基础上，页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。 这时由段式内存管理映射而成的地址称为线性地址（虚拟地址）。 逻辑地址通过段式内存管理映射为线性地址，线性地址再通过页式内存管理映射为物理地址。 Linux 的内存管理 主要采用页式内存管理，但同时也不可避免地涉及段机制。 每个段是从 0 地址开始的整个 4GB 虚拟空间（32 位），也就是说所有的段起始地址都是一样的，这意味着 Linux 系统中的代码，包括操作系统本身和应用程序代码，所面对的都是线性地址，这种做法相当于屏蔽了逻辑地址的概念。 段只被用于访问控制和内存保护。 虚拟地址空间内部又分为内核空间和用户空间。 32 位系统内核空间占 1G，位于最高处，用户空间占剩下的 3G。 64 位系统内核空间和用户空间都是 128T，分别占据内存空间的最高处和最低处，剩下的中间部分是未定义的。 进程在用户态时，只能访问用户内存空间。 只有进入内核态后，才能访问内核空间的内存。 每个虚拟内存中的内核地址，关联的是相同的物理内存。 用户内存空间的分布（从低到高） 程序文件段，包括二进制可执行文件。 已初始化的数据段，包括静态常量。 未初始化的数据段，包括未初始化的静态变量。 堆段，包括动态分配的内存，从低地址开始向上增长。 文件映射段，包括动态库、共享内存等。 栈段，包括局部变量和函数调用上下文等。大小是固定的，从高地址开始。 进程与线程进程 我们编写的代码只是一个存储在硬盘中的静态文件，通过编译后生成二进制可执行文件，当运行这个可执行文件时，它会被装载到内存中，然后 CPU 执行程序中的每一条指令，而这个运行中的程序，就称为进程。 CPU 执行指令的速度是非常快的，而需要读取文件等等指令时，硬盘的读写速度却非常慢，这个时候如果 CPU 停转等待硬盘会导致利用率非常低，因此我们需要一个进程管理方法，在某个进程阻塞时，CPU 可以执行别的进程。 CPU 可以从一个进程切换到另一个进程，在切换前必须要记录当前进程中运行的状态信息，以备切换回来的时候可以恢复运行。 进程的状态 运行状态：该时刻进程占用 CPU。 就绪状态：可运行，由于其他进程处于运行状态而暂时停止运行。 阻塞状态：该进程正在等待某一事件发生（如等待输入/输出）而暂时停止运行。 创建状态：进程正在被创建时的状态。 结束状态：进程正在从系统中移除的状态。 阻塞挂起状态：进程在外存（硬盘）并等待某个时间的出现。 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即可立即运行。 进程的控制结构 进程控制块（PCB）是进程存在的唯一标识。 进程描述信息 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符。 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。 进程控制和管理信息 进程当前状态，如运行状态、就绪状态、阻塞状态等等。 进程优先级：进程抢占 CPU 时的优先级。 资源分配清单 有关内存地址空间或虚拟地址空间的信息。 所打开的文件列表和所使用的的 I/O 设备信息。 CPU 相关信息：CPU 中各个寄存器的值 PCB 通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。除了链接，也有索引的组织方式，同一状态的进程在同一个索引表中。 进程的控制 创建进程 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，申请失败则创建失败。 为进程分配资源，如果资源不足，则进入等待状态，等待资源分配。 初始化 PCB。 如果进程的调度队列可以接纳新进程，则进程进入就绪队列，等待运行。 终止进程 查找需要终止的进程 PCB。 如果处于执行状态，则立即终止运行，并将 CPU 资源分配给其他进程。 如果该进程有子进程，则应将其所有子进程终止。 将该进程所拥有的全部资源归还给父进程或者操作系统。 将其从 PCB 所在队列中删除。 阻塞进程 查找将要被阻塞进程标识号对应的 PCB。 如果该进程为运行状态，则保护其现场，将其状态转为阻塞态，停止运行。 将该 PCB 插入到阻塞队列中去。 唤醒进程 处于阻塞状态的进程需要由其他进程进行唤醒。 在该事件的阻塞队列中找到相应进程的 PCB。 将其从阻塞队列中移出，并置其状态为就绪状态。 把该 PCB 插入到就绪队列中，等待调度程序调度。 进程的上下文切换 各个进程之间是共享 CPU 资源的，一个进程切换到另一个进程运行，称为进程的上下文切换。 操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器，这些信息称为 CPU 上下文。 CPU 上下文切换分为：进程上下文切换、线程上下文切换、中断上下文切换。 进程的上下文切换发生在内核，不仅包含了虚拟内存、栈、全局变量等用户空间资源，还包括了内核堆栈、寄存器等内核空间的资源。 发生进程上下文切换的场景 为了保证所有进程可以得到公平调度，CPU 时间被划分为时间片，轮流分配给各个进程。某个进程的时间片耗尽了就需要切换为就绪状态，让另外一个进程运行。 进程在系统资源不足时，要等到资源满足后才可以运行，这个时候进程需要挂起，并由系统调度其他进程运行。 当进程通过睡眠函数等方法将自己主动挂起时，也需要进行进程切换。 当有优先级更高的进程运行时，低优先级的进程需要挂起。 发生硬件中断时，CPU 上的进程会被中断挂起，然后运行内核中的中断服务程序。 线程 线程是进程中的一条执行流程。 同一个进程内的多个线程之间可以共享代码段、数据段、打开的文件等资源。 每个线程各自拥有一套独立的寄存器和栈，可以确保线程的控制流是相对独立的。 优点 一个进程中可以同时存在多个线程。 各个线程之间可以并发执行。 各个线程之间可以共享地址空间和文件等资源。 缺点 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。 线程的上下文切换 当进程只有一个线程时，可以认为进程就等于线程。 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的。 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样。 当两个线程是属于同一个进程，则只需要切换线程的私有数据、寄存器等不共享的数据。 线程的实现 线程由线程控制块（TCB）进行控制。 用户线程：在用户空间实现的线程，由用户态的线程库来完成线程的管理。 用户线程的 TCB 是在线程管理库中实现的，对于操作系统而言是不可见的。 用户线程的整个线程管理和调度，操作系统均不参与，由用户级线程库函数完成。 优点 每个进程拥有它私有的 TCB 列表，可用于不支持线程技术的操作系统。 用户线程的切换也是由线程库函数完成，无需切换内核态，速度快。 缺点 由于操作系统不参与用户线程调度，当一个线程发起系统调用而被阻塞，则该进程所包含的所有用户线程都不能执行了。 当一个线程开始运行时，除非它主动地交出 CPU 的使用权，否则它所在进程中的其他线程均无法运行，因为用户态线程没有权限打断运行中的线程。 由于时间片是分配给进程的，与其他进程相比，多线程中每个线程得到的时间片较少，执行会比较慢。 内核线程：在内核中实现的线程，是由内核管理的线程。 内核线程的 TCB 放在操作系统里，由操作系统负责创建、终止和管理。 优点 在一个进程中，某个内核线程发起系统调用而阻塞，不会影响其他内核线程运行。 时间片分配给线程，多线程的进程可以获得更多的 CPU 运行时间。 缺点 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息。 线程的创建、终止和切换都是通过系统调用的方式来进行，系统开销较大。 轻量级进程（LWP）：在内核中来支持用户线程。 与普通进程的区别在于它只有一个最小执行上下文和调度程序所需要的统计信息。 一个进程代表程序的一个实例，而 LWP 代表程序的执行线程。 进程与线程的异同 进程是操作系统资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位。 进程拥有一个完整的资源平台，而线程只独享必不可少的资源（寄存器和栈）。 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转移关系。 线程能够减少并发执行的时间和空间开销。 线程的创建和终止更快，因为所拥有的资源少，申请和释放更简单。 同一进程里的线程切换比进程切换快，因为线程具有相同的地址空间，这意味着同一个进程里的线程具有同一个页表，在切换的时候无需切换页表。 线程之间进行数据传递的时候不需要经过内核，数据交换效率更高。 进程间通信管道 管道传输数据是单向的，并且遵循 FIFO。如果想相互通信，需要创建两个管道。 管道其实就是内核里面的一串缓存，从一端写入数据，从另一端读取。 管道传输的数据是无格式的流并且大小受限。 匿名管道是特殊的文件，只存在于内存而不存在于文件系统中。 匿名管道的通信范围是存在父子关系的进程。 匿名管道的生命周期跟随进程，随进程的创建建立，随进程的结束销毁。 命名管道拥有文件实体，可以在不相关的进程间相互通信。 管道的通信方式效率低，不适合进程间频繁地交换数据。 消息队列 消息队列是保存在内核中的消息链表，拥有独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息发送方和接收方要约定消息体的数据类型。 如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。 消息队列的生命周期跟随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。 消息队列的不足是通信不及时，并且有大小限制。 消息队列不适合比较大数据的传输，因为消息体的大小有限制，队列的长度也有限制。 消息队列通信过程中，存在用户态和内核态之间的数据拷贝开销。 共享内存 两个进程拿出一块虚拟地址空间，映射到相同的物理内存。 这样的方法减少了拷贝的开销，可以提高通信的速度，但是同时也引入了冲突问题。 防止多进程竞争共享资源的问题，使用信号量进行保护。 信号量其实是一个整型计数器，主要用于实现进程间互斥与同步，不用于缓存通信数据。 P 操作：把信号量减 1，相减后小于 0 表示资源已被占用，其他进程需阻塞；大于等于 0 则表示还有资源可以使用。P 操作用于进入共享资源之前。 V 操作：把信号量加 1，相加后小于等于 0 表示有阻塞中的进程需唤醒；大于 0 则表明当前没有阻塞中的进程。V 操作用于离开共享资源后。 如果要使得进程互斥访问共享内存，则初始化信号量为 1，称为互斥信号量。 如果要使得进程顺序访问共享内存，则初始化信号量为 0，称为同步信号量。 信号 以上的几种进程间通信方式都是常规状态下的工作模式。而异常情况下的工作模式，则需要使用信号来通知进程。（信号与信号量是完全不同的东西） 信号是进程间通信机制中唯一的异步通信机制，可以在任何时候发送信号给某一进程。 用户进程对信号的处理方式 执行默认操作。Linux 中的每种信号都有默认操作，例如终止进程等等。 捕捉信号。为信号定义一个处理函数，当信号发生时执行相应的处理函数。 忽略信号。当我们不希望处理某些信号的时候，可以设置忽略该信号不做处理。 套接字 以上的几种进程间通信方式都是在同一台主机上进行的，而跨网络与不同主机上的进程之间通信就用到了 Socket 通信，也就是套接字。当然 Socket 也可以用于本机通信。 Socket 的系统调用中有三个参数，分别表示协议簇（IPv4、IPv6、本机）、通信特性（字节流、数据报）、通信协议。 不同主机间的通信需要绑定（bind）主机 IP 地址和端口号。 TCP 协议需要建立和维护连接（使用 listen 监听，使用 connect 请求连接，使用 accept 接受连接），使用 sendto 和 recvfrom 发送和接收数据。使用 close 关闭连接。 UDP 协议无需建立连接，但是仍然需要绑定主机 IP 地址和端口号。 本地 Socket 也分为字节流和数据报，实现效率大大高于 IPv4 和 IPv6 的实现。 本地 Socket 与 TCP、UDP 的区别是绑定的是一个本地文件，而不是 IP 和端口。 多线程同步竞争与协作 互斥 由于多线程执行操作共享变量的代码可能会导致竞争状态，因此我们将此段代码称为临界区，它是访问共享资源的代码片段，一定不能让多线程同时执行。 我们希望临界区的代码是互斥的，也就是保证一个线程在临界区执行时，其他线程会被阻止进入临界区。 同步 并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程/线程同步。 实现进程/线程间正确的协作的主要方法有两种 锁：加锁、解锁 信号量：P、V 操作 信号量 信号量是操作系统提供的一种协调共享资源访问的方法。 通常信号量表示资源的数量，对应的变量是一个整型变量。 信号量不仅可以实现临界区的互斥访问控制，还可以实现线程间的事件同步。 生产者-消费者模型 问题描述 生产者在生成数据后，放在一个缓冲区中。 消费者从缓冲区取出数据处理。 任何时刻，只能有一个生产者或消费者可以访问缓冲区。 问题分析 任何时刻只能有一个线程操作缓冲区。说明缓冲区是临界区，需要互斥。 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。 信号量 互斥信号量 mutex：用于互斥访问缓冲区，初始化值为 1。 资源信号量 full：用于表示满槽的个数，用于消费者询问缓冲区是否有数据，有数据则可以读取数据，初始化为 0。 资源信号量 empty：用于表示空槽的个数，用于生产者询问缓冲区是否有空位，有空位则可以生产数据，初始为 n（缓冲区大小）。 哲学家就餐问题 哲学家围成一圈吃面，每个哲学家之间有一把叉子，每个哲学家需要拿到左右两边的叉子才可以进餐。这个问题使用普通的调度可能会导致死锁（所有哲学家都拿了同一边的叉子，构成了循环等待） 方案一：直接使用互斥量，缺点是同一时间只能有一个哲学家进餐。 方案二：奇数编号和偶数编号的哲学家获取叉子的顺序不同，保证不会发生死锁。 方案三：使用信号量数组，当左右两边的哲学家都不是进餐状态时才可以进餐。 读者-写者问题 问题描述 「读-读」允许：同一时刻，允许多个读者同时读 「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写 「写-写」互斥：没有其他写者时，写者才能写 方案一：读者优先 读者计数为 0 时写者才能操作，否则会被阻塞。 wMutex：控制写者进入的互斥信号量，初始值为 1。 rCount：读者计数器，初始化为 0。 rCountMutex：控制对 rCount 读者计数器的互斥修改，初始值为 1。 若持续不断有读者，则写者会处于饥饿状态。 方案二：写者优先 只要有写者准备写入，写者应尽快执行写操作，后来的读者则阻塞。 rMutex：控制读者进入的互斥信号量，初始值为 1。 WDataMutex：控制写者写操作的互斥信号量，初始值为 1。 wCount：写者计数器，初始值为 0。 wCountMutex：控制对 wCount 写者计数器的互斥修改，初始值为 1。 若持续不断有写者，则读者会处于饥饿状态。 方案三：公平策略 读者和写者的优先级相同。 读者、写者互斥访问。 只能一个写者访问临界区。 可以有多个读者同时访问临界资源。 各种锁 使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。 任何想进入临界区的线程，必须先执行加锁操作，若操作顺利通过，则线程可以进入临界区。 在完成对临界资源的访问后需要执行解锁操作，以释放该临界资源。 互斥锁与自旋锁 互斥锁加锁失败后，线程会释放 CPU，给其他线程。 独占锁，一旦一个线程加锁成功就独占，其他线程会因为加锁失败而阻塞。 阻塞的线程会将 CPU 让给其他线程执行。 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。 开销成本主要来源于两次线程上下文切换。 如果被锁住的代码执行时间很短，可能上下文切换时间比锁住的代码执行时间更长。 自旋锁加锁失败后，线程会忙等待，直到它拿到锁。 自旋锁通过 CPU 提供的 CAS 函数，在用户态完成加锁和解锁操作。 加锁过程分为两步：查看锁的状态，若空闲则设置为当前线程拥有。 上面的操作被 CAS 函数合并成一条硬件级指令，是具有原子性的。 在单核 CPU 中，需要抢占式调度器（不断通过时钟中断一个线程，运行其他线程）。这是因为自旋的线程永远不会放弃 CPU。 读写锁 读写锁适用于能明确区分读操作和写操作的场景。 读锁是共享锁，而写锁是独占锁。 读写锁可以根据场景选择使用互斥锁还是自旋锁实现。 乐观锁与悲观锁 悲观锁对多线程竞争持悲观态度，认为多线程同时修改共享资源的概率比较高，于是很容易发生冲突，所以访问共享资源前都需要先上锁。 乐观锁对多线程竞争持乐观态度，认为冲突的概率较低，工作时先修改共享资源，再检验这段时间内有没有发生冲突，如果没有其他线程在修改资源则操作完成，如果发现有其他线程已经修改过这个资源则放弃操作。 一般来说，乐观锁一旦发生冲突，处理成本是比较高的，但是如果冲突概率足够低就可行。并且实际上它并没有真正上锁，所以也称为无锁编程。 死锁 死锁发生的条件 互斥条件：多个线程不能同时使用用一个资源。 持有并等待条件：线程已经持有一定资源，并在等待其它线程持有的资源。 不可剥夺条件：线程拥有的资源在使用完之前不能被其他线程获取。 环路等待条件：线程正在等待的资源顺序刚好构成了环形链。 避免死锁的方法就是破坏以上任意一个条件。 最常见的解决方法是使用资源有序分配法来破坏环路等待条件。 调度算法进程调度 非抢占式调度算法 当进程正在运行时，它会一直运行，直到该进程完成，或者发生某个事件而被阻塞，才会把 CPU 让给其他进程。 抢占式调度算法 当进程正在运行时，可以被打断，使其把 CPU 让给其他进程。 先来先服务调度算法 先来先服务（FCFS）算法是非抢占式调度算法。 每次从就绪队列选择最先进入队列的进程。 一直运行进程，直到进程退出或者被阻塞，才选择下一个进程运行。 对短作业不利，如果前面有长作业先运行，那么短作业等待的时间会很长。 对长作业有利，适用于 CPU 繁忙型作业的系统，不适用于 I/O 繁忙型作业的系统。 最短作业优先调度算法 最短作业优先（SJF）算法也是非抢占式调度算法。 优先选择运行时间最短的进程来运行，有助于提高系统吞吐量。 对长作业不利，极端情况下长作业永远也不会被运行。 高响应比优先调度算法 高响应比优先（HRRN）算法权衡了短作业和长作业。 每次进行进程调度时先计算响应比优先级，最高的进程投入运行。 优先权 = ( 等待时间 + 要求服务时间 ) / 要求服务时间。 等待时间相同时，短作业优先权更高，更容易被选中运行。 而随着等待时间增长，优先权会逐渐变高，这样就兼顾了长作业。 时间片轮转调度算法 时间片轮转（RR）算法是抢占式调度算法。 每个进程被分配一个时间段，称为时间片，允许该进程在该时间段中运行。 如果时间片用完，进程还在运行，则此进程会从 CPU 中释放出来，分配给另外一个进程。 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。 如果时间片设置得太短会导致频繁的进程上下文切换，降低了 CPU 效率。 如果时间片设置得太长会导致短作业进程的响应时间变长。 一个时间片大小通常设置为 20ms ~ 50ms 最高优先级调度算法 最高优先级（HPF）算法从就绪队列中选择最高优先级的进程运行。 静态优先级：创建进程的时候确定优先级，并且整个运行时间都不会变化。 动态优先级：根据进程的动态变化调整优先级，例如随着运行时间增加降低优先级，随着等待时间增加升高优先级。 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。 低优先级的进程可能永远不会运行。 多级反馈队列调度算法 多级反馈队列（MFQ）算法是时间片轮转算法和最高优先级算法的综合和发展。 多级表示有多个队列，每个队列优先级从高到低，优先级越高时间片越短。 反馈表示如果有新的进程加入优先级高的队列，立即停止当前正在运行的进程并将其移入原队列队尾，转而去运行优先级高的队列。 新的进程会被放入第一级队列的末尾，按先来先服务的原则排队等待调度。如果在第一级队列规定的时间片没运行完成，则将其转入第二级队列的末尾，以此类推，直完成。 短作业可以在第一级队列很快处理完。而长作业在第一级队列处理不完，可以移入下一队列，下次运行的时间片更长。这样就很好地兼顾了长短作业，并且响应时间也比较理想。 页面置换 缺页异常（缺页中断）指 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入物理内存。 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完成之后检查和处理中断信号。缺页中断返回到该指令的开始重新执行，而一般中断返回到该指令的下一个指令执行。 页面换入的时候需要寻找空闲页进行替换，若没有空闲页就需要使用页面置换算法选择一个页面换出到磁盘中。 页表项字段 页号、物理页号 状态位：表示该页是否有效，也即是否在物理内存中。 访问字段：记录该页在一段时间被访问的次数，用于页面置换算法作参考。 修改位：表示该页在调入内存后是否有被修改过，如果有则称为脏页，在置换该页时需要写回磁盘；若没有则置换时无需写回磁盘，可以减少系统开销。 硬盘地址：表示该页在硬盘上的地址，通常是物理块号，供调入该页时使用。 最佳页面置换算法 最佳页面置换算法（OPT）基本思路是置换在“未来”最长时间不访问的页面。 该算法实现需要计算内存中每个逻辑页面的下一次访问时间，通过比较选择换出的页。 这种算法是理想算法，实际系统中无法实现，因为程序访问页面是动态的，我们无法预知每个页面下一次访问的时间。 最佳页面置换算法的作用是衡量其他页面置换算法的效率，越接近这个效率表明算法越高效。 先进先出置换算法 先进先出置换算法（FIFO）选择在内存驻留时间最长的页面进行置换。 FIFO 算法通常来说并不高效，优点是简单。 最近最久未使用置换算法 最近最久未使用置换算法（LRU）选择最长时间没有被访问的页面进行置换。 该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内也不会被使用。 最佳页面置换算法通过“未来”的使用情况淘汰页面，而 LRU 使用“历史”的使用情况来推测需要淘汰的页面，效果是较优的。 LRU 的缺点是实现代价比较高，因为我们需要在内存中维护一个所有页面的链表，最近使用的页面在表头，而最近最久未使用的页面在表尾。每次访问都需要更新链表。 所以 LRU 虽然效果不错，但是因为开销比较大，在实际应用中较少使用。 时钟页面置换算法 时钟页面置换算法（Clock）与 LRU 近似，又是对 FIFO 的一种改进，比较容易实现。 该算法把所有的页面保存在一个类似钟面的环形链表中，一个表针指向最老的页面。 发生缺页中断时，检查表针指向的页面。 如果访问位是 0，淘汰该页面，把新的页面插入到这个位置，表针前移一个位置。 如果访问位是 1，清除访问位，表针前移一个位置，继续寻找访问位为 0 的页面。 这个算法结合了 LRU 和 FIFO 的部分优点，采取了较容易实现的方式，是不错的改进。 最不常用置换算法 最不常用置换算法（LFU）选择访问次数最少的页面进行置换。 该算法对每个页面设置一个访问计数器，每当一个页面被访问，访问计数器累加 1。 虽然算法非常简单，但是需要增加一个计数器，这对操作系统来说是不小的硬件成本。并且查找计数器值最小的页面也是比较耗时的操作。 另一个缺点是 LFU 只考虑了频率而没有考虑时间，一个非常常见的情况是某些页面在过去的一段时间内访问频率很高，但是现在已经不常访问甚至是不访问了，而目前频繁访问的页面没有这些页面访问次数高，可能会在刚开始频繁访问的时候不断换进换出，因此效果不佳。 上面的这个缺点也有一些应对办法：定期减少所有页面的访问次数，这样随着时间的流逝，以前的高访问页面的访问计数器会不断减少，增加被置换的几率。 磁盘调度 常见的机械磁盘是由多个盘片组成的，每个盘片有磁头，每一层有多个磁道，每个磁道分为多个扇区，每个扇区大小是 512 字节。每个相同编号的磁道形成的圆柱称为磁盘的柱面。 磁盘调度算法的目的就是提高磁盘的访问性能，一般通过优化磁盘的访问请求顺序做到。 寻道的时间是磁盘访问最耗时的部分，因此优化的方向可以是尽量减少寻道次数。 先来先服务算法 先来先服务（FCFS）算法就是先到的请求先服务。 这种算法是最简单粗暴的做法，如果请求访问的磁道比较分散则会导致性能特别差。 最短寻道时间优先算法 最短寻道优先（SSF）算法是优先选择从当前磁头位置所需寻道时间较短的请求。 这个算法相比 FCFS 服务性能提升很多，但是可能存在的问题是饥饿。 产生饥饿的情况就是动态的请求使得磁头在一小块区域来回移动，而没有服务远端的请求。 扫描算法 扫描（Scan）算法可以防止 SSF 算法造成的饥饿。 该算法规定磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上最后的磁道，再调换方向，如此在磁道来回移动。 扫描算法的性能较好，不会产生饥饿，不过存在的问题是中间部分的磁道的响应效率会高一些，磁道的响应频率存在差异。 循环扫描算法 循环扫描算法（C-Scan）用于解决磁道访问频率差异的问题。 该算法规定只有磁头朝某个特定方向移动时才处理访问请求；而返回时则直接快速移动到最靠边缘的起始磁道，不处理任何请求，也即是复位，这个过程是很快的。 Look 与 C-Look 算法 上面说到的扫描算法和循环扫描算法都是磁头移动到磁盘的最始端和最末端才调换方向，而 Look 算法优化的思路就是在移动到最远的请求之后就调换方向。 Scan 算法对应的就是 Look 算法，C-Scan 算法对应的就是 C-Look 算法。 文件系统文件系统的基本组成 文件系统是操作系统中负责管理持久数据的子系统。 文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理。 Linux 最经典的一句话：「一切皆文件」，不仅普通文件和目录，就连块设备、管道、Socket 等，都是统一交给文件系统管理的。 索引节点。记录文件的元信息，比如索引编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘中的位置等等。它是文件的唯一标识，它们之间一一对应，而索引节点同样也存储在磁盘中，占用磁盘空间。 目录项。记录文件的名字、索引节点指针以及其他目录项的层级关联关系。多个目录项关联起来就形成目录结构。与索引不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存中。 注意目录和目录项并不是一个东西。目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里保存的是文件数据，而目录文件保存的是子目录或文件。目录项则是内核里的一个数据结构，缓存在内存，目的是加快文件系统效率。 磁盘读写的最小单位是扇区，大小 512B，多个扇区组成一个逻辑块，文件系统每次读写的最小单位就是逻辑块，Linux 中的逻辑块大小为 4KB（8 个扇区）。 磁盘的存储区域 超级块，用来存储文件系统的详细信息，如块个数、块大小、空闲块等等。 索引节点区，用来存储索引节点。 数据块区，用来存储文件或目录数据。 虚拟文件系统 文件系统种类众多，而操作系统希望读用户提供一个统一的接口。 我们在用户层与文件系统层引入了中间层，就是虚拟文件系统（VFS）。 VFS 定义了一组所有文件系统都支持的数据结构和标准接口。 文件的存储连续空间存放方式 文件存放在磁盘连续的物理空间中。读写效率高。 文件头里需要指定起始块的位置和长度。 缺陷是存在磁盘空间碎片、文件长度不易扩展。 非连续空间存放方式 链表方式 存放方式是离散的，不连续的。 可以消除磁盘碎片，文件长度可以动态扩展。 隐式链表 文件头包含第一块和最后一块的位置。 每个数据块里面留出一个指针空间，存放下一个数据块的位置。 缺点是无法直接访问数据块，需要通过指针顺序访问，指针也消耗一定空间。 稳定性较差，如果数据块指针丢失或损坏，文件数据会丢失。 显式链表 每个磁盘块的指针都放在内存的一个表中。 每个表项中存放链接指针，指向下一个数据块号。 这个表格称为文件分配表（FAT）。 查找记录的过程是在内存中进行的。 提高了检索速度，大大减少了磁盘访问次数，但不适用于大磁盘。 索引方式 为每个文件创建一个索引数据块，存放了指向文件数据块的指针列表。 文件头需要包含指向索引数据块的指针。 优点 文件的创建、增大、缩小很方便。 不会有磁盘碎片的问题。 支持顺序读写和随机读写。 缺点 索引数据块带来的开销。 当文件很大，一个索引块放不下的时候 链式索引块。同样的，这个处理方式也会存在文件损坏的问题。 多级索引块。利用索引套索引的方式。 Unix 文件的实现方式 结合了前面几种存放方式，根据文件的大小进行变化。 如果数据块小于 10 块，采用直接查找的方式。 如果数据块多于 10 块，采用一级间接索引方式。 如果前面两种方式不够存大文件，采用二级间接索引方式。 如果二级间接索引也不够存放大文件，采用三级间接索引方式。 对于小文件使用直接查找的方式可以减少索引数据块的开销。 对于大文件采用多级索引的方式支持，所以大文件访问数据块的时候需要大量查询。 空闲空间管理 存储管理是针对已经被占用的数据块的组织和管理。 而新的数据块保存在哪里，就需要用到空闲空间管理来进行分配。 空闲表法 为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。 这个方式是连续分配的，空闲块个数符合要求才会进行分配。 这种方法适用于仅有少量空闲块，如果存储空间有大量小空闲块，则空闲表很大。 空闲链表法 使用链表的方式来管理空闲空间，每个空闲块有一个指针指向下一个空闲块。 这种方法很方便把空闲块连接起来一起分配。 回收空间时就把空闲块依次连接到链头上，主存中只保存指向第一个空闲块的指针。 特点是简单，但不能随机访问，工作效率低，不适用于大型文件系统。 位图法 利用二进制的一位来表示磁盘中的一个盘块的使用情况。 当值为 0 时表示对应的盘块空闲，值为 1 时表示对应的盘块已分配。 文件系统的结构 上面提到的位图法，一个块的位图+这个位图表示的所有块，假设一个块大小为 4 KB，则这样一个数据结构最多只能表示 128 MB 的空间。 上面的数据结构成为块组，而一个文件系统有大量的块组。 块组的内容 超级块，包含文件系统的重要信息。比如 inode 总个数、块总个数。 块组描述符，包含文件系统中各个块组的状态。比如空闲块和 inode 数目。 数据位图和 inode 位图，用于表示对应的数据块或者 inode 是否空闲。 inode 列表，inode 用于保存文件系统中各个文件和目录相关的所有元数据。 数据块，包含文件的有用数据。 上面提到的超级块和块组描述符所包含的信息是冗余的。 它们保存的是全局消息，并且非常重要，冗余是为了提高可靠性。 文件和管理数据尽可能靠近，可以减少磁头寻道和旋转，提高性能。（空间换时间） Ext2 后续版本使用了稀疏技术，它们不再存储到每个块组中，而是只写入到块组 0、块组 1 和其他可以表示为 3、5、7 的幂的块组中。 软链接和硬链接 Linux 中可以通过硬链接和软链接的方式来给某个文件取别名。 硬链接 多个目录项中的索引节点指向一个文件，也即指向同一个 inode。 硬链接不可用于跨文件系统。 只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。 软链接 软链接相当于重新创建一个文件，这个文件的内容是另外一个文件的路径。 所以软链接的文件有独立的 inode，并且是可以跨文件系统的。 目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了。 文件 I/O缓冲与非缓冲 I/O 文件操作的标准库可以实现数据的缓存，根据是否利用标准库缓冲，可将文件 I/O 分为缓冲 I/O 和非缓冲 I/O。 缓冲 I/O，利用标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。 例子：很多程序在换行的时候再进行输出，而换行前的内容就是由标准库暂时缓存。 直接与非直接 I/O 根据是否利用操作系统的缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。 直接 I/O，不会发生内核缓存和用户程序之间的数据复制，直接经过文件系统访问磁盘。 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序；写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。 非直接 I/O，内核什么情况下会把缓存数据写入磁盘？ 在调用 write 的最后，发现内核缓存的数据太多的时候，内核会把数据写入磁盘。 用户主动调用 sync，内核缓存会刷到磁盘上。 当内存十分紧张，无法再分配页面时，会把内核缓存的数据刷到磁盘上。 内核缓存的数据的缓存时间超过某个时间时，会把数据刷到磁盘上。 阻塞与非阻塞 I/O 阻塞 I/O，当用户程序执行 read，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。 非阻塞 I/O，read 请求在数据未准备好的情况下会立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。 I/O 多路复用，也是一种非阻塞 I/O，通过 I/O 事件分发，当内核数据准备好时，再以事件的方式通知应用程序进行操作。这个做法大大改善了应用程序对 CPU 的利用率，应用程序无需一直轮询而没有做其他事情。 同步与异步 I/O 同步 I/O，上面的阻塞与非阻塞 I/O 都是同步调用，它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是同步的。如果内核实现的拷贝效率不高，那么 read 调用在这个过程中就需要等待较长时间。 异步 I/O，内核数据准备好和数据从内核态拷贝到用户态，都不需要等待。 设备管理设备控制器 电脑的输入输出设备非常多样，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等。 为了屏蔽设备之间的差异，每个设备都使用设备控制器进行管理。 控制器一般有三类寄存器 状态寄存器，存储设备的工作状态。 命令寄存器，存储 CPU 向设备发送的命令。 数据寄存器，存储 CPU 向 I/O 设备写入的需要传输的数据。 输入输出设备也可以分为两大类 块设备，把数据存储在固定大小的块中，每个块有自己的地址，例如硬盘、USB。 字符设备，以字符为单位发送或接收字符流，不可寻址，没有寻道，例如鼠标。 I/O 控制方式 硬件一般拥有中断控制器，当设备完成任务后就触发中断，通知 CPU 处理。 中断的方式对于读写频繁的磁盘并不友好，这样的 CPU 经常会被打断而影响效率。解决方法是使用 DMA 控制器，使得设备在 CPU 不参与的情况下，自行完成把设备 I/O 数据与内存交互，而 CPU 只需要在传送开始和结束的时候进行干预。 设备驱动程序 虽然设备控制器屏蔽了设备的众多细节，但是每种设备控制器的寄存器、缓冲区等使用模式也是不同的，为了屏蔽这种差异，我们还需要设备驱动程序。 设备控制器是硬件的一部分，而设备驱动程序是操作系统的一部分。 中断处理程序就位于设备驱动程序里，中断处理程序的处理流程如下 设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求。 保护被中断进程的 CPU 上下文。 转入相应的设备中断处理函数。 进行中断处理。 恢复被中断进程的上下文。 通用块层 对于块设备，为了减少不同块设备的差异带来的影响，Linux 使用一个通用块层进行管理。 通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层。 第一个功能，向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序。 第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并对队列进行重新排序、请求合并，也就是 I/O 调度，主要目的是提高磁盘读写的效率。 网络系统网络模型 开放式系统互联参考模型（OSI）（7 层） TCP/IP 网络模型（4 层） 具体可以参考 计算机网络 知识总结 这篇文章。 Linux 网络协议栈 应用程序需要通过系统调用，跟 Socket 层进行数据交互。 Socket 层的下面就是传输层、网络层和网络接口层。 最下面的一层，则是网卡驱动程序和硬件网卡设备。 Linux 收发网络包的流程 接收网络包的流程 网卡是计算机里的一个硬件，专门负责接收和发送网络包。 当网卡接收到一个网络包时，会通过 DMA 技术，将网络包放入 Ring Buffer 中，这是一个环形的缓冲区。然后触发中断，告诉操作系统。 操作系统中有一个 NAPI 机制来处理网络包。它是混合了中断和轮询的方式来接收网络包，核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收服务程序（软中断），然后通过 poll 方法轮训数据。 软中断处理网络包会从 Ring Buffer 拷贝数据到内核缓冲区，交给协议栈逐层处理。 在网络接口层会判读报文合法性，不合法则丢弃，然后找出上层协议类型（IP 协议 IPv4、IPv6），去掉帧头和帧尾，交给网络层。 取出 IP 包，判断 IP 包的走向，是发给本机的（需要交给上层处理）还是需要进行转发的。如果是发给本机的，从 IP 头查看上层网络协议类型（传输层协议 TCP、UDP），然后去掉 IP 头，交给传输层。 取出 TCP 头或者 UDP 头，根据四元组找到对应的 Socket，并将数据拷贝给 Socket 的接收缓冲区。 应用层程序调用 Socket 接口，从内核的 Socket 接收缓冲区取出数据。 发送网络包的流程 发送网络包的流程刚好和接收流程相反。 应用程序调用 Socket 发送数据包，这是系统调用，会从用户态进入内核态。 Socket 层从发送缓冲区中取出数据包，通过协议栈逐层封装。 最后达到网络接口层，添加了帧头帧尾后，放到发包队列中。 触发软中断告诉网卡驱动程序，然后通过 DMA，读取网络包，加入硬件网卡的队列中，然后通过物理网卡将其发送出去。 零拷贝 磁盘是计算机系统最慢的硬件之一，读写速度相比其他硬件来说慢了非常非常多，因此针对磁盘优化很有必要，可以大幅提高系统的吞吐量。 DMA 技术也即直接内存访问技术，在进行 I/O 设备和内存的数据传输时，交给 DMA 控制器，而 CPU 不参与这个数据搬运的工作，可以去处理别的事务。 传统的网络文件传输中，需要将磁盘上的文件读取出来，然后通过网络协议发送出去，这个过程需要两个系统调用，read 和 write，期间发送了 4 次用户态与内核态的上下文切换，因为每次系统调用会从用户态切换到内核态，完成任务后又从内核态切换回用户态。 这期间还发生了 4 次数据拷贝，从磁盘中拷贝到内核缓冲区（通过 DMA 搬运），从内核缓冲区拷贝到用户缓冲区，从用户缓冲区拷贝到内核的 Socket 缓冲区，从 Socket 缓冲区拷贝到网卡的缓冲区（通过 DMA 搬运）。 可以看到，想要提升网络文件传输的性能，就需要减少用户态与内核态的上下文切换和内存拷贝的次数，也就是零拷贝技术。 减少上下文切换次数的思路是减少系统调用，因为系统调用必然会导致两次上下文切换。 减少内存拷贝次数的思路是减少其中不必要的拷贝，比如通过用户缓冲区的这个过程，如果用户程序并没有对数据进行修改，这个过程是不必要的。 mmap + write 技术 通过 mmap() 系统调用函数直接把内核缓冲区的数据映射到用户空间，而没有进行实际的数据拷贝操作。这个技术可以减少一次拷贝操作。 sendfile 函数 ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 参数分别是目的端文件描述符、源端文件描述符、源端偏移量、复制数据长度。返回值是实际复制数据的长度。 这个函数只有一次系统调用，因此只有 2 次上下文切换开销。 这个函数的数据拷贝次数也是 3 次，数据没有到用户缓冲区。 SG-DMA 技术 如果网卡支持 SG-DMA 技术，还可以再减少一次数据拷贝，无需通过 Socket 缓冲区。 具体过程是只有缓冲区描述符和数据长度传送到了 Socket 缓冲区，然后网卡的 SG-DMA 控制器直接从内核缓冲区将数据拷贝到网卡的缓冲区里。 这个技术就是真正的零拷贝技术，两次数据拷贝都是 DMA 完成的，无需使用 CPU 进行数据搬运，没有从内存层面拷贝数据。 大文件传输 PageCache 也即磁盘高速缓存，它是内存中存放的磁盘的部分缓存。 缓存最近被访问的数据。 预读功能。 在传输大文件（GB 以上级别）时，PageCache 会失效。 PageCache 被大文件占据，其他热点小文件无法充分利用 PageCache 提高读写性能。 PageCache 无法一次性装入大文件，换进后又换出，并且其中一些文件再次被访问的概率也非常低，无法享受缓存带来的好处，还耗费了 DMA 的一次拷贝。 因此大文件传输不应该使用 PageCache 零拷贝技术。一般是采用异步 I/O + 直接 I/O 的方式，绕开 PageCache。 I/O 多路复用 Socket 模型中，一个客户端请求对应一个连接。 多进程模型中，一个连接对应一个子进程，复制了父进程的文件描述符，就可以维护一个已连接 Socket，不过进程上下文切换的开销非常大，100 以上连接就开始扛不住。 多线程模型中，一个连接对应一个线程，比起多进程开销小了一些，但是频繁的创建和销毁线程也会带来不小的系统开销。这个时候可以采用线程池进行避免，也就是提前创建若干个线程，用于处理已连接的 Socket。不过需要注意的是，已连接 Socket 队列是全局的，为了避免多线程竞争，操作这个队列时需要加锁。 有没有只使用一个进程来维护多个 Socket 呢？其实就是 I/O 多路复用技术。 select/poll select 是将已连接的 Socket 都放到一个文件描述符集合，调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，将此 Socket 标记为可读/可写，再把文件描述符拷贝回用户态，遍历找到可读/可写的 Socket 并处理。 select 这种方式，需要 2 次遍历文件描述符集合，2 次拷贝文件描述符集合。 select 采用固定长度的 BitsMap，表示文件描述符集合。默认最大值 1024。 poll 则是使用动态数组，以链表的方式组织，突破了文件描述符个数限制。 它们并没有本质区别，都是使用线性结构存储，都需要使用遍历的方式检查。 epoll epoll 在内核中是使用红黑树来跟踪进程所有待检测的文件描述符。每次操作只传入需要检测的 Socket，可以在对数时间内得到结果。并且是在内核中完成，减少了大量的内存分配和数据拷贝的工作。 epoll 使用了事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 Socket 有事件发生时，通过回调函数将其加入这个链表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符个数，而无需进行轮询。 边缘触发（ET），当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核中读取数据。因此我们要保证一次性将内核缓冲区的数据读取完。边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作直到返回错误。 水平触发（LT），当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 苏醒，直到内核缓冲区的数据被 read 函数读完才结束。 "},{"title":"智力题：12 硬币问题","date":"2021-08-23T17:58:00.000Z","url":"/2021/08/24/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A12%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/","categories":[["智力题","/categories/%E6%99%BA%E5%8A%9B%E9%A2%98/"]],"content":"题目描述：现在有 12 枚硬币，其中有 1 枚是假币，它的重量和真币不同，不知道它是重了还是轻了，你只有一个没有砝码的天平，最少称重几次可以找出有问题的硬币并且知道它的轻重？ 题目分析：&emsp;&emsp;一次测量有左边重（&gt;）、左边轻（&lt;）、两边相等（=）3 种结果，而 12 枚硬币都有可能是那一枚假币，包括它们的轻重一共有 $12\\times2=24$ 种情况。则理论上来说，至少需要 3 次称重，一共产生 $3^3=27$ 个分支，才有可能对每一种情况进行分类。事实上答案也确实是 3 次。我们将 12 枚硬币编号为 1 ~ 12。下面是操作的步骤。 左边放上 1 2 3 4，右边放上 5 6 7 8 若 1 2 3 4 = 5 6 7 8 假币在 9 10 11 12 之间，左边放上 9 10 11，右边放上 1 2 3 若 9 10 11 = 1 2 3 假币是 12，左边放上 1，右边放上 12 1 &gt; 12，假币是 12 且轻 1 &lt; 12，假币是 12 且重 若 9 10 11 &gt; 1 2 3 假币在 9 10 11 之间，并且假币重，左边放上 9，右边放上 10 9 = 10，假币是 11 且重 9 &gt; 10，假币是 9 且重 9 &lt; 10，假币是 10 且重 若 9 10 11 &lt; 1 2 3 假币在 9 10 11 之间，并且假币轻，左边放上 9，右边放上 10 9 = 10，假币是 11 且轻 9 &gt; 10，假币是 10 且轻 9 &lt; 10，假币是 9 且轻 若 1 2 3 4 &gt; 5 6 7 8 可知 9 10 11 12 为真，左边放上 1 2 3 5，右边放上 4 9 10 11 若 1 2 3 5 = 4 9 10 11 假币在 6 7 8 之间，并且假币轻，左边放上 6，右边放上 7 6 = 7，假币是 8 且轻 6 &gt; 7，假币是 7 且轻 6 &lt; 7，假币是 6 且轻 若 1 2 3 5 &gt; 4 9 10 11 可以确定 6 7 8 是真，拿 6 7 8 换掉 9 10 11，等式变成 1 2 3 5 &gt; 4 6 7 8，结合第一次称重的结果 1 2 3 4 &gt; 5 6 7 8，可以知道 4 和 5 互换没有影响，4 5 也是真。假币在 1 2 3 里面，并且假币重。左边放上 1，右边放上 2 1 = 2，假币是 3 且重 1 &gt; 2，假币是 1 且重 1 &lt; 2，假币是 2 且重 若 1 2 3 5 &lt; 4 9 10 11 可以确定 6 7 8 是真，同上置换可以知道假币就在 4 和 5 之间 1 = 4，假币是 5 且轻 1 &lt; 4，假币是 4 且重 1 2 3 4 &lt; 5 6 7 8，逻辑同上 "},{"title":"Leetcode 739.每日温度","date":"2021-08-18T16:00:00.000Z","url":"/2021/08/19/Leetcode%20739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","tags":[["C++","/tags/C/"],["单调栈","/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 示例 2: 示例 3: 提示： $1 &lt;= temperatures.length &lt;= 10^5$ $30 &lt;= temperatures[i] &lt;= 100$ 链接： 题目分析&emsp;&emsp;这道题要寻找的是“之后几天”出现了更高的温度，那遍历的顺序应该是从右向左。对于一个更高的温度，它右边所有低于它的温度就失去作用了，这是因为如果 i 低于右边的温度，那 i 也肯定低于当前的温度，而当前温度比右边的温度更“早”出现，所以答案肯定不会是右边的温度。我们只需要维护从右到左逐渐降低的温度，它们才可能是答案，这其实就符合单调栈的特性（可以直接点击 单调栈 标签跳转到同类型的题目）。&emsp;&emsp;我们从右到左遍历，对于每个温度，我们查询栈顶，如果栈顶温度大于当前温度，那么栈顶就是答案；而如果栈顶温度小于当前温度，则栈顶失去作用，出栈，这样直到栈顶温度大于当前温度，或者是栈空，我们就得到了答案。然后再将当前温度入栈。&emsp;&emsp;注意这里是要填入“几天后”，也就是与答案下标的距离，那么我们直接将下标入栈而不是温度入栈（温度可以通过下标查询到），这样可以快速获取答案。注意一下等于也是需要出栈的（不算做更高的温度）还有栈空的情况就可以了。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们维护了一个单调栈，栈的大小不会超过 $n$。答案数组不计入空间复杂度中。"},{"title":"Leetcode 647.回文子串","date":"2021-08-18T15:33:00.000Z","url":"/2021/08/18/Leetcode%20647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 示例 2： 提示： 输入的字符串长度不会超过 1000 。 链接： 题目分析&emsp;&emsp;看到这道题就想到了 Leetcode 5.最长回文子串。在寻找回文子串的时候，我们其实也是对所有的回文子串进行了一次遍历。那道题我们采用的是中心扩展的算法，也就是对每一个字符都考虑其作为“回文中心”，能够扩展出多长的回文子串。&emsp;&emsp;函数 expand() 表示对回文中心 left 和 right 进行扩展，奇数时 left = right，偶数时 right = left + 1。在这里我们修改了一下函数返回值，先看看奇数的情况，比如我们以某个中心找到了最长长度为 5 的回文子串，那么长度为 1、3、5 这三个子串都是回文串。其实也就是 (len + 1) / 2。而我们长度是用最后的 right - left - 1 来获得的（最后的 left 和 right 会在最长回文串之外，也就是第一个不满足回文的字符上），那么就可以知道，回文串的数量刚好就是 (right - left) / 2。&emsp;&emsp;我们再来看看偶数的情况，比如我们找到了最长长度为 6 的回文子串，那么长度为 2、4、6 的三个子串都是回文串，也就是 len / 2，而长度同样也是 right - left - 1（这个是偶数），我们使用 (right - left) / 2 得到的也是正确的结果。这样我们函数的返回值就是该回文中心回文串的个数。&emsp;&emsp;由于回文串的中心不一样就可以肯定回文串不是同一个，那么我们直接对所有的回文中心进行寻找就可以了。这里注意一下，偶数回文中心的时候，i+1 越界有没有问题呢？如果传入函数，由于不满足 while 条件会直接返回，得到的结果是 0，是不会有问题的。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。我们一共有 $2n-1$ 个回文中心（包括奇数和偶数），而每一次中心扩展寻找最长回文串的时间复杂度是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 621.任务调度器","date":"2021-08-18T14:38:00.000Z","url":"/2021/08/18/Leetcode%20621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/","tags":[["C++","/tags/C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的 最短时间 。 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= task.length &lt;= 10^4$ tasks[i] 是大写英文字母 n 的取值范围为 [0, 100] 链接： 题目分析&emsp;&emsp;我们最先想到的应该是贪心的做法，也就是任务量最多的任务先完成。而执行一个任务之后都要等待 n 时间过后才能继续该任务，那么我们可以将 n+1 时间视为一个执行周期。假设任务量最多的任务次数是 maxtimes，那么我们至少就需要 maxtimes 个执行周期。假设任务数最多的任务是 A，需要执行 6 次，等待时间 n=2。那么我们的执行示意图就如下图所示。当然最后一个执行周期执行完 A 就可以结束了。总时间是 (2+1)*(6-1)+1=16 &emsp;&emsp;然后我们就可以对每个执行周期中的其他空位继续填入其他任务，我们先假设任务的总量可以安排到这些执行周期内。可以看到任务 B 执行次数跟 A 一样都是最大值，需要排到最后一个执行周期。而任务 C 是不会对结果有任何影响的。总时间是 (2+1)*(6-1)+2=17。这个时候即使将 C 下面的三个“等待”时间填满也可以。 &emsp;&emsp;假设任务量最多的任务共有 diff 种，那么假设总的任务量没有超过 (n+1)*(maxtimes-1)+diff 时，我们肯定是能够按照这种方法将其安排进这些任务列表里的。&emsp;&emsp;如果任务量超过了这个大小呢？比如下面所示，A、B、C、D 任务已经填满了这个表，而我们还有任务 F。这个时候其实我们直接将任务 F 加入到前面的执行周期就好了，为什么呢？执行周期的限制其实是对每列任务的限制，比如在这里，第一个周期的 A 执行过后，至少需要等待 2 个时间才能继续执行 A，那我们等到 3 个时间当然也是没有任何问题的。因此我们可以直接对每个执行周期任意延长。&emsp;&emsp;注意这里“延长”执行周期并不是对所有的执行周期都延长，而是只延长需要的，比如这里，前两个执行周期延长到了 4，而下面的执行周期依然是 3。这个时候我们可以发现，其实我们需要的时间数就是所有的任务数，这个时候我们已经不需要任何的“待命”时间了。 &emsp;&emsp;通过上面的分析，我们知道所需时间要么是 (n+1)*(maxtimes-1)+diff，要么是任务数，是两者中更大的那个。那么我们就只需要计算出任务量最多的任务，以及它们的种数。我们使用一个哈希表来记录每个任务的任务量，之后再遍历哈希表找出任务量最多的任务种类即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是任务数。我们只需要遍历一次任务进行记录，再遍历一次哈希表获取结果，哈希表的大小不会超过 $n$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是任务数。也就是哈希表的开销。 &emsp;&emsp;PS：上面的三个图来自 Leetcode 会员 popopop 发表的题解。由于我懒得画图，因此直接用同样的例子进行解释，然后就套用了 ta 的图，在这里表示感谢。"},{"title":"Leetcode 617.合并二叉树","date":"2021-08-18T14:04:00.000Z","url":"/2021/08/18/Leetcode%20617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 注意: 合并必须从两个树的根节点开始。 链接： 题目分析&emsp;&emsp;我们递归地处理节点就可以。把 Tree 1 作为主树，将 Tree 2 合并到 Tree 1 过来。若 Tree 1 为空则可以直接返回 Tree 2（不管是否为空都是正确的）。若 Tree 1 不为空则判断 Tree 2 是否也不为空，均不为空的话就将 Tree 2 的值加到 Tree 1 上，递归地处理它们的子树，然后返回 Tree 1。若 Tree 2 为空直接返回 Tree 1。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。我们对两个二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只是处理结点值并且连接树，没有用到额外的变量。"},{"title":"Leetcode 581.最短无序连续子数组","date":"2021-08-18T12:54:00.000Z","url":"/2021/08/18/Leetcode%20581.%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 请你找出符合题意的 最短 子数组，并输出它的长度。进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？ 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 10^4$ $-10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;这个子数组将原数组分成了三段，左边和右边都是排好序的数组，并且要满足这三段中的任意数都有大小关系。也就是说中间的任一个数都比左边的大。进阶要求提示我们应该使用遍历就可以完成，如何在遍历中找到分割数组的端点呢？&emsp;&emsp;我们先考虑左边，如果是按照从右到左的遍历顺序维护一个最小值，那么在左边的数组中，应该可以不断更新最小值，而最后一个不满足这样性质的就是左端点。我们使用一个例子来辅助理解。比如我们有这样一个数组 [1,2,3,5,6,4,9,7,8,10,11,12]，分割的区间应该是 [5 ~ 8]。先观察一下左端点 5 的性质，它其实仍然是大于 3 的，但是它比 4 大，所以已经属于中间的数组了，我们从右向左遍历，遍历到 4 的时候就记录到了最小值 4，而遍历到 5 的时候可以将左端点记录为 5（因为它比 4 大），而继续遍历 3、2、1 的时候则是不断更新最小值，那么更新最小值的时候就可以不用更新左端点。&emsp;&emsp;上面的分析中，从右到左遍历可以获得左端点，那同理从左到右遍历应该可以获得右端点。并且获得左端点是维护最小值，获得右端点是维护最大值，这两个过程是不冲突的，可以同时进行的，那么我们只使用一趟遍历就可以了。&emsp;&emsp;最后再考虑一下边界情况。如果数组最开始就是有序的，那么我们应该找不到左右端点，这个时候左右端点就是初始值，而返回结果应该是 0。另一种是数组中也可能出现同数字，这个时候要更新最值还是更新端点呢？我们考虑 [1,3,2,4,4] 这样的数组，它的分割区间应该是 [3,2]，从左到右遍历时，遍历到第二个 4 的时候，它与当前最大值相同，这个时候右端点不应该更新，而它与最大值相同，更新最大值是不会产生任何影响的。所以我们应该将等于最值的情况归为更新最值的办法中。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们只需要对数组进行一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 560.和为K的子数组","date":"2021-08-17T15:51:00.000Z","url":"/2021/08/17/Leetcode%20560.%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1： 说明： 数组的长度为 [1, 20000]。 数组中元素的范围是 [-1000, 1000]，且整数 k 的范围是 [-1e7, 1e7]。 链接： 题目分析&emsp;&emsp;刚看到这道题目的时候以为又是经典的滑动窗口问题，小于 k 增大窗口，大于 k 缩小窗口，后来眉头一皱发现事情并不简单，数组中元素可以是负的，那就不能使用滑动窗口了。&emsp;&emsp;这道题目要寻找数组中某一个区间的和为 k，发现和前几天做的题 Leetcode 437.路径总和 III 道理是完全一样的。那道题中我们把 DFS 遍历的那段路径视为一个数组，然后利用前缀和快速找到和为 target 的区间数量，使用一个哈希表存储前缀和，用前缀和作为 key，数量作为 value。&emsp;&emsp;对每一个位置的前缀和 sum，寻找前缀和为 sum-k 的个数，那么它们所夹的区间就是和为 k 的区间，将数量添加到结果中即可。然后再更新前缀和哈希表，将当前的前缀和添加进去。需要注意的是，我们需要将前缀和为 0 的数量初始化为 1，表示没有选择数组中任何数时的前缀和为 0。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们只对数组进行了一次遍历，查找哈希表并更新前缀和，而查找和插入哈希表的时间复杂度都是 $O(1)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们需要一个哈希表来存储前缀和，最大的大小就是数组的大小。"},{"title":"Leetcode 543.二叉树的直径","date":"2021-08-17T15:15:00.000Z","url":"/2021/08/17/Leetcode%20543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例： 注意：两结点之间的路径长度是以它们之间边的数目表示。 链接： 题目分析&emsp;&emsp;这道题很像 Leetcode 124.二叉树中的最大路径和。那道题中路径的概念和这道题是一样的，那我们的做法也可以是一样的。我们利用 DFS 对二叉树进行遍历，而返回值和计算最大路径长度是分开的。返回值是该节点子树的深度，而以当前结点为根的最大路径长度则是左右子树返回值之和。&emsp;&emsp;我们使用一个类的成员变量来表示出现过的最大路径长度（也就是要求的直径）。在遍历中将计算每个点作为根的最大路径长度（左右子树的最大深度之和），然后返回自己的深度（也就是左右子树的最大深度加上 1），供给上层节点使用。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。递归的最大深度为 $n$。"},{"title":"Leetcode 538.把二叉搜索树转换为累加树","date":"2021-08-17T13:25:00.000Z","url":"/2021/08/17/Leetcode%20538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 树中的节点数介于 $0$ 和 $10^4$ 之间。 每个节点的值介于 $-10^4$ 和 $10^4$ 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 链接： 题目分析1.我的做法&emsp;&emsp;二叉搜索树的特点就是有序，如果按照中序遍历的顺序就可以得到升序序列，而题目中要求将节点的值更新为大于等于它的所有节点和，其实就是要进行中序遍历的逆序，并将节点值累加起来作为新节点值。&emsp;&emsp;中序遍历的逆序可以使用 DFS 来完成。我们传给一个节点的值就是上一个节点更新后的值。这个数可能来自父节点，也可能来自右孩子。那么我们使用一个参数 up 表示从上层（父节点）传过来的值，而返回值就是当前结点所表示的子树最左的节点值（最近更新的值）。&emsp;&emsp;遍历的顺序是 右中左。我们先遍历右子树，得到的返回值给自己更新，并将更新后的值传给左子树。而左子树的返回值才是我们要传给上层的返回值。&emsp;&emsp;比如示例 1 中，节点 6 将右子树 7 返回的 15 加到自己身上得到 21，然后把 21 传给左子树 5 进行更新，左子树更新后返回 26，节点 6 返回给上层的也是 26，表示这个子树累加的值是 26。然后节点 4 就可以根据节点 6 返回的 26 将自己更新为 30，继续传给左子树 1。而对于空的节点，我们则将 up 原封不动地返回去，这样就没有影响。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。我们对二叉树做了一次中序遍历的逆序。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。也就是 DFS 中栈的开销，最坏情况下深度为 $n$。 2.官方题解&emsp;&emsp;官方题解的第一个做法也是同样的思路，按照中序遍历的逆序遍历。不同的是，官方题解使用了一个类的成员变量（也就类似于全局变量）记录累加和，然后就没有多写一个 DFS 函数。当然这样也是一种方法，然后我在下面的评论区找到了和我做法一模一样的 Java 题解（还是十分有成就感的），那个人说这算是一种 code smell，就是尽量不要使用这样的全局变量，虽然对于这个题目来说全局变量无伤大雅，但是类内部的变量都这么无所谓的话，就变成一坨 shit 了。嗯很有道理。&emsp;&emsp;第二种方法是使用了 Morris 遍历的方法，大概就是说直接将前缀节点（右子树的最左子节点）连接到当前节点上，这样是利用了树中指向空的指针，所以是无需额外空间的，然后处理顺序就可以通过这个前缀节点进行。代码如下，我感觉很难讲出来具体操作，可以结合代码理解。 "},{"title":"Leetcode 494.目标和","date":"2021-08-17T11:59:00.000Z","url":"/2021/08/17/Leetcode%20494.%E7%9B%AE%E6%A0%87%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 示例 2： 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 链接： 题目分析&emsp;&emsp;对于每一个整数，要不添加的是正号，要不添加的是负号，那么可以将他们分成两类。假设正数类的和为 pos，负数类的和为 neg，那么需要满足 pos - neg = target。而我们有 pos + neg = sum（sum 表示数组所有数的和）。那么可以联立得到 neg = (sum - target) / 2。那这个问题就转化成了：在 nums 中挑选若干个数使得它们的和为 neg。是不是有点熟悉？其实和 Leetcode 416.分割等和子集 的解法一样了。不过那道题是判断目标和是否存在，而这道题是需要输出目标和的数量。&emsp;&emsp;采取同样的动态规划方法，外层是逐一判断每个数放入和不放入背包的情况，内层是计算凑成某个背包大小的方案数。这个时候我们要把 dp[0] 初始化为 1，表示一种方案的起始点。同样的，使用空间降维的方法，内层循环需要从大到小。&emsp;&emsp;这道题也可以先进行一些剪枝，比如我们从提示中可以看到数组中的数是正整数，那么计算得到的 neg 不能小于 0，还有 diff 也不能是奇数，遇到这两种情况都可以直接返回 0。 &emsp;&emsp;时间复杂度：$O(n\\times(sum - target))$，其中 $n$ 是数组的元素个数，$sum$ 是数组元素和，$target$ 是目标和。也就是我们双层遍历的时间复杂度。&emsp;&emsp;空间复杂度：$O(sum-target)$，其中 $sum$ 是数组元素和，$target$ 是目标和。也就是保存动态规划状态的数组大小。"},{"title":"Leetcode 461.汉明距离","date":"2021-08-17T11:19:00.000Z","url":"/2021/08/17/Leetcode%20461.%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","tags":[["C++","/tags/C/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。 示例 1： 示例 2： 提示： $0 &lt;= x, y &lt;= 2^{31} - 1$ 链接： 题目分析&emsp;&emsp;两个数的汉明距离其实就是他们异或后 1 的个数。计算一个数 1 的个数可以用位运算解决。一种方法是右移一位一位计算。另一种就是 z 与 z-1 进行按位与，可以消掉 z 的最右一个 1，这个算法叫 Brian Kernighan 算法（我们当时判断一个数是不是 2 的幂次也是用的这个位运算，消除最右一个 1 后会直接变成 0），这样有多少个 1 只需进行多少次位运算，比右移一位一位算更快一点。 &emsp;&emsp;时间复杂度：$O(\\log z)$，其中 $z$ 表示两个数异或后的大小。我们是将其二进制化进行位运算，最差情况下每一位都要计算。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行位运算和记录。 &emsp;&emsp;PS：官方题解中提到在工程中我们应该使用编程语言的内置函数，这样才是最快的方法。例如 C++ 的是 return __builtin_popcount(x ^ y);。而我们学习算法的时候就要学习造轮子。"},{"title":"Leetcode 448.找到所有数组中消失的数字","date":"2021-08-17T10:30:00.000Z","url":"/2021/08/17/Leetcode%20448.%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。 示例 1： 示例 2： 提示： $n == nums.length$ $1 &lt;= n &lt;= 10^5$ $1 &lt;= nums[i] &lt;= n$ 链接： 题目分析&emsp;&emsp;我们需要找到数组中没有出现过的数字，最容易想到的就是使用哈希表记录出现过的数，这样需要空间大小为 $O(n)$ 的哈希表。而进阶要求中说不使用额外空间，那我们就需要思考原数组如何利用。可以知道原数组的大小也是 n，是否可以将原数组当成一个哈希表来使用呢？区间 [1, n] 的各个数字刚好对应数组 [0, n-1] 各个下标。&emsp;&emsp;遍历数组，对于出现的元素 num 我们就标记 nums[num-1]，我们考虑如何进行标记，因为 nums[num-1] 可能还未被遍历到，需要标记后仍然能使用。一种方法是标记的时候将其作为下一个查找的目标，那样需要在数组中跳跃。另一种就是考虑标记后能够还原成原数字的方法，比如数字的范围是 1~n，那我们可以将其置为相反数，还原的时候取绝对值就可以。&emsp;&emsp;具体操作就是每次将需要标记的下标计算出来（当前元素的绝对值减一），然后判断其是否未标记（仍然是正数），然后进行标记（置为相反数）。全部标记完毕后，我们就可以遍历数组，对于每个仍是正数的元素，说明其下标加一的那个数不存在数组中，加入结果数组。对于负数的元素我们进行还原（这个操作好像也可以不要，题目不检查是否已经改动了原数组）。这样就达到了进阶的要求。&emsp;&emsp;PS：这样的算法也是一种原地算法，就是在原数组进行操作的算法。官方题解也是差不多的思路，而进行标记的方法是加上 n，这样也会超过原数字的范围，然后还原的方法是对 n 取余。这样也是一种方法，好处是操作之前不需要先判断是否已经标记，因为再次加 n 也不会造成影响。但是不好的地方在于其实这样是会越界的，题目中 n 的范围可以到 $10^5$，这样最大的标记可以到达 $10^{10}$，这是超过了 int 的范围的，貌似最后的测例并没有这么大，所以官方题解可以通过所有测例。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们对数组进行了两次遍历，一次是进行标记，一次是寻找结果。&emsp;&emsp;空间复杂度：$O(1)$。我们在原数组进行操作，而结果数组不计入空间复杂度。"},{"title":"Leetcode 438.找到字符串中所有字母异位词","date":"2021-08-16T16:33:00.000Z","url":"/2021/08/17/Leetcode%20438.%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指字母相同，但排列不同的字符串。 示例 1: 示例 2: 提示: $1 &lt;= s.length, p.length &lt;= 3 * 10^4$ s 和 p 仅包含小写字母 链接： 题目分析&emsp;&emsp;刚阅读题目的时候以为异位词必须满足排列不同，那排除排列完全相同的情况还是有点麻烦的，后面观察示例发现排列完全相同也算在异位词里面，那就好办了。这道题有点像 Leetcode 76.最小覆盖子串，我们知道异位词首先需要满足的是长度相同，那么可以使用滑动窗口的思想，而这个窗口的大小是固定的，就是 p 的长度。异位词只需要满足字母相同，那么我们可以使用一个哈希表来记录 p 中各个字母的数量，作为我们的目标 target。&emsp;&emsp;在那道题中，我们使用了另外一个哈希表来记录窗口中的各字母数量并将其与 target 进行比对，在这道题中我们要寻找的是字母完全相同的子串而不是能够覆盖的子串，那么可以不使用另外一个哈希表，而是直接对 target 进行操作。进入窗口的每个数我们直接将 target 中对应的值减 1，视为“匹配目标”，这样当 target 中所有的值都为 0 的时候也就意味着当前窗口的字母与 p 完全相同。而移出窗口则加 1，也就是“退出匹配”。&emsp;&emsp;开始时先将与 p 长度相同的字符加入窗口，成为初始窗口。窗口进行滑动的时候，将右边的一个字符加入窗口，左边一个字符移出窗口即可。对于每一个窗口，我们都判断 target 的所有值是不是都变成了 0，是则说明当前窗口是一个异位词，将窗口的起点索引加入结果数组。&emsp;&emsp;需要注意的细节是，p 的长度如果比 s 大是一定不满足的，可以返回空数组。然后移动窗口的时候不要越界，也就是最后一个窗口判断后不能再继续右移了。 &emsp;&emsp;时间复杂度：$O(|\\alpha|\\times n)$，其中 $n$ 是 s 的长度，$|\\alpha|$ 是哈希表的大小，在这里不超过 26。我们进行窗口滑动相当于对字符串 s 进行了一次遍历，而每一个窗口都需要遍历哈希表判断是否值全为 0。题目中说明了字符串中仅包含小写字母，也就是不超过 26 个字符。&emsp;&emsp;空间复杂度：$O(|\\alpha|)$。也即哈希表的大小。而作为结果输出的数组不计入空间复杂度中。"},{"title":"Leetcode 437.路径总和 III","date":"2021-08-16T15:04:00.000Z","url":"/2021/08/16/Leetcode%20437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["DFS","/tags/DFS/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 示例 1： 示例 2： 链接： 题目分析&emsp;&emsp;通过题意和示例我们了解到，这个路径的起点和终点无需是根结点或者叶子结点，那么很难用从上往下或者是从下往上传递的路径和。联想到我们做过的 求数组任意区间内元素之和 这样的题目（查询了一下是 Leetcode 303，没有在 Leetcode 上做过，是之前在程序设计的时候就做过，非常经典的题目）。我们的处理方法是不记录数组的每个数，而是直接记录数组到这个数的累加和，而区间和就是用区间右端点的累加和减去左端点的累加和，这样对于多次查询我们就不用再遍历进行累加。“累加和”我们也可以视为“前缀和”，也就是表达了数组从起点到这个数作为“前缀”的和。在这道题上，可不可以也把根结点到叶子结点的这段路径视为一个数组呢？这样任意一段路径的和也就是数组某一个区间的和，我们要找的也就是区间和为 targertSum 的区间数量。&emsp;&emsp;我们来思考一下树和数组中有什么不同。树中带有分叉，而不同分叉的也就不算做是一个路径了。我们如果使用深度优先搜索的遍历方式，维护的其实就是单条路径，那么我们可以使用回溯的方法，寻找完某一个结点后，将其从数组中删去，然后遍历别的结点，这样实时维护的就是一条路径而已。然后再次考虑一下，我们需要找到的是特定和的区间，而不是特定区间的和，我们遍历到某个结点时计算出当前的前缀和 preSum，需要知道的是前缀和为 preSum - targetSum 的区间是否存在（它们的差就是 targetSum 也即那段路径的和就是符合题意的），那么我们可以使用哈希表而不是数组进行记录，可以加快搜索速度。&emsp;&emsp;另外思考一个问题，在一条路径中，前缀和为某个数的区间是否可以不止一个？答案是可以的。因为结点值可以为负，那么应该存在某个和为 0 的区间，包含它们或者不包含它们的前缀和就是相同的。那我们使用哈希表记录某个前缀和是否存在的时候，应该同时记录它的数量，那我们就需要使用到 unordered_map 了。key 是前缀和，value 是数量。然后我们回溯删除的时候就把那个前缀和的数量减 1。&emsp;&emsp;答案我们是使用类的成员变量表示的，DFS 函数中传入父节点的前缀和，便于计算当前结点的前缀和，并将其加入到哈希表中。这里我们使用的是一个 if 语句先判断前缀和是否已存在，存在则数量加 1，遍历子节点后回溯减 1；不存在则创建并赋值为 1，遍历子节点后删除。&emsp;&emsp;后来看了一下别人的做法才了解到，unordered_map 的 value 值是有缺省值的，int 类型的就是 0，因此无需进行判断再插入的，这样的话一个前缀和不存在之后 value 值就会归为 0，而不会从哈希表中删掉，对于最后的结果也是没有影响的。&emsp;&emsp;而根结点也是可以作为路径中的点的，调用 DFS 从根结点中开始，根结点的“父节点”的前缀和我们认为是 0，那么也要将这个 0 先加入到哈希表中。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们对二叉树进行了一次 DFS 遍历，而查询和插入哈希表的操作都是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。当二叉树是一条链时栈的深度达到了 $n$，并且哈希表记录的也是整条路径中每个结点的前缀和，大小也会达到 $n$。"},{"title":"Leetcode 416.分割等和子集","date":"2021-08-14T15:55:00.000Z","url":"/2021/08/14/Leetcode%20416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 示例 2： 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 链接： 题目分析&emsp;&emsp;一开始想到的是类似于贪心这样的做法，比如维护两个数组，每次总是先添加到较小的那个数组，或者是从大到小贪心地加入数字直到它们的和等于总和的一半。但是考虑了一下总是能举出反例，导致找出答案的复杂度肯定不太美丽。无奈瞄了一眼官方题解，好家伙，原来是 NP 完全问题。（我在观察到题目的数据数量级的时候就意识到这可能没有复杂度很低的做法，毕竟数量级挺小）然后才了解到，这道题目是经典的 0-1 背包问题，有空需要了解一下相关方面的题目了。&emsp;&emsp;经典的 0-1 背包问题也是使用动态规划来做的，主要思想就是，对于每一个元素考虑要不要放入背包（也就是分类讨论，这也符合动态规划的特点）。这道题目，我们可以视为我们要从这个数组中找出若干个数，让它们的和达到数组总和的一半，而这个数目就是背包的大小 target，而我们对元素一个一个进行考虑。这样我们令 dp[i][j] 表示 0 ~ i 个元素能否取出若干个数凑成大小 j。那么第 i 个数有放入或者不放入两种做法。 放入。那么如果 0 ~ i-1 能凑出 j-nums[i]，我们就可以达成。 不放入。那么如果 0 ~ i-1 能凑出 j，我们也可以达成。 &emsp;&emsp;注意一下不要越界（也即 j &gt;= nums[i] 才能放入），那么便有这样的状态转移： dp[i][j] = \\begin{cases} dp[i-1][j]\\ ||\\ dp[i-1][j-nums[i]], & j\\geq nums[i] \\\\ dp[i-1][j], & j < nums[i] \\end{cases}&emsp;&emsp;边界条件是什么呢？当 j == 0 时，所有数都不放入即可，我们可以视为 true。而元素一个一个考虑，假设有 n 个元素，最后的结果就是 dp[n-1][target]。&emsp;&emsp;观察到，动态状态中每一层（也即外层 i）只与上一层的状态有关，那么我们可以进行降维，类似于滚动数组的思想，只使用一层来存储状态。实际上这也是 0-1 背包问题的常见优化方向。需要注意的是，这个时候内层循环需要从大到小遍历。为什么呢？相关的上一层状态是更小的状态，那么从大到小遍历才可以保证进行转移的状态是上一层的状态而不是这一层的状态。这样我们便完成了空间降维。&emsp;&emsp;这道题还可以先进行一部分的剪枝，比如数组元素个数小于 2 个，那是不可能划分成两个数组的。比如数组的总和是奇数，这样肯定无法分成两个和为其一半的数组。比如数组中的最大元素已经超过和的一半了，这样其他元素和也不够一半，同样无法分割。 &emsp;&emsp;时间复杂度：$O(n\\times target)$，其中 $n、target$ 分别表示数组的大小和数组总和的一半。也就是我们双层遍历的时间复杂度。&emsp;&emsp;空间复杂度：$O(target)$，其中 $target$ 是数组总和的一半。也就是我们经过优化后用来存储状态的数组。"},{"title":"Leetcode 406.根据身高重建队列","date":"2021-08-14T14:36:00.000Z","url":"/2021/08/14/Leetcode%20406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/","tags":[["C++","/tags/C/"],["排序","/tags/%E6%8E%92%E5%BA%8F/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 示例 2： 提示： $1 &lt;= people.length &lt;= 2000$ $0 &lt;= hi &lt;= 10^6$ $0 &lt;= ki &lt; people.length$ 题目数据确保队列可以被重建 链接： 题目分析1.从低到高处理&emsp;&emsp;题目中对 i 个人有影响的只有比他高的并且站在他前面的人，那么如果我们按身高从低到高的顺序进行处理，那么先处理的人的位置对后处理的人是没有影响的，这个时候我们只需要给后处理的人留“空位”，我们使用一个和人数相同大小的空数组（每个人一个空位）表示我们的结果。我们先不考虑同样身高的人，假设第 i 个人前面有 k 个比他高的人，那么我们只需要在结果数组中，给这 k 个人留了空位，那么自己就在第 k+1 个空位中，这样后处理填进去的这 k 个人就能满足条件，而先处理的那些人则没有影响。这样不断填充队列就可以得到答案。&emsp;&emsp;接下来我们需要考虑相同身高的人的情况。假设有两个人同身高，而他们一前一后，在后面的那个人数值应该会大 1，前面的人是能够对后面的人产生影响的，而后面的人却不会对前面的人产生影响。根据我们处理的逻辑：先处理的人不对后处理的人产生影响，我们应该先处理后面的人。那么我们对原数组进行排序时，第一关键字是身高，低的在前面；第二关键字也需选择，让数值大的在前面（先处理）。这里我们使用一个 Lambda 表达式直接表示。&emsp;&emsp;答案数组我们给上初始值 -1，表示空位（因为人物编号从 0 开始）。每次处理的时候在第 k+1 个空位填上数值即可。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是人数。排序的时间复杂度是 $O(n\\log n)$。后面的处理中，我们需要处理 $n$ 个人，而搜索空位的时间复杂度是 $O(n)$，那处理的时间复杂度应该是 $O(n^2)$。那么总的时间复杂度就是 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(\\log n)$，其中 $n$ 是人数。也即排序算法所需要的栈空间。而作为答案返回的数组不计入空间复杂度。 2.从高到低处理&emsp;&emsp;相反的，我们也可以从高到低进行处理。这个时候，后处理的不会对先处理的产生任何影响。那么我们可以采用“插入”的思路，已经插入的人都会对当前处理的人产生影响，这个时候我们只需要数出 k 个人并在他后面插入即可。当然对于同样身高的人的处理顺序也是和前一种相反的。&emsp;&emsp;从代码上来看更简洁了一些，因为 STL 中 vector 是可以在数组中间插入元素的，但是实际操作时间复杂度会更高一点，这是由于数组插入是需要整体移动的，会比搜索来的慢。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是人数。排序的时间复杂度是 $O(n\\log n)$。后面的处理中，我们需要处理 $n$ 个人，而对数组进行插入是 $O(n)$，那处理的时间复杂度应该是 $O(n^2)$。那么总的时间复杂度就是 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(\\log n)$，其中 $n$ 是人数。同上。"},{"title":"Leetcode 399.除法求值","date":"2021-08-14T12:00:00.000Z","url":"/2021/08/14/Leetcode%20399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/","tags":[["C++","/tags/C/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。 注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。 示例 1： 示例 2： 示例 3： 提示： 1 &lt;= equations.length &lt;= 20 equations[i].length == 2 1 &lt;= Ai.length, Bi.length &lt;= 5 values.length == equations.length 0.0 &lt; values[i] &lt;= 20.0 1 &lt;= queries.length &lt;= 20 queries[i].length == 2 1 &lt;= Cj.length, Dj.length &lt;= 5 Ai, Bi, Cj, Dj 由小写英文字母与数字组成 链接： 题目分析&emsp;&emsp;一开始被示例吓了一跳，以为 bd 表示的是 b 乘 d，那这道题要分析的情况就特别复杂，还好仔细阅读题目之后发现，Ai 或 Bi 表示的就是单个变量。（PS：在题解中也发现了同样的兄弟，他甚至还以为有 5b / 3d 这样的出现，那就更复杂了。）&emsp;&emsp;首先我们可以简化一下，将每个变量使用一个数字编号表示，这样做的好处是可以将它们在数组中处理，并且同时也可以统计所出现的变量个数。这个过程可以使用一个哈希表完成，统计不同的变量并给他们从 0 开始的编号，最后 count 的值就是变量的个数。 &emsp;&emsp;然后我们来分析一下变量之间的转化过程，比如我们有 a / b = x 和 b / c = y，那么我们就有 a / c = (a / b) * (b / c) = x * y。那么它们是有传递关系的，很容易可以想到使用图来表示，每个变量是一个结点，而它们之间的边权值就可以用除法值表示，那么我们可以得到一个有向图。对于没有直接连接的结点呢？其实就是路径中的各个权值乘起来。那么其实是一个最短路径问题，只是这个路径中的权值不是加起来的而是乘起来的，并且任意路径都是最短路径。我们最后需要对所有的问题作出回答，也即可能是任意两个变量之间的最短路径，对于这种多源最短路径问题可以使用 Floyd 算法。&emsp;&emsp;定义一个二维数组，result[i][j] 表示 i 到 j 的路径，我们先将初始值赋为 -1.0 也即题目中定义的不可达。先将直连的边加入数组，这里注意加入是双向的。然后使用三层循环遍历即可得到结果，而判断的条件从“最短”改为了“是否可达”。 &emsp;&emsp;最后我们再对每一个问题进行查询并输出结果即可，注意题目中提到问题中的变量也有可能是从未出现过的，那么我们需要先判断是否出现再处理。 &emsp;&emsp;时间复杂度：$O(E+N^3+Q)$，其中 $E、N、Q$ 分别表示初始边、变量、问题的数量。建立哈希表的时间是 $O(E)$，初始化图是 $O(E)$，而 Floyd 算法是 $O(N^3)$，最后每个问题查询时间是 $O(1)$，共有 $Q$ 个问题。这里是把变量的长度视为常数。&emsp;&emsp;空间复杂度：$O(N^2)$，其中 $N$ 表示出现的变量数。哈希表的大小是 $O(N)$，而进行 Floyd 算法得到的结果数组需要 $O(N^2)$ 的空间进行存放，作为结果返回的问题答案不计入空间复杂度。 &emsp;&emsp;这道题还有并查集的做法。还没学会，待填的坑++。"},{"title":"Leetcode 394.字符串解码","date":"2021-08-14T10:21:00.000Z","url":"/2021/08/14/Leetcode%20394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 1： 示例 2： 示例 3： 示例 4： 链接： 题目分析&emsp;&emsp;根据编码的规则和给出的示例，我们可以看到这个编码是存在着嵌套的结构的，那么我们可以考虑使用递归的方法进行处理。对于我们遇到的每一个数字，都意味着出现了 k[encoded_string] 结构。那么我们可以将这个结构作为一个整体进行处理，然后返回一个处理好的字符串，交给外层的嵌套结构进行处理。为了方便，我们可以直接将待处理的原字符串和正在处理的下标使用这个类的成员变量表示，这样就可以在各个函数中直接使用。&emsp;&emsp;读取 k 的函数是 getDigits()，可以读入一位或多位的数字串，并转化成整型变量表示，最后下标会停留在下一位，也就是 &#39;[&#39; 上。&emsp;&emsp;读取字符串的函数是 getString()。结束条件是到达字符串结尾或者遇到了 &#39;]&#39;。读取的时候我们需要先判断是不是数字，如果是的话就获取到数字 k 也即我们的重复次数。然后停留在 &#39;[&#39; 上需要跳过。而我们的循环体就要使用递归结果继续调用 getString() 获取。获取后是停留在 &#39;]&#39; 上的，我们也要跳过。然后我们将获取到的字符串重复 k 次，这样就处理好了一个 k[encoded_sting] 结构。如果读取到的是字母，那么我们将字母添加上去即可。&emsp;&emsp;而这样一次处理只是处理好了一个 k[encoded_string] 结构或者是一个字母，而我们可能有多个这样的结构顺序排列，所以返回的结果应该是处理好的这个串接下一次处理 ret + getString()。&emsp;&emsp;这样可以处理并列或者嵌套的结构，最后在主函数中给两个成员变量赋初始值并调用最外层的一个 getString() 函数即可得到最终结果。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是解码后的字符串长度。我们对原字符串进行一次遍历进行处理，而最后得到的字符串就是一个字符一个字符添加上去的。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是解码后的字符串长度。主要是栈递归的深度，还有嵌套过程中保存的临时字符串，栈递归的深度和临时字符串的长度都不会超过解码后字符串的长度。"},{"title":"Leetcode 347.前 K 个高频元素","date":"2021-08-12T16:31:00.000Z","url":"/2021/08/13/Leetcode%20347.%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["堆","/tags/%E5%A0%86/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 示例 1: 示例 2: 提示： $1 &lt;= nums.length &lt;= 10^5$ k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 链接： 题目分析&emsp;&emsp;这道题也是一道 Top-K 问题，不同之处在于我们还需要统计每个数字出现的次数。这里我们使用一个哈希表统计每个数字出现的次数。之后再使用 Leetcode 215.数组中的第K个最大元素 同样的做法得到出现前 k 多的元素即可。&emsp;&emsp;稍微有点不同的是，这里我们统计的是出现的次数，没办法在原数组进行操作，所以只能首先将前 k 个数加入到数字中，建立一个堆。并且我们要比较的是数字出现的次数，而最后记录的结果是数字本身，因此哈希表也要传入函数中作为比较依据，而存入堆数组的就是数字本身。 &emsp;&emsp;时间复杂度：$O(n\\log k)$，其中 $n、k$ 分别是数组的大小和题目中的 k。建立哈希表需要遍历一次数组，所花时间 $O(n)$。遍历数组并加入堆调整堆的时间复杂度为 $O(n\\log k)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。哈希表的大小就是数组中不同元素的种类，不会超过数组大小，为 $O(n)$，而堆的大小为 k，也是不超过数组大小，并且作为返回结果应该可以不计入空间复杂度。"},{"title":"Leetcode 338.比特位计数","date":"2021-08-12T15:06:00.000Z","url":"/2021/08/12/Leetcode%20338.%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 示例 2: 进阶: 给出时间复杂度为 $O(n*sizeof(integer))$ 的解答非常容易。但你可以在线性时间 $O(n)$ 内用一趟扫描做到吗？ 要求算法的空间复杂度为 $O(n)$。 你能进一步完善解法吗？要求在 C++ 或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 链接： 题目分析1.动态规划 - 最高位&emsp;&emsp;按照进阶要求中的意思，应该就是不要对每一个数都去模 2 取余一个一个算，那么应该就是要好好利用前面已经算好的结果。观察了一下它们的特点，发现每到 2 的幂次时，就会开启一个新的最高位，并且只有最高位为 1，其他都重置为 0，这个时候前面的那些位又相当于从 0 开始，那么我们就可以取前面的结果。而取前面结果的差值刚好就是这个 2 的幂次。如何判断 2 的幂次呢？它的前一位是全 1，而自己开启了一个新的最高位，并且前面全部置为 0，那么刚好就是没有一位是同 1 的，用“按位与”这种位运算得到的结果是 0。&emsp;&emsp;其实，用位运算判断 2 的幂次这种方法，我是看了题解才了解的。然后又思索了一下，这样的代码下，对于每一个数，都要判断它与它前一位的“按位与”，这样的运算难道不也是 $O(sizeof(integer))$ 的运算吗？这里还是存在着一点不解的。当然，我自己想到的是套一层内层循环，每次循环大小乘 2，也就是直接用我们所知道的“个数”去使它准确。转念想想，每个循环也都需要判断一次是否满足循环条件，而判断循环条件在底层不也是一次位运算吗？并且循环还有自增等运算，在底层也是一次位运算吧。所以应该还是直接套用位运算是最快的，就姑且认为一次位运算是常数时间的咯。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 就是题目中所给的 n。我们对于每个数的操作是常数时间复杂度的。&emsp;&emsp;空间复杂度：$O(1)$。通常作为答案返回的数组是不计入空间复杂度的，那我们所需的额外空间只有几个变量。 2.动态规划 - 最低位&emsp;&emsp;看了一下官方题解，有 3 种动态规划，这种也是非常好理解的一种。我们也可以从最低位找规律。与前面的思路一样，我们最好能用到前面已经得出的结果，如果我们直接将数字右移一位（也就是除以 2，得到的结果肯定更小），如果最低位是 1，那么就还要加上 1，如果最低位是 0，那 1 的个数是不变的。而获取最低位就是直接将其和 1 进行按位与就可以了。 &emsp;&emsp;时间复杂度：$O(n)$。同上。&emsp;&emsp;空间复杂度：$O(1)$。同上。"},{"title":"Leetcode 337.打家劫舍 III","date":"2021-08-12T14:20:00.000Z","url":"/2021/08/12/Leetcode%20337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;依然还是采用动态规划的方法，利用 DFS 的方法遍历二叉树，每个房屋依然有偷和不偷两种选择。我们分析每一个结点作为根能够偷的最大金额，这样搜索后往上归并即可得到答案。 偷。那么这个结点的两个子结点都不能偷。 不偷。那么这个结点的两个子结点可偷可不偷。 &emsp;&emsp;通过以上的分析我们可以发现，每个结点的选择都可能影响到父节点，因此我们动态规划记录状态的时候需要记录两种选择结果，那么我们可以使用一个结构体进行存储和返回。偷记录为 robber，不偷记录为 norobber。那么我们有这样的状态转移：$\\small root.robber=left.norobber+right.norobber+root.val$，而 $\\small root.norobber=max(left.robber,left.norobber)+max(right.robber,right.norobber)$。&emsp;&emsp;从根结点进行 DFS 即可得到答案。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们对二叉树进行了一次深度优先搜索遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。主要取决于递归栈的深度，当二叉树是一条链时达到最大深度 $n$。"},{"title":"Leetcode 322.零钱兑换","date":"2021-08-09T12:25:00.000Z","url":"/2021/08/09/Leetcode%20322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= coins.length &lt;= 12$ $1 &lt;= coins[i] &lt;= 2^{31} - 1$ $0 &lt;= amount &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;我看到这道题的时候就想到了两种思路。一种是贪心法，我们知道想要使得硬币组合的总数少，那肯定是使用面值越大的越多越好，我们可以从硬币面值最大的开始使用 DFS 进行搜索。当然这样也可能导致解不存在而需要回溯，比如 amount = 21 而 coins = [2, 9, 10]，如果我们贪心的使用了两个面值为 10 的硬币就会导致找不到解，这个时候还要进行回溯，减少大面值硬币的个数。另一种情况是 DFS 找到的第一个解也不一定是最优解，比如 amount = 14 而 coins = [1, 7, 10]，DFS 找到的第一个解应该是 10+1+1+1 而最优解其实是 7+7。这样的情况导致我们即使是使用贪心法，最后也得遍历所有的可能情况，所以也不能做到很快，而且回溯的过程比较麻烦，也不够简洁。&emsp;&emsp;另一种比较暴力的方法就是动态规划。我们令 dp[i] 表示凑成 i 所需要的最少硬币数，则 dp[i] 可以通过 dp[i-j] + 1（其中 j 是单枚硬币的面值）获得。我们只需要遍历所有的硬币面值，找到使得 dp 值最小的那个即可。题目中没有说 coins 已经排序，为了加速遍历过程，我们先对其进行排序，这样在寻找最小值的过程中，到了 j &gt; i 的情况就可以直接停止。而我们最后要求的答案就是 dp[amount]。&emsp;&emsp;我们知道边界值是 dp[0] = 0，然后就可以从 1 到 amount 进行遍历。对于那些无法凑成的金额该怎么处理呢？可以直接赋为最大值 INT_MAX 吗？答案是不可以的，因为我们在状态转移的时候会对其加 1，超过了上限就会变为负数，这个时候寻找最小值就会出问题。注意到 amount 的值并不会很大，那么我们可以直接将初始值赋为 amount + 1，就表示无法凑成，因为硬币最小面值为 1，如果可以凑成一定不会超过 amount 个。这样这个数继续增大也不会出问题。最后返回结果的时候判断 dp[amount] 是否会大于 amount 即可。（当然，我们也可以先判断 dp[i-j] 是否可以凑成然后再进行状态转移，这样初始值可以赋为 -1，最后直接返回结果，也是可行的。） &emsp;&emsp;时间复杂度：$O(ac)$，其中 $a、c$ 分别表示 amount 的值和 coins 的长度。这是因为我们需要进行 amount 次状态转移，而每次状态转移的时间复杂度是 $O(c)$。这里因为 coins 的长度很小，所以排序的时间复杂度忽略。&emsp;&emsp;空间复杂度：$O(a)$，其中 $a$ 表示 amount 的值。也即保存动态规划状态的数组大小。"},{"title":"Leetcode 312.戳气球","date":"2021-08-09T12:02:00.000Z","url":"/2021/08/09/Leetcode%20312.%E6%88%B3%E6%B0%94%E7%90%83/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 示例 2： 提示： n == nums.length 1 &lt;= n &lt;= 500 0 &lt;= nums[i] &lt;= 100 链接： 题目分析&emsp;&emsp;观察示例可以发现，戳破气球可以让原本不相邻的气球变得相邻，如果每次戳破气球就按照实际情况移动数组肯定会导致复杂度过高，并且也不利于处理。最后必须要戳破所有的气球，那么我们可以考虑倒推。也即按照实际“戳破”相反的顺序，往数组中“添加”气球。&emsp;&emsp;由于数组边界视为有一个数值为 1 的气球，我们先把这两个边界加上存入一个新数组，便于后续的处理。对于区间 [i, j] 中添加气球会发生什么呢？假设 i 和 j 位置已经存在气球，并且开区间 (i, j) 中没有任何气球，那么我们往这个区间的位置 k 添加气球，获得的硬币数就是 nums[i] * nums[k] * nums[j]，并且这个时候问题转化成了往 (i, k) 和 (k, j) 中添加气球。基于这个思路我们就可以使用动态规划进行求解了。我们令 dp[i][j] 为填满 (i, j) 获得最多的硬币数。边界条件就是 (i, j) 中间已经没有数字。我们有这样的状态转移方程： \\small{dp[i][j]= \\begin{cases} \\displaystyle\\max^{j-1}_{k=i+1}(nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j]), & i"},{"title":"Leetcode 309.最佳买卖股票时机含冷冻期","date":"2021-08-09T10:01:00.000Z","url":"/2021/08/09/Leetcode%20309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）。 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 链接： 题目分析&emsp;&emsp;应该还是采用动态规划的方法，我们考虑一下每一天的状态，应该有三种：手中没有股票（不在冷冻期）、手中没有股票（在冷冻期）、手中持有股票。这是因为冷冻期一定是在卖出股票后才发生的，而我们不能同时参与多笔交易，那么冷冻期的时候手上一定没有股票。然后我们每一天能做出的选择只有买入、卖出或者不做任何事（当然，它们也有一定的前提），我们思考一下对于每种状态，做出选择后结果如何。 手中没有股票且不在冷冻期 nostock。这个时候我们可以买入股票或者保持不变。 买入股票：手中的钱变为 nostock - prices[i]，同时状态变为持有股票。 保持不变：手中的钱不变，状态也不变。 手中没有股票且在冷冻期 cooldown。这个时候我们只有保持不变一种选择。 保持不变：手中的钱不变，状态变为了手中没有股票且不在冷冻期。 手中持有股票 havestock。这个时候我们可以卖出股票或者保持不变。 卖出股票：手中的钱变为 havestock + prices[i]，同时状态变为冷冻期。 保持不变：手中的钱不变，状态也不变。 &emsp;&emsp;那么我们就得到状态转移的方式了，对于每种状态，不管是以何种状态转移过来的都没有影响（比如持有股票是本来就持有的还是昨天买入的并没有差别），那么我们只需要让该状态手中的钱尽可能地多就可以了。而且状态转移只与前一天的状态有关，那么我们也不需要一个数组来存放所有状态，我们只需要三个变量分别记录这三种状态。&emsp;&emsp;我们的初始资金可以定为 0，并允许资金为负的情况，这样最后得到的结果就是我们的利润。对于第 0 天的状态，只有买入或者不买入，我们就可以得到三种状态的初始值，之后从第 1 天开始进行状态转移即可。遍历数组后，我们比较两种手里没有股票的情况选择更大的就是答案（到结束时手里还持有股票一定不会是利润最大的情况）。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们只需要遍历一次数组进行状态转移，并且每次状态转移的复杂度是 $O(1)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量记录状态。"},{"title":"Leetcode 300.最长递增子序列","date":"2021-08-06T16:44:00.000Z","url":"/2021/08/07/Leetcode%20300.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 进阶： 你可以设计时间复杂度为 $O(n^2)$ 的解决方案吗？ 你能将算法的时间复杂度降低到 $O(n\\log(n))$ 吗? 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 2500$ $-10^4 &lt;= nums[i] &lt;= 10^4$ 链接： 题目分析1.动态规划&emsp;&emsp;我们思考子序列之间的联系，如果 nums[j] 是递增子序列中的最后一个数，则我们只需要满足 nums[i] &gt; nums[j] 且其中 i &gt; j，则 nums[i] 可以接在以 nums[j] 后面成为更长的递增子序列，这样的关联是满足动态规划性质的。而对于每个 i，满足这样关系的 j 可以是多个的，我们需要找到最长的那一个。&emsp;&emsp;我们定义 dp[i] 为以 nums[i] 为结尾的最长递增子序列。那么我们有状态转移方程：$dp[i]=max(dp[j])+1$，其中 $0\\leq j &lt; i$ 且 $nums[j]&lt; nums[i]$。最短的递增子序列就只包含本身，长度为 1，因此我们将所有的初始状态赋值为 1。对于每个状态，我们都需要遍历前面所有的状态找到最大值，需要进行双层遍历，满足第一个进阶要求。而我们所要求的结果就是这个过程中出现的最大状态值。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是数组的大小。每一个状态依赖于前面的所有状态，需要进行双层遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们需要一个数组保存所有的状态，状态数为 $n$。 2.贪心+二分 - 官方题解&emsp;&emsp;这个解法我没有想出来，看了官方题解之后看懂了，在这里用我的话重述。对于同样长度的递增子序列，哪一个是更优的？应该是最后一个数更小的那一个，因为它提供了下一个数更多的可能，换句话说，让序列上升的“慢一些”。那我们使用 greed[i] 表示长度为 i 的递增子序列中最小的末尾元素。这个数组是单调递增的。为什么呢？&emsp;&emsp;我们采用反证法，假设存在 i &gt; j 使得 greed[i] &lt; greed[j]，那么在长度为 i 的子序列 A 中，前 j 个数也可以构成一个递增子序列 B，并且这个长度为 j 的子序列 B 的末尾元素一定小于 greed[i]（因为它就包含在 A 中），那么就与 greed[i] &lt; greed[j] 矛盾了。&emsp;&emsp;这个数组是单调的有什么好处？单调的数组进行搜索的时候就可以使用二分法了。如何对这个数组进行更新呢？我们顺序遍历原数组，假设我们遍历到的数比 greed 的最后一个元素大，这意味着这个数可以构成更长的递增子序列，则我们将其添加到 greed 之后，表示新的最长长度子序列以这个数结尾。&emsp;&emsp;如果遍历到的数 nums[i] 不比 greed 最后一个元素大，思考一下对 greed 数组中的数的影响。假设 greed[0 ~ k] 是小于 nums[i] 的所有数，则对于这些数来说没有影响，因为我们本来就要让 greed 值尽可能小。而对于 greed[k+1]，这个时候我们可以用 greed[k] 代表的 k 个数加上 nums[i] 组成一个长度为 k+1 的递增子序列，也即 greed[k+1] 的值可以更新为 nums[i]。对于后面的所有数，由于 greed[k+1 ~ n] &gt;= nums[i]，则 nums[i] 对它们也没有影响。&emsp;&emsp;通过上面的分析，我们可以知道 nums[i] 只需要对单调数组 greed 中的第一个不小于它的值进行替换，则可以使用二分法搜索。这样也达到了我们第二个进阶要求中的对数复杂度。&emsp;&emsp;最后的答案就是 greed 数组的最大下标，而且 greed[0] 是没有作用的，我们可以直接全体前移一位，greed[i] 表示长度为 i+1 的递增子序列中最小的末尾元素。那么答案就刚好是 greed 数组的大小。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 是数组的大小。我们遍历了数组对 greed 进行更新，而每次更新操作的时间复杂度为 $O(1)$（插入最后）或者 $O(\\log n)$（二分法更新中间值）。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们需要一个 greed 数组，最大长度为 $n$。 &emsp;&emsp;PS：感觉还是讲不清楚第二种方法，重点在于理解 greed 数组中每个数所代表的含义（千万注意 greed 并不代表最终的递增子序列），应该就可以明白为什么只需要更新不小于 nums[i] 的第一个值了。"},{"title":"C/C++ 知识总结（更新中）","date":"2021-08-06T13:11:00.000Z","url":"/2021/08/06/C&C++%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;关于 C/C++ 知识体系的总结。 大纲 基本语法 数据类型与声明 关键字和标识符 常量与变量 运算符 表达式 基本词法 数组 字符串 各种指针 引用 内存管理 基本句法 赋值、判断、循环 结构体 函数 类和对象 命名空间 高级语法 类型转换 异常处理 I/O 设计 文件操作 多线程 C++ 编程 C 和 C++ 的区别 运算符重载 深拷贝与浅拷贝 封装 继承 多态 模板编程 C++ 标准库 STL 容器 仿函数 迭代器 适配器 C++ 11 auto 关键字 智能指针 右值引用 列表初始化 Lambda 表达式 基本语法数据类型与声明 基本数据类型 bool 布尔型 char 字符型 int 整型 float 浮点型 double 双精度浮点型 void 无类型 wchar_t 宽字符型 类型修饰符（一些基本类型可以使用一个或多个类型修饰符进行修饰） signed unsigned short long 变量声明 type variable_list; type variable_name = value; 关键字和标识符 常用关键字 上面提到的基本数据类型和类型修饰符 class / struct / union 类 / 结构体 / 联合体 const / static / extern / volatile 变量修饰符 return 函数返回 true / false 布尔值真 / 假 if / else / switch / case / default 条件语句 for / while / do / continue / break 循环语句 enum 枚举类型 try / throw / catch 异常处理 new / delete 动态内存分配 using / namespace 命名空间 nullptr 空指针 sizeof 返回数据对象所占空间大小 public / protected / private 访问说明符 template / typename 模板类 virtual 虚类 typedef 类型别名 operator 运算符重载 标识符 标识符是程序员给变量、类、函数或其他实体的唯一名称。 标识符命名规则 标识符可以由字母，数字和下划线字符组成。 它对名称长度没有限制。 它必须以字母或下划线开头。 区分大小写。 我们不能将关键字用作标识符。 我们应该为有意义的标识符提供有意义的名称。 常量与变量 变量 在编程中，变量是用于保存数据的容器（存储区）。 为了表示存储区域，应该为每个变量赋予唯一的名称（标识符）。 变量的值可以更改。 字面量 字面量用于表示固定值的数据。它们可以直接在代码中使用。 整型字面量、浮点字面量、字符字面量、转义字符字面量、字符串字面量。 常量 我们使用 const 关键字来定义一个常量。 我们还可以使用 #define 预处理器指令创建常量。 常量的值不能更改。 static 关键字的作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，表示该函数属于一个类而不是属于此类的任何特定对象，类和对象不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 const 关键字的作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 const 的指针与引用 指针 指向常量的指针（pointer to const）const type* p; 自身是常量的指针（常量指针，const pointer）type* const p; 引用 指向常量的引用（reference to const）const type&amp; p; 没有 const reference，因为引用只是对象的别名，不是对象，不能用 const 修饰 extern 关键字的作用 extern 用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。 extern 声明不是定义，即不分配存储空间。 我们也可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。为什么还要使用 extern 关键字呢？因为用 extern 引用另一个文件的范围更小，会加速程序的编译过程，这样能节省时间。 在 C++ 中 extern 还有另外一种作用，用于指示 C 或者 C++ 函数的调用规范。比如在 C++ 中调用 C 库函数，就需要在 C++ 程序中用 extern &quot;C&quot; 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用 C 函数规范来链接。主要原因是 C++ 和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。 volatile 关键字的作用 C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的内存屏障。 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 一般说来，volatile 用在如下的几个地方： 中断服务程序中修改的供其它程序检测的变量需要加 volatile； 多任务环境下各任务间共享的标志应该加 volatile； 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义。 volatile 并不能保证线程安全，因为 volatile 并不能保证变量操作的原子性。 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 局部变量：只能被函数内部或者代码块内部的语句使用。 全局变量： 全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。全局变量一旦声明，在整个程序中都是可用的。 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。 运算符 运算符类型 算术运算符：+、-、*、/、%、++、— 赋值运算符：=、+=、-+、*=、/=、%= 关系运算符：==、!=、&gt;、&lt;、&gt;=、&lt;= 逻辑运算符：&amp;&amp;、||、! 按位运算符：&amp;、|、^、~、&lt;&lt;、&gt;&gt; 其他运算符：sizeof、?:、,、.、-&gt;、&amp;（地址）、*（指针） 基本词法数组字符串引用与指针指针 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 把引用作为参数：C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值：可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 this 指针 this 指针是隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为 ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为 const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。 this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 内存管理malloc 和 free 函数 在 C 语言中只能通过 malloc() 和其派生的函数进行动态的申请内存，而实现的根本是通过系统调用实现的。free() 函数释放由其分配的内存。 malloc 函数是从堆里面获得了空间。 此外，堆中的内存块总是成块分配的，并不是申请多少字节，就拿出多少个字节的内存来提供使用。堆中内存块的大小通常与内存对齐有关。 free(p) 释放的是指针变量 p 所指向的内存，而不是指针变量 p 本身。指针变量 p 并没有被释放，仍然指向原来的存储空间，这时候 p 是个野指针。 new 和 delete 操作符 new 和 delete 是 C++ 中关于管理内存的操作符。 malloc / free 只是动态分配内存空间 / 释放空间。而 new / delete 除了分配空间还会调用构造函数和析构函数进行初始化与清理（清理成员）。 它们都是动态管理内存的入口。 malloc / free是 C/C++ 标准库的函数，new / delete 是 C++ 操作符。 malloc / free 需要手动计算类型大小且返回值为 void*（需要进行强制类型转换），new / delete 可自动计算类型的大小，返回对应类型的指针。 malloc / free 管理内存失败会返回 0，new / delete 等的方式管理内存失败会抛出异常。 实际上 new 和 delete 只是 malloc 和 free 的一层封装。 他们都需要配套使用。 基本句法赋值、判断、循环结构体内存对齐 结构体中可以存放不同类型的数据，它的大小也不是简单的各个数据成员大小之和，限于读取内存的要求，而是每个成员在内存中的存储都要按照一定偏移量来存储，根据类型的不同，每个成员都要按照一定的对齐数进行对齐存储，最后整个结构体的大小也要按照一定的对齐数进行对齐。 对齐规则 第一个成员在与结构体变量偏移量为 0 的地址。 其他成员变量要对齐到对齐数（对齐数 = 编译器默认的一个对齐数与该成员大小的较小值）的整数倍的地址处。 Linux 中默认对齐数为 4，vs 中的默认值为 8。 结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）。 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍，结构体的整体大小就是所有最大对齐数的整数倍（含嵌套结构体的对齐数）。 对齐特点： 每个成员的偏移量 % 自己的对齐数 = 0。 结构体整体大小 % 所有成员最大对齐数 = 0。 结构体的对齐数是自己内部成员的对齐数中的最大对齐数。 为什么要内存对齐？ 平台移植型好。 CPU 处理效率高。 函数inline 关键字 为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。 引入内联函数的主要原因是用它替代 C 中表达式形式的宏定义。 宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受 C++ 编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。 在 C++ 中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将 this 指针放在合适的位置）。 inline 的使用是有所限制的，inline 只适合函数体简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数。 inline 对于编译器只是一个建议，编译器会根据实际情况选择是否设置当前函数为内联函数。 类和对象概述 定义一个类（class），本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。 类成员函数：指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 构造函数：一种特殊的函数，在创建一个新的对象时调用。 析构函数：一种特殊的函数，在删除所创建的对象时调用。 拷贝构造函数：一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 友元函数：可以访问类的 private 和 protected 成员。 内联函数：通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 指向类的指针：如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 构造函数和析构函数 构造函数 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值。 析构函数 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 构造函数不能是虚函数。 若构造函数是虚的，则需要通过虚函数表来调用，若对象还未实例化，即还未分配内存空间，无法找到虚函数表。 虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数就没有实际意义。 析构函数应当是虚函数。 析构时将调用相应对象类型的析构函数。 如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。 访问修饰符 public：公有成员。任何位置都可以访问。 protected：保护成员。只有类自己和子类的成员函数以及友元函数才能访问。 private：私有成员。只有类自己的成员函数和友元函数才能访问。 C++ 的限定符是限定类的，不是限定对象的，只要是类型相同就能相互访问。 友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有成员和保护成员的函数。 尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。 struct 和 class 的区别 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 总的来说，struct 更适合看成是数据结构的实现体，class 更适合看成是对象的实现体。 命名空间 使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。 在 C++ 中，变量、函数和类都是大量存在的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。 命名空间的定义使用关键字 namespace，后跟命名空间的名称。 namespace name &#123; // 代码声明 &#125; 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称。 name::code; // code 可以是变量或函数 可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 如 using namespace std; 使用 C++ 标准库。 高级语法类型转换隐式类型转换 当运算符的操作数具有不同的数据类型时，C++ 会自动将它们转换为相同的数据类型。 当一个值被转换为更髙的数据类型时，称之为升级。反之，降级则意味着将其转换为更低的数据类型。 char、short 和 unsigned short 值自动升级为 int 值。 当运算符使用不同数据类型的两个值时，较低排名的值将被升级为较高排名值的类型。 当表达式的最终值分配给变量时，它将被转换为该变量的数据类型。 如果接收值的变量的数据类型低于接收的值，值将被降级为变量的类型。如果变量的数据类型没有足够的存储空间来保存该值，则该值的一部分将丢失。 当变量值的数据类型更改时，它不会影响变量本身。 强制类型转换 static_cast 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。 static_cast &lt;type_id&gt; (expression)。 用于类层次结构中基类和派生类之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示），是安全的。 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。 只能在有相互联系的类型中进行相互转换，不一定包含虚函数。 用于基本数据类型之间的转换。这种转换的安全需要开发人员来保证。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换为 void 类型。 static_cast 不能转换掉表达式的 const、volitale 或者 __unaligned 属性。 const_cast 用来移除变量的 const 或 volatile 限定符。 const_cast &lt;type_id&gt; (expression)。 不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。 常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 经过转换并修改值之后，常量的值不会被修改，指针取值会修改，而它们指向的地址是相同的。（这里我黑人问号，不是很懂为什么会这样，找到的资料都是说这样是无奈之举，并没有说为什么可以地址一样值不一样。） 移除 const 限定后通过指针修改值是一种未定义行为，具体操作取决于编译器。 所以说，这种用法最好只用在迫不得已的地方（比如函数参数类型不一样，只能转换），尽量不要去修改值。 reinterpret_cast 异常处理I/O 设计文件操作多线程C++ 编程C 和 C++ 的区别重载 在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。 不能仅通过返回类型的不同来重载函数。 运算符重载 大部分 C++ 内置的运算符都可以被重定义或重载。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 不可重载的运算符列表： .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 深拷贝与浅拷贝封装 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 通常情况下，我们都会设置类成员状态为私有，除非我们真的需要将其暴露，这样才能保证良好的封装性。 这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 继承 继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 一般形式：class 派生类名: 访问修饰符 基类名。 如果未使用访问修饰符，则默认为 private。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 多态概述 多态按字面的意思就是多种形态，可以简答地概括为 “一个接口，多种方法”。调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 静态多态 静态多态也称为编译时多态。 静态多态通过重载和模板实现。 动态多态 动态多态也称为运行时多态。 动态多态通过虚函数实现。 虚函数 虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。 虚函数指针 虚函数指针从本质上来说就只是一个指向函数的指针，与普通的指针并无区别。它指向用户所定义的虚函数，具体是在子类里的实现，当子类调用虚函数的时候，实际上是通过调用该虚函数指针从而找到接口。 虚函数指针是确实存在的数据类型，在一个被实例化的对象中，它总是被存放在该对象的地址首位，这种做法的目的是为了保证运行的快速性。与对象的成员不同，虚函数指针对外部是完全不可见的，除非通过直接访问地址的做法或者在 DEBUG 模式中，否则它是不可见的也不能被外界调用。 虚函数表 每个类的实例化对象都会拥有虚函数指针并且都排列在对象的地址首部。而它们也都是按照一定的顺序组织起来的，从而构成了一种表状结构，称为虚函数表。 虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面，子类覆盖父类的函数直接放到父类函数原来的位置中。 对于多重继承，每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的表中（所谓的第一个父类是按照声明顺序来判断的）。 函数的声明与定义要求非常严格，只有在子函数中的虚函数与父函数一模一样的时候（包括限定符）才会被认为是真正的虚函数，不然的话就只能是重载。这被称为虚函数定义的同名覆盖原则，意思是只有名称完全一样时才能完成虚函数的定义。 纯虚函数 虚函数的定义形式：virtual &#123;method body&#125; 纯虚函数的定义形式：virtual &#123; &#125; = 0; 在虚函数和纯虚函数的定义中不能有 static 标识符，原因很简单，被 static 修饰的函数在编译时候要求前期 bind，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。 虚函数可以被直接使用，也可以被子类重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。 虚函数和纯虚函数通常存在于抽象基类中，被继承的子类重载，目的是提供一个统一的接口。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。 如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。 抽象类的子类也可以是抽象类。 模板编程 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 函数模板 类模板 C++ 标准库STL 容器STL 的 sort 函数 对于STL中的sort()算法： 当数据量大时，将会采用 Quick Sort（快排），分段递归进行排序。 一旦分段后的数据量小于某个阈值，为了避免快排的递归带来过大的额外的开销，sort()算法就自动改为 Insertion Sort（插入排序）。 如果递归的层次过深，还会改用 Heap Sort（堆排序）。 简单来说，sort并非只是普通的快速排序，除了对普通的快排进行优化，它还结合了插入排序和堆排序。 根据不同的数量级以及不同的情况，能够自动选择合适的排序算法。 仿函数迭代器适配器C++ 11auto 关键字 auto 可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。 auto 的自动类型推断发生在编译期，所以使用 auto 并不会造成程序运行时效率的降低。 auto 声明的变量必须要初始化，否则编译器不能判断变量的类型。 auto 不能被声明为返回值，不能作为形参，不能被修饰为模板参数。 定义在一个 auto 序列的变量必须始终推导成同一类型。 使用 auto 关键字做类型自动推导时，依次施加以下规则： 如果初始化表达式是引用，则去除引用语义。 如果初始化表达式为 const 或 volatile（或者两者兼有），则除去 const / volatile 语义。 如果 auto 关键字带上 &amp; 号，则不去除 const 语意。 初始化表达式为数组时，auto 关键字推导类型为指针。 若表达式为数组且 auto 带上 &amp;，则推导类型为数组类型。 智能指针 四个智能指针: auto_ptr、unique_ptr、shared_ptr、weak_ptr。 包含在头文件 &lt;memory&gt; 中 使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。 所有智能指针都重载了 operator-&gt; 操作符，直接返回对象的引用，用以操作对象。 auto_ptr C++98的方案，C++11 已经抛弃。 采用所有权模式。 operator= 会剥夺先前对象的内存管理所有权。 release() 函数不会释放对象，仅仅归还所有权。 缺点是存在潜在的内存崩溃问题。 unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。 对于避免资源泄露特别有用。 当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。 可以通过 move() 函数转让所有权。 可以通过 release() 函数释放所有权。 shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象。 使用引用计数来表明资源被几个指针共享，每一个 shared_ptr 的拷贝都指向相同的内存。 每使用它一次，内部的引用计数加 1，每析构一次，内部的引用计数减 1。 该对象和其相关资源会在“最后一个引用被销毁”时候释放。 可以通过成员函数 use_count() 来查看资源的所有者个数。 可以指定类型，传入指针通过构造函数初始化。也可以使用 make_shared() 函数初始化。 不能将指针直接赋值给一个智能指针，一个是类，一个是指针。 注意不要用一个原始指针初始化多个 shared_ptr，否则会造成二次释放同一内存。 share_ptr 智能指针还是有内存泄露的情况，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。 share_ptr的简单实现 作者：code_peak链接： weak_ptr 为了配合 shared_ptr 而引入的一种智能指针，因为它不具有普通指针的行为，没有重载 * 和 -&gt;,它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况。 weak_ptr 可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造，获得资源的观测权。 weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加。 weak_ptr 可以通过调用 lock 函数来获得 shared_ptr。 weak_ptr的简单实现 作者：code_peak链接： 右值引用 左值和右值 左值：英文简写为 lvalue，是 loactor value 的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据。 右值：英文简写为 rvalue，是 read value 的缩写，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。 判断某个表达式是左值还是右值的方法。 可位于赋值号左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。 C++98/03 标准中的引用使用 “&amp;” 表示，正常情况下只能引用左值，无法对右值添加引用。因此这种引用方式也称为左值引用。 注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值。 C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。 和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。 和常量左值引用不同的是，右值引用还可以对右值进行修改。 C++ 语法上是支持定义常量右值引用的，但这种定义出来的右值引用并无实际用处。 移动语义 我们一般在使用函数管理含有资源的类的时候，一般都需要实现拷贝构造函数和拷贝赋值函数，因为默认的拷贝是浅拷贝，而指针这种资源不能共享，不然会因为指向同一个区域，一个析构了另一个也不能使用。 当我们将一个右值（比如一个字符串）作为函数参数传入时，本来就已经需要构造这个右值了，传进去之后却又要拷贝一遍，并且这个右值只是一个临时对象，拷贝完也没有什么用了，这就造成了很多不必要的资源申请和释放。 实现移动语义需要增加两个函数：移动构造函数和移动赋值构造函数。 移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是常量左值引用，而移动构造的参数是右值引用。 移动构造函数并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为空。 有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11 为了解决这个问题，提供了std::move() 方法来将左值转换为右值，从而方便应用移动语义。 通用引用 当右值引用和模板结合的时候，T&amp;&amp; 并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。 它是左值引用还是右值引用却决于它的初始化，如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用。 引用折叠 所有的右值引用叠加到右值引用上仍然使一个右值引用。 所有的其他引用类型之间的叠加都将变成左值引用。 完美转发 所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。 c++ 中提供了一个 std::forward() 模板函数将拥有名字的右值依然保持为右值。 配合上面提到的通用引用，我们可以将左值引用、常量左值引用、右值引用、常量右值引用都保持原样转发给另一个函数，也即实现完美转发。 右值引用例子及理解  列表初始化Lambda 表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。 一般形式：[capture](parameters) -&gt; return-type &#123;body&#125; [capture] 可能值 "},{"title":"Leetcode 297.二叉树的序列化与反序列化","date":"2021-08-05T18:38:00.000Z","url":"/2021/08/06/Leetcode%20297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 树中结点数在范围 $[0, 10^4]$ 内 -1000 &lt;= Node.val &lt;= 1000 链接： 题目分析&emsp;&emsp;按照题目要求，我们应该是采用一种遍历方法将二叉树序列化成一个字符串进行保存，而反序列化则是将字符串重新解码构造成原来的二叉树。二叉树的遍历方法有很多种，例如前序遍历、中序遍历、后序遍历、层序遍历。观察到题目中所给的示例就是使用层序遍历进行编码的，则我也采用同样的遍历方式。&emsp;&emsp;层序遍历需要维护一个队列，保存需要遍历子树的结点。我们在序列化的时候需要考虑到反序列化的时候如何拆分序列成为单个结点，观察到结点不会超过 4 位数，且带有正负，则每个结点都可以用不多于 5 位表示，我们可以规定每 5 个位为一个结点，这是一种表示方法。而考虑到实际上大部分结点都不需要 5 位，并且 C++ 中也含有一些字符串与整型互相转化的函数，则我们可以使用 , 进行结点划分，反序列化的时候再通过 , 拆分并使用已有的转化函数应该更为方便。而空结点我们这里使用 # 进行表示。对于每个非空结点，我们都需要遍历其左右子树，这样在反序列化的时候才能够根据层序遍历顺序得到原二叉树。下面是序列化函数。整型转字符串使用的是 to_string() 函数。 &emsp;&emsp;通过上面的序列化，我们得到以 , 分割的二叉树层序遍历串。进行反序列化时，我们首先要对字符串进行拆分。这里采用的是队列进行存储，使用一个字符串 str 进行记录，按字符遍历，每次遇到分隔符就拆分出一个结点。&emsp;&emsp;拆分完毕后，我们先对根结点进行判断，如果为空直接返回空指针，反之则创建根结点，作为返回结果。我们同样创建一个层序遍历的结点处理队列，同时我们使用一个布尔变量 left 来标记当前处理的是左孩子还是右孩子（这是由于进行连接的时候不能由空结点直接 new，而是需要先 new 完再进行连接，所以当前处理的是队首的左右孩子，而不是队首本身），遇到非空结点连接好之后就将其加入待处理队列中。队首的左右孩子都处理完毕之后才将队首弹出。&emsp;&emsp;这里将字符串转化为整型用到的函数是 int atoi(const char *str)，这个函数是 C 语言的函数，参数是 const char*，C 语言没有 string 类型，因此还得使用一个 const char *c_str() 函数进行转换。而 string 类型的比较函数是 compare(const string&amp; str)。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们在序列化与反序列化的过程都是对二叉树进行了一次层序遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们在序列化与反序列化的时候都需要维护一个队列，队列长度不会超过结点数，并且在反序列化时还使用了另一个队列对序列进行拆分，大小为 $n$。"},{"title":"Leetcode 287.寻找重复数","date":"2021-08-05T16:37:00.000Z","url":"/2021/08/06/Leetcode%20287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。 进阶： 如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= n &lt;= 10^5$ $nums.length == n + 1$ $1 &lt;= nums[i] &lt;= n$ nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 链接： 题目分析&emsp;&emsp;使用抽屉原理就可以证明进阶要求的第一问，不再赘述。&emsp;&emsp;题目要求不能修改原数组，且只能用常量级的空间，那么排序做法、哈希做法都是不能用的。由于没有仔细看提示（只研究了一下 1 到 n 的和会不会超过 int 上限），并且给出的示例也不够好，以为重复的那个数出现了两次，那么其他数就刚好都出现一次，直接使用数组总和减去 1 到 n 的和，打码测试示例提交一气呵成，以为秒杀却非常悲惨地收到一个 WA。&emsp;&emsp;这下明白了，重复的数字是可以出现多次的，也即是说，其他数字也可以不出现，这下就比较难用到 1 到 n 的一些性质了。我们通过一个萝卜一个坑的原理思考一下可行性，如果使用 nums[i] 与 i 之间的映射会出现什么情况呢？我们把它们的这种联系视为链表，则重复的那个数字下标，会出现多个指针指向它的情况。我们从下标 0 出发，则如果数字不重复，通过这个映射，我们会得到一条链，而直到重复数字出现，重新指向了之前指向的下标，也就是形成了环。&emsp;&emsp;注意这里有个很重要的一点，不重复的数字之间通过映射也是可能形成一个首尾相连的环的，但是这些数字不含 0，因此从下标 0 出发一定不会得到首尾相连的环，那么成环的那个就一定是重复的数字了。而且这样的映射数组里的数字不会超过 n，这说明肯定不会形成一条链，那么我们从 0 出发肯定能找到答案。答案就是从 0 出发的链表中环的入口，这样这道题已经转化成了我们做过的一道题 Leetcode 142.环形链表 II。这道题的最佳算法是使用快慢指针，时间复杂度就是 $O(n)$，符合进阶要求。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。形成的链表大小不会超过 $n$，而找到一条长度为 $n$ 的链表的环入口时间复杂度是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只是通过映射把原数组视为链表，实际上只需要通过两个变量充当指针的角色在数组中迭代，并没有真正建立链表，需要的空间是常数级的。 &emsp;&emsp;PS：官方题解中还有两种 $O(n\\log n)$ 的做法，都是通过 1 到 n 的性质寻找的，分别是记录小于等于 i 的数字个数和使用二进制求出重复数的每一位。成功解决了重复数为多个时带来的影响，还是有借鉴意义的。"},{"title":"Leetcode 283.移动零","date":"2021-08-05T15:57:00.000Z","url":"/2021/08/05/Leetcode%20283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/","tags":[["C++","/tags/C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 链接： 题目分析&emsp;&emsp;我们可以使用一个数 zero 来记录 0 的个数，则可以根据这个数算出非 0 数应该移动到的位置，全部处理完之后将后面 zero 个数全部置为 0 就可以。因为题目说尽量减少操作次数，因此我们增加了两条判断（第 9 行和第 14 行），如果是无需改变的就保持不动，而不是用原数字覆盖。&emsp;&emsp;写完了之后发现我们也可以记录非零数的个数，甚至都用不到减法，我真傻，真的。然后看了官方题解，使用的是双指针的做法，都知道后面全为 0 了还交换啥呢，直接覆盖最后再补 0 操作次数更少才对。然后好像别人写的是没有增加这两条判断的，我不管，我就是要满足操作次数最少！ &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。每个位置最多被遍历两次（扫描一次，覆盖一次）。&emsp;&emsp;空间复杂度：$O(1)$。原地算法，只需要常数个变量的空间。"},{"title":"Leetcode 279.完全平方数","date":"2021-08-05T14:02:00.000Z","url":"/2021/08/05/Leetcode%20279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 示例 2： 提示： $1 &lt;= n &lt;= 10^4$ 链接： 题目分析1.动态规划&emsp;&emsp;看到这道题的时候，第一感觉就是动态规划，思考一下其中的过程。对于一个数 $n$，我们将其表示成一个完全平方数 $i^2$ 和另一个数的和，这个问题就转化了成了另一个更小的数 $n-i^2$ 的问题。那么我们令 $f(n)$ 是和为 $n$ 的完全平方数的最少数量，我们要找的是使得 $f(n-i^2)$ 最小的那个 $i$，则有以下动态规划转移方程 $\\displaystyle f(n) = 1 + \\min^{\\lfloor\\sqrt{n}\\rfloor}_{i}(f(n-i^2))$。特别的，我们令 $f(0)=0$，这样一个完全平方数就刚好能用本身表示。而状态转移是需要用到更小的状态，则我们从小到大进行动态规划即可。 &emsp;&emsp;时间复杂度：$O(n\\sqrt{n})$，其中 $n$ 是正整数的大小。我们进行了从 1 到 $n$ 的动态规划，而每次规划需要计算 $\\lfloor\\sqrt{n}\\rfloor$ 个状态中的最小值。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是正整数的大小。也即存储动态规划状态的数组大小。 2.数学方法 - 官方题解&emsp;&emsp;做出了上面那种动态规划的方法后，总是觉得状态转移需要 $\\sqrt{n}$ 个状态有点多，以为有更好的动态规划，没想到那样就是动态规划的解法了。而更好的解法是使用数学定理的，这个实在是知识盲区。&emsp;&emsp;这里使用到的数学定理是 四平方和定理。这个定理说，每个正整数均可表示为 4 个整数的平方和。也就是说，这道题的答案不会超过 4。同时四平方和定理包含了一个更强的结论：当且仅当 $n\\neq4^k\\times(8m+7)$ 时，$n$ 可以被表示为至多三个正整数的平方和。也就是说，当 $n=4^k\\times(8m+7)$ 时，答案一定是 4。而对于剩下的数，还剩下 3 种可能。如果答案是 1，也即该数本身就是完全平方数，容易判断。如果答案是 2，则 $n$ 可以表示成两个完全平方数的和，则我们枚举不大于 $\\sqrt{\\frac{n}{2}}$ 的平方，并判断减去之后另一个数是不是也是完全平方数就可以了。而剩下的数答案就是 3。&emsp;&emsp;这里对官方题解做了一点点修改，官方题解枚举答案 2 的时候是枚举到了 $\\sqrt{n}$，其实到了一半就可以了。并且在看官方题解的时候，注意到了求平方根函数 sqrt 的时间复杂度是 $O(1)$，有点不解，去了解了一下算法原理，看完神清气爽，不得不感叹前人的智慧。这里附上链接 sqrt方法复杂度探讨。 &emsp;&emsp;时间复杂度：$O(\\sqrt{n})$，其中 $n$ 为给定的正整数。最坏情况下答案为 3，我们需要运行所有的判断，而判断答案是否为 1 的时间复杂度为 $O(1)$，判断答案是否为 4 的时间复杂度为 $O(\\log n)$，判断为 2 的时间复杂度为 $O(\\sqrt{n})$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。 3.贪心法 - 官方题解评论区&emsp;&emsp;在看官方题解的评论的时候，还看到一种贪心的方法。通过上面的分析我们也知道，这道题的答案是不会超过 4 的，所以其实使用贪心的思路不会比正向动态规划慢。贪心的思路就是贪心地认为是 1 个完全平方数的和，不行再判断是不是 2 个完全平方数的和，不行再判断是不是 3 个完全平方数的和，以此类推直到找到答案。&emsp;&emsp;这样做的好处是减少了很多对结果没有用的状态，相当于从结果倒推需要的状态，类似于 DFS 的思想去搜索，在这道题应该是蛮快的。这里附上评论区大佬的 python 代码。这份代码还可以优化，p 循环不需要 ps 里面的所有数，大于 n/2 之后就可以停止了。 "},{"title":"Leetcode 240.搜索二维矩阵 II","date":"2021-08-04T15:10:00.000Z","url":"/2021/08/04/Leetcode%20240.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 示例 2： 提示： $m == matrix.length$ $n == matrix[i].length$ $1 &lt;= n, m &lt;= 300$ $-10^9 &lt;= matix[i][j] &lt;= 10^9$ 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 $-10^9 &lt;= target &lt;= 10^9$ 链接： 题目分析&emsp;&emsp;因为矩阵是相对有序的，对于一个节点，若 target 比它小，则只能在左边或者上边；若 target 比它大，则只能在右边或者下边。这样搜索路径有两条不好选择。如果我们从左下角开始搜索，若 target 小则只能往上边搜索，若 target 大则只能往右边搜索，我们只规定两个合法的移动方向，由于严格的大小关系，若 target 存在是一定不会错过的。同理，从右上角往左下角搜索也是可以的。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别为二维矩阵的行数和列数。我们的搜索方向只有右和上，最多只能走过 $m+n-1$ 步到达右上角。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要根据搜索得到的大小进行移动，只需要常数个变量的空间。 &emsp;&emsp;PS：官方题解中还有二分法等高端操作，非常复杂，时间复杂度也没有比这个好，就没有进行学习，这种方法还是十分巧妙和简洁的。"},{"title":"Leetcode 239.滑动窗口最大值","date":"2021-08-04T14:14:00.000Z","url":"/2021/08/04/Leetcode%20239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/","tags":[["C++","/tags/C/"],["队列","/tags/%E9%98%9F%E5%88%97/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= nums.length &lt;= 10^5$ $-10^4 &lt;= nums[i] &lt;= 10^4$ $1 &lt;= k &lt;= nums.length$ 链接： 题目分析&emsp;&emsp;我们要获取滑动窗口中的最大值，可以维护一个队列记录当前在滑动窗口中的数字，移动的时候往队列右边添加数字，在队列左边删除数字就好了。但是如何快速地获取队列中最大的元素呢？我们考虑下标为 i 和 j 并且满足 i 在 j 的左边（也即有 i&lt;j）这样两个元素，则当 i 还在滑动窗口中时，j 也一定在滑动窗口中。当 j 的值不小于 i 的时候 i 不影响滑动窗口中的最大值，那么我们就可以把 i 从队列中删去了。那么最后我们只需要维护一个单调递减的队列。&emsp;&emsp;每次从右边添加新数字的时候，删去右边所有比新数字更小的数，并把新数字加在右边中，仍然保持单调队列。然后我们检查队列的左边元素是否已经移出窗口，如果已经移出窗口则将其删去。这个时候，滑动窗口中的最大值其实就是队列最左边的元素（也即队列中最大的元素），这样我们便可以直接得到滑动窗口中的最大值。&emsp;&emsp;从上面的分析中我们也可以发现，我们需要能够从队列左边或者右边增删数字，则需要用到双端队列 deque，而且判断队列左边是否需要删去的时候，我们需要判断下标，因此我们保存到队列中的信息是数组下标，而不是数字本身。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们在进行窗口滑动并维护队列的过程相当于对数组进行了一次遍历。而每个数也最多进出队列一次。&emsp;&emsp;空间复杂度：$O(k)$，其中 $k$ 是滑动窗口的大小。主要的空间开销就是队列的开销，而队列的大小不会超过滑动窗口的大小。"},{"title":"计算机网络 知识总结","date":"2021-07-30T15:14:00.000Z","url":"/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;关于 计算机网络 知识体系的总结。 概述计算机网络 计算机网络 —— 自主计算机的互连集合 网络分类 直连网 点到点网络 单工（simplex）：如有线电视 半双工（half duplex）：如对讲机 全双工（full duplex）：如电话 多路访问网络（共享介质、可能存在碰撞） 单播、多播、广播 间接连网：用路由器（或网关）连接起来构成的网络，也称网络互连 系统域网、局域网、城域网、广域网 因特网 多层 ISP（因特网服务提供商）结构，由终端、路由器、通信链路组成 网络服务 可靠/不可靠：如 TCP/UDP 面向连接/无连接：如电话/邮件 有确认/无确认：如挂号信/数据报 网络分层 上层服务可以使用下层服务提供的协议 因特网模型（4层） 物理网络层 物理层 bitstream 字节流 数据链路层 PPP Ethernet （节点 node / 跳 hop）数据帧 网络层 IP 路由协议 （主机 host） 数据报 传输层 TCP UDP （端 end） 数据段 应用层 FTP SMTP HTTP 消息 ISO/OSI 参考模型（7层） 物理层：传输原始比特流 数据链路层：在物理网路中传送数据包 网络层：通过路由选择连接各种网络 传输层：用于进程之间的数据传送 会话层：提供会话式的数据传送服务 表示层：提供数据转换服务 应用层：为专门应用提供服务 网络性能分析 包交换技术 延迟 处理延迟：检查比特错，确定输出链路 排队延迟：在输出链路队列等待发送 传输延迟：包长（bits）/ 链路带宽（bps） 传播延迟：物理链路长度 / 信号传播速度 丢失 带宽：一条链路或通道可达到的最大数据传输速率 吞吐量：一条链路或通道的实际数据传输速率 物理层 载波信号一般采用正弦波信号 编码方式 FSK 频移键控、ASK 幅移键控、PSK 相移键控、QAM 正交调幅 单极编码 双极编码 不归零编码 NRZ（有时钟漂移、基线漂移） 不归零反转编码 NRZI（有时钟漂移、基线漂移） 曼切斯特编码（克服时钟漂移、基线漂移）（以太网） 0 变为 01、1 变为 10 差分曼切斯特编码（克服时钟漂移、基线漂移） 0 起始跳变、1 起始不跳变、中间一定跳变 4B / 5B 编码：使用 5 比特表示 4 比特，不会多于 1 个前导零和多于 2 个末端零。可以结合 NRZI，不会有过多跳变同时克服时钟漂移、基线漂移。 物理介质 有线介质 双绞线 同轴电缆 光纤（利用了光的全反射） 单模光纤：速率高、距离长 多模光纤 阶跃光纤：速率低、距离短 渐变光纤：速率中、距离中 无线介质 —— 大气：如地面微波、wifi、3/4/5G、卫星 多路复用技术 电路交换技术：时分多路复用、频分多路复用、波分多路复用、码分多路复用 包交换技术：统计多路复用 数据链路层概述 只涉及一个直连网 主要功能：形成帧、差错检测、差错控制、介质访问控制 差错：丢失、重复、错序、溢出、比特错，碰撞（多路访问） 纠错码：海明码、二维奇偶检验码 校验码： 奇偶校验码 二维奇偶校验码（可以纠正 1 位比特错） 校验和 循环冗余校验码 CRC（容易用硬件实现、速度快、检错率高） 可靠数据传输：确认帧、超时定时器（自动重发请求 ARQ） 停等协议 滑动窗口协议 PPP 协议 停等协议 确认帧（ACK）表示序号为 ACK 以及之前的数据帧以及全部收到并已交给上层协议。 只有收到前一个数据帧的确认才可以发送下一个数据帧。 滑动窗口协议 发送窗口：连续发送数据帧的可用序号范围，主要用于流控制。 发送窗口大小：表示发送窗口的大小，也是发送缓冲区的大小。 回退 N 协议 出现超时的时候将重传所有已发送且未收到确认的帧。 选择性重传 否定性确认帧（NAK）表示在这一帧之前的数据帧全部收到并已交给上层协议，要求发送方重传这一帧。每个帧只发送一次 NAK。 接收窗口：用于确定应该保存那些帧，用序号范围表示。 接收窗口大小：表示接收窗口的大小，也是接收缓冲区的大小。 提高滑动窗口协议效率 选择性确认：接收方把已收到的帧序号告诉发送方。当发送方要重传的时候不会发送这些帧。 延迟确认：接收方收到一帧后并不立即发送确认帧，而是等待一段时间再发送。 捎带确认：通信双方采用全双工的方式工作，接收方在发数据时顺便把确认号也告诉对方。 PPP 协议 PPP 协议是点到点网络的数据链路层协议。 PPP 协议是根据 HDLC（高级数据链路控制）协议进行设计的，主要用于串行电缆、电话线等各种串行链路。 PPP 协议可以提供连接认证、传输加密和压缩功能。 PPP 协议可以为各种网络层协议提供服务。 PPP 协议的多链路捆绑技术可以通过将通信两端之间的多条通信链路捆绑成一条虚拟的链路而达到扩充链路可用带宽的目的。 PPP 协议没有纠错、流控制、确保有序功能。 介质访问控制子层概述 多路访问网络采用共享介质连接所有站点，发送站点通过广播方式发送数据并占用整个共享介质的带宽。由于每个站点只需要一条线接入网络就可以访问所有站点，所以安装简单并且价格便宜，局域网一般都采用这种链路。 数据链路层 介质访问控制子层（MAC 子层）：控制和协调所有站点对共享介质的访问，避免或减少冲突。 逻辑链路控制子层（LLC 子层）：为上层协议提供服务 LLC 1：提供无确认无连接服务 LLC 2：提供有确认面向连接的服务 LLC 3：提供有确认无连接的服务 CSMA（载波监听多路访问） 1-persistent CSMA：信道空立即发送，信道忙持续监听。（以太网） non-persistent CSMA：信道空立即发送，信道忙延迟一段随机长度的时间。（最省电） p-persistent CSMA：信道空立即以概率p发送，以概率1-p延迟一个时间槽，信道忙延迟一个时间槽。 以太网 MAC 层协议 CSMA/CD（带冲突检测的载波监听多路访问） 发送数据帧之前先监听信道。如果空闲立即发送，如果忙持续监听直到空闲。 边发送边检测冲突。如果发送完毕都没有检测到冲突则发送成功。 如果发送时检测到冲突，则停止发送，在发送 32 位干扰位以加强冲突信号后采用二进制退避算法随机延迟一段时间，再重新监听。 接收帧的方式 以太网站点会缓存所有帧 如果缓存的帧有错则丢弃 对比目的地址，如果是需要接收的帧则接收（包括单播多播广播） 如果网卡设置是混杂模式则会接收所有无错的帧 最短帧问题 发送 96 bits 时间信道均空闲则认为信道空闲 最短帧 64 Bytes，也是争用窗口长度。为了使发送站点能检测到所有冲突。 物理层协议 传输方法：异步传输 编码方法：采用曼切斯特编码 冲突域：两个接口同时发送数据会产生冲突（集线器，半双工） 广播域：一个广播帧可以到达的所有接口（交换机，全双工，不同接口不同冲突域） 透明网桥 扩展局域网：用网桥连接若干局域网，形成一个更大的局域网。 原来的局域网成为该扩展局域网的一部分，称为一个网段。 MAC 地址表：目的 MAC 地址、转发端口、TTL。 过滤（filter）、转发（forward）、扩散（flood）。 自学习：将接收到的帧的原地址和接收端口记录到表中。 生成树协议 配置信息 BPDU（当前根BID，到根距离、发送BID、发送端口） 网桥ID BID（优先权、网桥的 MAC 地址） 端口ID PID（优先权、序号） 根端口：网桥上离根最近的端口 指定网桥：网段上离根最近的网桥（最近路径有多条选最小 BID） 指定端口：指定网桥上与网桥连接的端口 阻塞端口：网桥上既非根端口又非指定端口 虚拟局域网 网桥只在具有相同 VLAN ID 的端口之间转发帧，把原来的局域网分割成多个相互隔离的局域网，称为虚拟局域网。 默认 VLAN 为 VLAN 1 一个 VLAN 的帧只能转发到属于同一个 VLAN 端口或者干道端口，只有发往干道端口的帧才需要加上 VLAN ID。 交换机 交换机：一个把多个网段连接起来的设备，也称为多端口网桥。 交换机结构： 共享总线式交换机 纵横式交换机：可以实现多路并行传输 转发方法： 存储转发：交换机接收整个帧之后转发它。 直通：交换机不用收到整个帧而是收到帧的硬件地址后立即转发它。 无碎片：交换机不用收到整个帧而是收到帧的前64个字节后立即转发它。 适应性交换：自动在上面三种方式进行选择。 全双工模式：交换机可以在全双工模式下工作，没有冲突，不需要 CSMA/CD 算法。 令牌环网 令牌环网：一个通过在站点之间传递令牌防止冲突并且具有优先权的星形 LAN。 数据传送过程： 令牌绕环而行 只有截获令牌的站点才可以发送数据帧 发送的数据帧通过所有的活动站点 目的站点拷贝数据帧 只有发送方移除数据帧 当没有数据帧要发送或者持有时间到时需要释放令牌，继续绕环而行。 具有 ACK 标志（是否见到） 具有 Copy 标志（是否收到） 具有监控站（超时产生新的令牌帧） 具有选举帧（监控站失效时重新进行选举） 无主帧（数据传递出错，找不到源站点，第 2 次收到则进行丢弃） 网络层概述 网络层协议负责确定把收到的包从哪条路径转发出去，即路由选择功能。 交换技术 电路交换：通过在网络中连接多条物理电路形成一条通路后传送数据。 包交换：采用统计多路复用的方法通过网络传送数据包。 虚电路：先建立连接再传送数据包。 交换式虚电路：每次传送数据前建立连接，传送完释放连接。 永久虚电路：由管理员建好后一直保持，随时可以传送数据。 数据报：根据数据包的目的地址直接转发数据包。（因特网） IP 协议（因特网的网络层协议） 可路由的（routable）：全局地址，按层分配。 尽力服务：无连接无确认的数据报服务。 可以运行在任何网络上。 IP 数据报IP 数据报的格式 版本号：4（IPv4）或 6（IPv6）。 头部长度：以字（32-bits）为单位。 服务类型：优先权(3)、低延迟(1)、高吞吐量(1)、高可靠性(1)、花钱最少(1)、保留位(1)。 总长度：数据报的长度，以字节为单位。 标识、标志、偏移量：用于划分片段。 生存期：记载经过的路由器数（跳数）。 一般初值设置为网络直径的两倍，Win 8 和 Linux 默认 64，UNIX 默认 255。 TTL 减到 0 仍未到达目的地则进行丢弃，并发出一个 ICMP 包告知源主机。 协议：6（TCP）、17（UDP）、1（ICMP）、2（IGMP）。 头部校验和：路由器会丢弃出错的数据报。 IP 数据报的分段和重组 最大传输单元（MTU）是该网络可以运载的最大有效载荷，即数据帧的数据部分的最大长度。 以太网的 MTU 为 1500，FDDI 为 4353，令牌环网 为 4482 如果一个数据报的长度大于 MTU，则需要进行分段。 源主机每次发 IP 数据报都会把标识字段加 1。 分段时标识保持不变，并且用偏移量字段指出该片段的数据部分相对原来的偏移量。 标志位中有 DF 字段和 MF 字段。 DF = 1 表示不可分段。 MF = 1 表示后面还有片段。 当目的主机收到该数据报的所有片段时会进行重组。 当第一个片段到达时就会启动重组定时器（默认15秒）。 若重组定时器到期仍没有完成重组则会放弃重组并丢弃该数据报的所有片段。 IP 数据报的选项 一般格式：代码（1）、总长度（1）、数据（n） 代码 0：选项列表结束。 代码 1：无操作。 代码 7：记录每个转发路由器的 IP 地址。 代码 20：IP 警报器，告知路由器需要特殊处理的选项。 代码 50：记录时间戳，每个转发的路由器都要记录 IP 地址和转发时间。 代码 131：松散源路由，指明一系列必须经过的路由器。 代码 137：严格源路由，指明一系列必须且只能经过的路由器。 IP 地址IP 地址空间 MAC 地址（48位）和 IP 地址（32 位）均是全局分配，但是 IP 地址是分层的，可路由的。 IP 地址由 ICANN 统一负责并逐级分配。亚洲由 APNIC 负责，中国由 CNNIC 负责。 IP 地址属于接口（网卡）。主机或路由器的每个接口可以配置一个或多个 IP 地址。 IP 地址结构 一个 IP 地址划分为两个部分：网络号和主机号。 网络号也称网络前缀、网络标识，确定拥有该 IP 地址的主机位于哪个网络。 主机号用于确定 IP 地址属于该网络下的哪台主机。 有类网 A 类：0.0.0.0 ~ 127.255.255.255，主机号 24 位 B 类：128.0.0.0 ~ 191.255.255.255，主机号 16 位 C 类：192.0.0.0 ~ 223.255.255.255，主机号 8 位 D 类：224.0.0.0 ~ 239.255.255.255，多播地址 E 类：240.0.0.0 ~ 255.255.255.255，保留网 子网划分 一个有类网可以通过子网掩码划分为多个相同大小的子网。 主机号为全 1 和全 0 的地址被保留，不能使用。 子网号为全 0 或全 1 的子网可以使用（以前不能）。 变长子网掩码（VLSM）允许把一个有类网划分为多个不同大小的子网。 无类域间路由选择协议（CIDR）允许把多个有类网合并为一个更大的网络，称为超网。 特殊的 IP 地址 全 0：未知或私密 IP 地址，只用作源地址。 全 0 + host：同一子网的主机，只用作源地址。 全 1：有限广播，对于一个直连物理网的广播。 network + 全 1：对于一个远程网络的广播。 network + 全 0：用 32 比特表示的网络号（含子网号）。 01111111 + 任意值：环回地址，如 127.0.0.1 表示本机地址。 私有 IP 地址 无需 IANA 分配，任何人都可以使用的 IP 地址。 只能用于内部网络。主干网上的路由器会过滤掉目的地址为私有地址的 IP 数据报。 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 网络地址转换 网络地址转换（NAT）是一种把内部地址映射为外部地址的技术。 动态 NAT：出口路由器在内网数据报发往外网时自动映射。关联 TTL，超时会删除。 静态 NAT：直接由管理员加入的映射方法。不会被自动删除。 NAPT 把端口号也加入到映射中，也称为 PAT 或过载 NAT。 ARP 协议 地址解析协议（ARP）可以把 IP 地址映射为 MAC 地址。 没有超时重传机制。超时没有收到响应则丢弃引发 ARP 查询的 IP 分组。 源主机获得的映射结果缓存在 ARP 表中，并设有 TTL。 当收到 ARP 请求，目的主机会缓存源主机的映射，其他监听到的主机如果已缓存则会更新 TTL。 也可以直接将映射加入到 ARP 缓存中，称为静态 ARP 映射，没有 TLL。 DHCP 协议 动态主机配置协议（DHCP）用于主机在加入网络时动态租用 IP 地址。 关于DHCP协议的详细信息  ICMP 协议 因特网控制消息协议（ICMP）用于主机或路由器发布网络级别的控制消息。 ICMP 常见的消息类型： 不可达消息：网络不可达、主机不可达、协议不可达、端口不可达、分段错误、源路由错误。 回响请求和响应：从回响（echo）请求收到的标识符、序号和数据拷贝到回响答复中。 时间超时消息：代码 0 表示 TTL 减为 0，代码 1 表示重组 IP 片段超时。 重定位消息：当路由器发现转发消息的接收接口和转发接口相同时会发送 ICMP 消息给主机，要求主机将发往目的主机的数据报直接发送。 路由协议概述 路由表（也称为转发表） 目的网络号、下一跳、接口。 如果目的网络为直连网络则下一跳为空。 有类网的 IP 路由选择 利用数据包中的目的地址得到目的网络号，然后查询路由表。 如果查询的结果为直连网，则直接把数据包从查出的接口转发到目的主机。 否则，如果查询得到下一跳，则把数据包转发给下一跳。 如果没有任何匹配项则把数据包转发给默认路由器。 如果没有设置默认路由器则丢弃该数据包。 无类网的 IP 路由选择 匹配方法：目的 IP 地址和子网掩码匹配子网号。 最长匹配原则：当有多条路由都匹配时选择子网掩码最长的路由。 路由协议 路由器在收到一个数据报之后用其目的地址查找路由表得到下一跳，再把该数据报转发给下一跳。 路由表可以由管理员手工建立，称为静态路由，默认路由和直连路由都是静态路由。 路由表也可以由路由协议自动建立，称为动态路由。 自治系统 自治系统（AS）：在同一个机构管理下的网络，决定采用的协议和网络控制政策。 用于 AS 内的协议称为内部网关协议（IGP）。如 RIP 协议、OSPF 协议。 用于 AS 之间的协议称为外部网关协议（EGP）。如 BGP 协议。 运行同一个 IGP 协议的连通区域也称为路由选择域。 路由算法：找最短路径的算法 通过链路状态：OSPF 协议 通过距离向量：RIP 协议 RIP 协议 距离向量算法 每个结点周期性地发送自己距离向量估计给邻居。 当一个结点收到来自邻居的新的距离向量估计，它将据此更新自己的距离向量。 在自然条件下，距离向量会收敛到实际的最短路径开销。 路由信息协议（RIP）：采用邻居的路由表构造自己的路由表。 路由表中到目的网络的距离以跳为单位。最大距离 15。距离 16 表示不可达。 初始时每个 RIP 路由只有到直连网的路由，距离为 1。 每 30 秒 RIP 路由把它的整个路由表发送给邻居。 当收到邻居发来的路由表，路由器将更新它的路由表。 收到的路由距离全部加 1（一跳的距离）。 把路由表中不存在的路由加入路由表。 如果比路由表中的路由距离更小，则更新该路由距离，并把下一跳修改为邻居。 如果路由已存在并且下一跳就是邻居，则必须进行更新。 RIP 路由表的每一项都有 TTL，加入路由器时启动，更新时重置，超时则失效。 RIP 协议的问题 慢收敛问题 计数到无穷问题 RIP 协议的技术 水平分割技术：从一个接口学来的路由不会从该接口发回去。 毒性反转技术：从一个接口学来的路由会把距离改为无穷大后从该接口发回去。 抑制技术：距离被改为无穷大的路由在一段短时间（180 秒）内其距离不允许被修改。 触发更新：一旦出现路由变化将立刻把变化的路由发送给邻居。 RIP 协议的定时器 更新定时器：控制一个路由器如何定期把路由表发送给邻居。默认 30 秒。 失效定时器：到期时被标记为无效路由。默认 180 秒。 清除定时器：到期时该路由将从路由表中删除。默认 240 秒。 抑制定制器：在路由距离变为无穷大时启动，到期前不许改动。默认 180 秒。 RIPv1 数据包 只能在有类网使用。使用 UDP 数据报封装，端口号 520，采用广播方式发送给邻居。 RIPv2 数据包 支持无类网。可以采用广播或多播的方式发送给邻居。 特点 协议简单、容易实现。 网络直接不能超过 16 跳。 不允许把一个大网络分成多个区。 开销缺乏灵活性。 每 30 秒发送完整路由表会消耗大量带宽。 直连网的管理距离为 0，在 RIP 协议中的距离为 1。 OSPF 协议 链路状态路由算法 利用最短路径算法求出一个节点到所有其他节点的最短路径。 利用这些最短路径上的下一个节点作为下一跳得到源节点的路由表。 开放式最短路径优先协议（OSPF） 周期性地收集链路状态，并扩散出去。 利用收到的链路状态建立整个 AS 的拓扑结构图。 利用 Dijkstra 算法计算到 AS 中所有网络的最短路径。 利用这些路径上的下一跳建立路由表。 路由器 ID 使用直接配置的 RID。 所有活动环回接口中最大的 IP 地址。 所有活动物理接口中最大的 IP 地址。 除非路由器重启、所选接口故障或关闭或 IP 地址改变、重新执行了 router-id 命令，RID 将保持不变。 指定路由器 当多路访问网络重启时，选举 DR 的过程就开始了。在等待时间（40 秒）结束时，带有最高和次高优先权的路由器分别称为 DR 和 BDR。如果优先权相同，RID 更大的成为 DR，次大的成为 BDR。 如果路由器不希望参与选举，应该把优先权设置为 0。 如果一个新的路由器在选举之后到达或者有路由器修改为更高的优先权，它也不可能抢占现存的 DR 和 BDR。 当 DR 失效时，BDR 成为 DR，并开始一个新的选举过程选出 BDR。 一个多路访问网络中的 OSPF 路由器只与 DR 和 BDR 建立相邻关系。 收到一个 LSA 后，一个多路访问网络中的 OSPF 路由器将把它首先多播给 DR 和 BDR，然后 DR 再把它多播给所有的 OSPF 路由器。 特点 所有的 OSPF 消息都要认证（防止恶意入侵）。 路由表中允许多个相同开销的路径存在，可以实现负载均衡。 对于每条链路，允许同时有多个开销。 在大型路由选择域中 OSPF 可以分区。 OSPF 比 RIP 收敛快而且更安静。 OSPF 实现起来更复杂，需要更多的计算开销。 OSPF协议的详细描述 对于每个中转网，要选举一个直连路由器作为其指定路由器（DR）。 发现邻居：每 10 秒向邻居发送 Hello 分组。如果 40 秒都收不到邻居发来的 Hello 分组，则把到邻居的链路标记为失效。多路访问网络采用多播发送 Hello 分组。一个 Hello 分组包含优先权、已知的邻居、DR 和 BDR。 完全相邻：在发现邻居之后，OSPF 路由器与邻居交换链路状态数据库中的 LSA（链路状态通告），请求得到更新的或者没有的 LSA。在与邻居的链路状态数据库变得完全一样时，它们就处于完全相邻状态。 生成 LSA：每 30 分钟或者链路变化时，每个 OSPF 路由器会生成 router LSA，中转网的 DR 会生成 network LSA。 扩散 LSA：产生的 LSA 立即封装为 Update 分组，被可靠地扩散出去（需要确认）。每次产生的 LSA 序号会加 1。通过序号可以防止扩散形成回路。 收集 LSA：路由器收集到 LSA 后，用新 LSA 替换链路状态数据库中的旧 LSA。如果一个 LSA 在 60 分钟内没有被更新，它将从链路状态数据库中移除。 计算最短路径：当链路状态数据库被改变时，OSPF 路由器将利用 Dijkstra 算法计算到所有网络的最短路径。 建立路由表：利用得到的最近路径产生路由表。 BGP 协议 边界网关协议（BGP）采用可靠扩散的方法把 AS 内的网络信息传遍整个因特网。 在 AS 中，每个运行 BGP 协议的路由器被称为 BGP 路由器。 在 BGP 路由器之间可以通过 TCP 连接（端口号 179）建立相邻关系。 BGP 协议所扩散的网络号称为网络层可达信息（NLRI）。 BGP 路由器可以把 NLRI 连同它们的属性一起通过相邻关系扩散给邻居，进而扩散到因特网中所有的 BGP 路由器。 BGP 路由器在 NLRI 引入 BGP 协议时扩散一次，并不定时扩散。 BGP 分组类型 OPEN 报文：用于建立相邻关系。 KEEPALIVE 报文：用于判断邻居是否有效。 UPDATE 报文：用于扩散 NLRI。 NOTIFICATION 报文：用于报告错误。 传输层概述 传输层协议称为端到端或进程到进程的协议。 因特网的传输层可以为两个进程在不可靠的网络层上建立一条可靠的逻辑链路。 传输层可以提供字节流传输服务，并且可以进行流控制和拥塞控制。 UDP 协议：提供不可靠的尽力服务。 TCP 协议：提供可靠的字节流服务。 传输层的多路复用 发送方：收集来自上层进程的数据形成数据段并发送出去。 接收方：把收到的数据段交给正确的上层进程。 端口号 1 ~ 1023：知名端口号。如 HTTP-80、FTP Control-21、FTP Data-20，telnet-23、SMTP-25、POP3-110、DNS-53。 1024 ~ 49151：注册端口号。在 IANA 注册的专用端口号，为企业软件所用。 49152 ~ 65535：动态端口号。没有规定用途的端口号，一般用户可以随意使用，也称为私用或暂用端口号。 端口号只具有本地意义，即端口号只是标志本地计算机应用层的各进程。在因特网中，不同的计算机的相同端口号是没有联系的。 UDP 协议概述 用户数据报协议（UDP）只提供无连接的不可靠的尽力服务。 UDP 发送给接收进程的数据有可能丢失，也有可能错序。 UDP 分组的首部开销小，只有 8 个字节。 UDP 没有拥塞控制，网络中的拥塞控制也不会影响主机的发送速率。 UDP 接收进程每次接收一个完整的数据报，如果进程设置的接收缓冲区不够大，收到的数据报将被截断。 UDP 的校验和字段是可选的，全 0 时表示忽略校验和。 与 IP 数据报的区别 IP 数据报在网络层要经过路由的存储转发。 UDP 数据报是在传输层的端到端的逻辑信道中传输，而封装成 IP 数据报在网络传输中，UDP 数据报对于路由是不可见的。 关于UDP协议的详细描述  TCP 协议概述 传输控制协议（TCP）为进程之间提供面向连接的可靠的数据传送服务。 TCP 是全双工协议。 TCP 提供流控制机制，即控制发送方的发送速度，使发送的数据不会淹没接收方。 TCP 提供拥塞控制功能。 TCP 进程提供可靠的字节流服务，也即没有消息边界，多次发送的数据可以放在一个数据段中传送且不标识边界。 每个 TCP 连接可以由四元组唯一标识：源 IP 地址，源端口号，目的 IP 地址，目的端口号。 标志位（为 1 时有效） URG：本数据段包含紧急数据。 ACK：表示确认号有效。 PSH：发送方执行了推送操作，接收方需要尽快将所有缓存的数据交给接收进程。 RST：重置连接。因为连接出现了错误，通知对方立即中止连接并释放相关资源。 SYN：同步序号标志，用来发起一个 TCP 连接。 FIN：结束标志，向对方表示自己不再发送数据。 通知窗口大小：接收方告知发送方接收窗口的大小，发送方会据此修改发送窗口的大小。 选项 建立连接时：MSS（最大段长度）、窗口比例、是否使用选择性确认（SACK）。 默认 MSS：Unix - 536、Windows - 1460。 默认 SACK：Unix - False、Windows - True。 数据传送时：选择性确认的序号范围、时间戳等等。 三次握手和四次挥手 三次握手（非对称活动，只能由客户端向服务端发起）建立连接 客户端发送连接请求（SYN 报文，含服务器端口号）。 服务端收到后查看是否有进程监听该端口，如果没有则发送 RST 拒绝。如果有，则发出 SYN + ACK 包，表示确认连接，并发送服务端的连接请求。 客户端收到后发送 ACK 包表示确认连接。 服务器发送 SYN + ACK 包之后会把链接请求放入到进程的半连接队列中（SYN 队列），而收到客户端的 ACK 后变成全连接队列（accept 队列）。 如果半连接队列和全连接队列满，则后面到的连接请求会直接被丢弃。而客户端发送 ACK 之后就认为连接已经建立，在第一个数据段重传几次后才会中止连接。 SYN 泛洪攻击就是客户端恶意建立半连接队列，不发送 ACK 给服务端，这样服务端就会一直维护半连接队列，造成资源的浪费。 四次挥手（对称活动，可以由客户端或者服务端发起）关闭连接 主机 1 发送 FIN 报文表示不再发送数据，但可以接收数据，进入终止等待 1。 主机 2 发送 ACK 报文表示收到，主机 1 收到后进入终止等待 2。 主机 2 发送 FIN 报文表示不再发送数据，进入最后确认状态。 主机 1 发送 ACK 报文表示收到，在等待时间结束后关闭连接。 主机 2 收到 ACK 报文后关闭连接。 为什么有等待时间？因为最后一个 ACK 可能丢失，而主机 2 发送的 FIN 包含有超时重传机制，如果略大于 1 MSL 之后还没有收到的话会进行重传，而等待时间就是用于等待可能的重传包的，若没有等到则认为正常收到，就可以关闭连接。 当主机 2 收到 FIN 报文并且自己也没有数据需要发送的时候，中间的两次握手可以合并。 主机 1 和 主机 2 也可能同时发出 FIN 报文，并不会影响最后的结果。 在进程异常退出的时候会直接发送 RST 报文并直接暴力关闭连接，没有挥手过程。 TCP 滑动窗口 TCP 协议使用选择性重传，但不使用 NAK。 只有一个超时定时器，只要有未确认的数据段就要启动。超时则重传当前未收到确认的最小序号的数据段。 TCP 采用字节流的方式，每个数据段使用其第一个字节的编号作为序号，而确认号则是期待接收的下一个字节的序号。 TCP 协议没有直接规定错序到达的数据段的处理方式，需要取决于具体实现。 TCP 的确认机制 快速重传 如果发送方收到一个数据段的 3 次重复 ACK 就会认为其后的数据段已经丢失，在超时之前就会重传该数据段。 延迟确认 采用延迟确认的时候，接收方不会在收到数据段的时候立即进行确认，而是延迟一段时间再确认，在这期间收到的多个数据段只需要对最后一个数据段进行确认。 如果发送确认号的同时有数据要发往对方，还可以使用捎带确认机制一起发送。 大部分系统的延迟确认时间为 200 ms，TCP 标准要求不大于 500 ms。 选择性确认 选择性确认允许接收方把收到的数据块通过数据段的选项告知发送方，使发送方不会重传这些数据块。 TCP 的拥塞控制 拥塞控制的两类方法 端到端：没有来自网络的明确反馈，通过丢包和延迟推导。（如快速重传） 网络辅助：由路由器反馈给终端，使用信号指出拥塞发生，或者是直接给出发送速率。 TCP 拥塞控制 超时或者收到 3 个重复 ACK 则认为丢包，拥塞发生。 发送速率 rate = SWS（发送窗口大小） / RTT 引入拥塞窗口变量 CongWin 来限制 SWS。SWS = Min(CongWin, AdvWin)。 加性增乘性减：每个 RTT 增加 1 MSS，直到丢包，丢包后 CongWin 直接减半。 慢启动 初始时 CongWin 设置为 1 MSS，并设置一个阈值。 在当前窗口所有数据段确认都收到后 CongWin 加倍。 当拥塞发生时，把当前 CongWin 减半作为阈值。然后又从 1 开始。 当 CongWin 达到阈值后，每次增加 1 MSS。 TCP 的问题及解决方法 长肥管道 如果两个端点的管道容量很大，可能会出现管道不满载、序号回绕的问题。 可以使用 SYN 选项设置 Window Scaling，$WinSize=AdvWin*2^{WinScale}$。 序号回绕使用数据段的选项的时间戳解决，只用于区分，不确认先后次序。 当丢包发生时需要清空管道，并使用快速重传、快速恢复。 死锁现象 如果接收方发送了窗口为 0 的 ACK，然后取走接收缓冲区的数据，再次发送的 ACK 丢失，则发送方会认为接收方仍然没有空位，从而发生死锁。 解决办法是使用坚持定时器，定期从要发送的数据取一个字节发送出去，直到收到大小不为 0 的通知窗口。 傻瓜窗口症候 发送进程有很多小批量的数据要发送。 Nagle 算法：发送方收到 ACK 或者发送进程的数据达到 MSS 才发送下一个数据段。这样的方法对于即时性要求高的不适用（如鼠标操作）。 接收进程频繁取走小批量数据。 Clark 算法：当接收缓冲区的空闲块变得很小时，等到空闲块大小为接收缓存区的一半或者达到 MSS 才发送通知窗口。 TCP 的定时器 重传定时器：针对第一个未确认的数据段。超时重传或者发送窗口移动才重启。 坚持定时器：用于保持窗口大小消息流动即使连接的另一端关闭了接收窗口。 保活定时器：在长时间没有交换数据段之后检测连接的另一端是否出现问题。 应用层概述 应用层直接和应用程序接口并提供常见的网络应用服务。 应用层是开放系统的最高层，是直接为应用进程提供服务的。 应用层的许多协议都是基于客户服务器方式。 常见的应用层协议：DNS、HTTP、FTP、SMTP。 DNS 协议 域名服务器（DNS）是专门用于解析域名的服务器。 在因特网中，主机之间的通讯是通过 IP 地址进行的。而 IP 地址难以记忆，我们一般采用的都是域名的方式进行访问，例如 ender-coder.github.io 这样的域名。 DNS 存储了域名与 IP 地址之间的映射，提供了域名与 IP 地址之间的转换服务。 DNS 是使用分布式数据库实现的，通过在不同 DNS 服务器之间进行转发直到找到信息。 DNS 报文包括请求报文和响应报文，一般采用 UDP 协议，超过 512 字节可以采用 TCP 协议。 DNS 采用的端口号是 53，在 UDP 和 TCP 都是如此。 DNS 查询可以是递归查询也可以是迭代查询。 HTTP 协议概述 超文本传输协议（HTTP）是应用层最基本的客户端与服务器的访问协议。 本地浏览器向服务器发送请求，而服务器回应本地浏览器相应的网页。 HTTP 的标准制定由万维网协会（W3C）和互联网工程任务组（IETF）进行协调，最终发布了一系列的RFC，其中最著名的是 1999 年 6 月公布的 RFC 2616，定义了 HTTP 协议中现今广泛使用的一个版本 —— HTTP 1.1。 HTTP 是无连接、无状态的，也即服务器不维护任何关于客户端过去发送的信息。 HTTP 协议使用 TCP 连接进行可靠的传送。 HTTP 采用的端口号是 80。 请求网页的工作过程 用户确定要访问的域名 URL，输入到浏览器中。 浏览器向 DNS 服务器发出请求，得到相应的 IP 地址。 浏览器向指定地址的 80 端口发出一条 TCP 连接请求。 通过三次握手建立 TCP 连接后，浏览器向服务器发送 HTTP 请求。 服务器收到请求后，向浏览器发送网页文件。 网页文件发送完成后，服务器通过四次挥手关闭 TCP 连接，通讯完成。 浏览器解析收到的网页文件并显示。 如果该网页中含有图片等信息，一般是通过异步传输的方式，浏览器还需要再次与服务器建立连接并请求该部分信息。 现有的 HTTP 1.1 协议中，连接不会马上进行关闭，而是会等待一定的时间，如果用户有后续操作就可以直接在这个连接进行通讯，这样可以提高效率，减少短时间内建立连接的次数。 Cookie 与 Session 现有的 HTTP 协议中引入了 cookie 技术，可以保存状态信息（比如用户的登陆态）。 浏览器发送 request 请求到服务器，服务器除了返回请求的 response 之外，还给请求分配一个唯一标识ID，协同 response 一并返回给浏览器。 服务器在本地创建一个 MAP 结构，专门以 key-value（请求ID-会话内容）形式将每个 request 进行存储。 浏览器的第二次 request 带有 ID，服务器先从 request 中查找该 ID，根据 ID 查找维护会话的 content 内容，该内容中记录了上一次 request 的信息状态。 根据查找出的 request 信息生成基于这些信息的 response 内容，再次返回给浏览器。如果有需要会再次更新会话内容，为下一次请求提供准备。 session 即是这个过程中保存在服务器的信息，也就是服务器会通过 session 保存一个状态记录，浏览器会通过 cookie 保存状态记录，服务器通过两者的对比实现跟踪状态。这样也极大的避免了cookie 被篡改而带来的安全性问题。 cookie 保存在客户端，比较不安全；session 保存在服务器端，比较安全。 cookie 中保存的是字符串，而 session 中能够存储任何类型的数据。 一般情况下，cookie 的过期时间会设置得很大，这样 cookie 会在浏览器中保存很长时间，而 session 依赖于 sessionId，如果把 id 设置为 -1 的话，如果关闭浏览器，session 就会失效。 cookie的缺陷 cookie 会被附加在每个 HTTP 请求中，所以无形中增加了流量。 由于在 HTTP 请求中的 cookie 是明文传递的，所以安全性成问题。（除非用HTTPS） cookie 的大小限制在 4KB 左右。对于复杂的存储需求来说是不够用的。 HTTP 请求方法 GET：请求指定的页面信息，并返回实体主体。 HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 PUT：从客户端向服务器传送的数据取代指定的文档的内容。 DELETE：请求服务器删除指定的页面。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS：允许客户端查看服务器的性能。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 GET 和 POST 请求的区别 GET 提交的数据会放在 URL 之后，也就是请求行里面，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。而 POST 方法是把提交的数据放在 HTTP 包的请求体中。 GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。 POST 的安全性要比 GET 的安全性高。比如通过 GET 提交数据，用户名和密码将明文出现在 URL 上，除此之外，使用 GET 提交数据还可能会造成跨站请求伪造（CSRF）攻击。 HTTP 状态码状态代码的第一个数字代表当前响应的类型： 1xx 消息 —— 请求已被服务器接收，继续处理。 2xx 成功 —— 请求已成功被服务器接收、理解、并接受。 3xx 重定向 —— 需要后续操作才能完成这一请求。 4xx 请求错误 —— 请求含有词法错误或者无法被执行。 5xx 服务器错误 —— 服务器在处理某个正确请求时发生错误。 HTTP 和 HTTPS 的区别 HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。 安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议，SSL/TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 协议握手阶段比较费时，连接缓存不如 HTTP 高效，并且 SSL 证书是需要收费的。 HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用，并且 SSL 的信用链也不是绝对安全的。 FTP 协议概述 文件传输协议（FTP）的目标是提高文件的共享性和可靠高效地传送数据。 在传输文件时，FTP 客户端程序先与服务器建立 TCP 连接，然后向服务器发送命令。 FTP 协议与操作系统无关，任何操作系统上的程序只要符合 FTP 协议，就可以相互传输数据。 相比于其他协议，FTP 协议要复杂一些，命令传输与数据传输分别采用不同的端口。 FTP 的工作过程 启动 FTP 服务器。由于 FTP 采用了客户机 / 服务器工作模式，因此在创建 FTP 会话之前，首先必须启动 FTP 服务器，并使其处于等待客户机程序的 FTP 请求状态。 打开 FTP 并建立控制连接。启动 FTP 客户机程序，并向 FTP 服务器的 21 端口（控制连接端口）发出主动连接的请求，以期获得 FTP 服务器的相应权限。服务器响应请求后便在用户协议解释器和服务器协议解释器之间建立了一条 TCP 连接。 建立数据连接并进行文件传输。用户通过客户机程序输入 FTP 命令，服务器接收命令。如果命令正确且需要进行文件传输，服务器使用 TCP 20 端口在双方之间建立另一条 TCP 连接，即数据连接，并通过该连接进行文件传输。当本次命令的文件传输完毕，关闭该数据连接。 关闭 FTP。用户执行完其所需的 FTP 命令后，发出退出 FTP 命令，控制连接关闭，本次 FTP 服务结束。 主动模式（PORT） 客户端随机打开一个大于 1024 的端口向服务器的 21 命令端口发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从它自己的 20 数据端口主动连接到客户端指定的数据端口（N+1）。 FTP 的客户端只是告诉服务器自己的端口号，让服务器来连接客户端指定的端口。对于客户端的防火墙来说，这是从外部到内部的连接，可能会被阻塞。 被动模式（PASV） 当开启一个 FTP 连接时，客户端打开两个任意的本地端口（N &gt; 1024 和 N+1）。 第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口（P &gt; 1024），并返回带有该端口号的信息。 客户端收到命令取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。 "},{"title":"数据结构与算法 知识总结","date":"2021-07-25T13:30:00.000Z","url":"/2021/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;关于 数据结构与算法 知识体系的总结。 常用的数据结构 数组 array 链表 list 栈 stack 队列 queue 树 tree 哈希表（散列表） hash 堆 heap 图 graph 数组特点 元素在内存中连续存放，每个元素占用的相同的空间。 可以通过下标迅速访问数组元素。$O(1)$ 插入和删除效率低（需要整体移动腾出空间或者删除空间）。$O(n)$ 需要预留空间，在定义的时候就定义好大小并申请内存空间。 难以扩展。 STL vector&emsp;&emsp;STL 中的 vector 是封装了动态大小数组的顺序存储容器，它与数组有着非常多的相似之处，可以直接进行随机访问，与数组不同的是，vector 可以动态地增加大小，可以在末尾增加/删除元素。并且 vector 拥有迭代器，也可以通过迭代器进行访问。 关于vector的详细信息  链表特点 元素在内存中非连续存放，依靠指针进行连接。 每个元素存储占用的空间比数组更大（需要存储下一个位置的指针，双向链表还需存储上一个位置的指针） 随机访问的效率低，需要按照链表的顺序遍历。$O(n)$ 插入和删除效率高，在相应结点修改指针进行连接。$O(1)$ 无需事先知道数据大小，可以在插入结点的时候再申请空间，内存利用率高。 易于动态扩展。 STL list&emsp;&emsp;STL 中的 list 就是封装好的双向链表容器。 关于list的详细信息  栈特点 栈是一种特殊的线性表。 按照先进后出（FILO）的规则存储数据。 只能在一端（栈顶）执行插入和删除操作。 STL stack&emsp;&emsp;STL 中的 stack 就是封装好的栈容器。 关于stack的详细信息  队列特点 队列是一种特殊的线性表。 按照先进先出（FIFO）的规则存储数据。 可以在队头执行删除操作，在队尾执行插入操作。 STL queue&emsp;&emsp;STL 中的 queue 就是封装好的队列容器。 关于queue的详细信息  STL deque&emsp;&emsp;STL 中的 deque 是封装好的双端队列。可以从队列的两端插入和删除元素。与 vector 类似，支持随机访问和快速插入删除。 关于deque的详细信息  树特点 由有限结点组成的具有层次关系的一个集合。 每个节点有 0 个或多个子节点。 没有父节点的节点称为根。 每一个非根节点有且仅有一个父节点。 除了根节点外，每个子节点可以分为多个不相交的子树。 二叉树 每个节点至多含有两个子树（分别称为左子树、右子树）。 完全二叉树 设二叉树的深度为 h。 除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数。 第 h 层所有的结点都连续集中在最左边。 满二叉树 二叉树的所有层结点数都达到最大个数。 二叉查找树 也成为二叉搜索树、有序二叉树。 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 平衡二叉树 当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树 典型的平衡二叉树：AVL 树（自平衡二叉搜索树） 红黑树 红黑树是一种弱平衡二叉树，旋转次数更少。 每个结点要么是红的要么是黑的。（红或黑） 根结点是黑的。（根黑） 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。（叶黑） 如果一个结点是红的，那么它的两个儿子都是黑的。（红子黑） 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。（路径下黑相同） 红黑树的调整操作方式有旋转和变色两种。 哈夫曼树 一种带权路径长度最短的二叉树。 也称为最优二叉树。 多路查找树B/B+ 树 B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树。 在大规模的数据存储中，二叉查找树会由于深度过大而造成磁盘 I/O 读写频繁，因而造成效率低下。 在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度。 关于AVL树、红黑树、B/B+树的详细信息  STL set 和 mapset set 表示的是一个集合。 set 中的元素都是唯一的。 set 中的元素在插入的时候就会进行排序（默认升序）。 set 中的元素的值并不能直接被改变，需要使用迭代器。 set 的底层实现是红黑树。 &emsp;&emsp;由于以上特点的存在，set 的插入删除和查找的效率是 $O(\\log n)$ 的。set 中的元素可以使用迭代器 iterator 进行访问。 multiset&emsp;&emsp;与 set 的功能类似，不同的是允许插入重复的值。 关于set和multiset的详细信息  map map 表示的是一个映射集合，保存的是 key-value 对。 map 中的关键字（key）是唯一的。 map 中的元素在插入的时候就会根据 key 进行排序（默认升序）。 map 中的元素的值并不能直接被改变，需要使用迭代器。 map 的底层实现是红黑树。 &emsp;&emsp;map 与 set 非常相似，只是存储的是一个数据对，其中一个是关键字，作为标识，而关键字对应的值则只跟随关键字，没有类型、大小等等限制。可以使用 map 的迭代器的成员变量 first 和 second 来访问关键字和值，也可以直接使用关键字作为下标进行访问，得到的是对应的值。 multimap&emsp;&emsp;与 map 的功能类似，不同的是允许插入重复的关键字。相应的，multimap 就不再支持通过关键字作为下标进行访问。 关于map和multimap的详细信息  哈希表特点 根据关键码值(Key value)而直接进行访问。 通过哈希函数把关键码值映射到表中一个位置。 插入删除和查找的复杂度都是 $O(1)$ 。 哈希函数&emsp;&emsp;一个好的哈希表离不开好的哈希函数。好的哈希函数计算快并且冲突少，才能真正达到 $O(1)$ 的复杂度。哈希函数设计的考虑因素有以下几点 关键字的长度和表的长度 计算散列地址所需要的时间较小（也即哈希函数不能太复杂） 关键字分布是否均匀，是否有规律可循 在满足以上条件的情况下尽量减少冲突 哈希冲突的解决办法&emsp;&emsp;经过哈希函数处理后仍然有不同的数据对应相同的值，也即不同的关键字映射到相同的位置上，这时候就产生了哈希冲突。我们一般有开放定址法、链地址法、公共溢出区法、再哈希法。下面中的 $\\alpha$ 表示装填因子，装填因子=数据总数/哈希表长。 哈希冲突的解决办法 1.开放定址法&emsp;&emsp;开放其他关键字对应的位置给产生冲突的关键字放置。 线性探测再散列：发生哈希冲突时在原来值的基础上往后加一个单位，直至不发生哈希冲突。查找效率 $S_{nl}\\approx\\frac{1}{2}(1+\\frac{1}{1-\\alpha})$ 。 平方探测再散列：发生哈希冲突时在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。 随机探测再散列：发生哈希冲突时通过伪随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。查找效率 $S_{nr}\\approx-\\frac{1}{\\alpha}\\ln(1-\\alpha)$ 。 2.链地址法&emsp;&emsp;产生哈希冲突后在存储数据后面加一个指针，指向后面冲突的数据。查找效率 $S_{nc}\\approx 1+\\frac{\\alpha}{2}$ 。 处理冲突简单，无堆积现象（非同义词不会产生冲突），因此平均查找长度较短。 由于链表上的结点空间是动态申请的，因此更适合难以事先知道表长的情况。 开发定址法为了减少冲突，要求装填因子较小（也不能超过1），浪费的空间也比较多。而链地址法中装填因子甚至可以超过1，当然，过长的链条也会使哈希表退化成为 $O(n)$ 的复杂度。 使用链地址法构造的哈希表删除结点更加简单，直接删去链表上相应结点即可。 3.公共溢出区法&emsp;&emsp;建立公共溢出区存储所有哈希冲突的数据。 4.再哈希法&emsp;&emsp;对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。 STL unordered_set 和 unordered_mapunordered_set unordered_set 表示的是无序集合。 unordered_set 的其他性质与 set 类似。 unordered_set 的底层实现是哈希表。 关于unordered_set的详细信息  unordered_map unordered_map 表示的是无序映射集合。 unordered_map 的其他性质与 map 类似。 unordered_map 的底层实现是哈希表。 关于unordered_map的详细信息  堆特点 堆其实看做是用数组实现的完全二叉树（按照层序遍历存储）。 最大堆的节点的值总是不大于其父节点的值。 最小堆的节点的值总是不大于其父节点的值。 根结点下标从 0 开始 左子节点的下标为 2 * i + 1 右子节点的下标为 2 * i + 2 用途 快速找出集合中的最大值或最小值 构造优先队列 堆排序 堆和二叉搜索树的区别 节点顺序不同。堆中的根结点是最大值或者最小值，而二叉搜索树的根结点是中间值。 堆的内存占用更小。二叉树需要指针指向子节点，而堆使用数组存储。 堆的平衡更简单。二叉树必须在平衡的情况下才能保证大部分操作是 $O(\\log n)$ 的，而堆不需要整棵树都有序，可以保证所有的操作都具有 $O(\\log n)$ 的性能。 二叉树的搜索更快。二叉搜索树建立之后，只要是平衡的，搜索的性能就能够达到 $O(\\log n)$，而堆主要处理的是最大值或最小值，快速地进行相关的插入和删除操作，搜索性能会比较差。 调整堆&emsp;&emsp;下面是调整堆的代码。我们在加入一个结点的时候，需要对堆进行调整使堆依然保持特性。根结点下标为 begin，堆尾下标（也即堆的大小）为 k。需要保证的是除了刚加入的根结点，其叶子结点都已经满足堆的特性。一次调整的时间复杂度为 $O(\\log n)$。 建立堆&emsp;&emsp;调整堆的代码就是上面所给出的代码。我们只需要自底向上将每个子树都调整到符合堆特性即可，这样就完成了一个堆的建立。这个操作的时间复杂度是 $O(n)$。 STL 中的堆&emsp;&emsp;在 STL 的头文件 algorithm 中含有关于堆的代码。当然实际应用的时候通常会要求我们自己实现堆的操作。 STL 中的堆支持以下的基本操作: 图特点 由顶点和连接顶点的边构成的离散结构。 有向图的边具有方向性。 加权图的边具有权重。 完全图的每两个顶点之间都有边。 树是一种特殊的有向图。 关于图的详细信息  图的表示 邻接矩阵：一个拥有 V 个顶点的图使用一个 V * V 的矩阵表示，行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。 邻接链表：一个拥有 V 个顶点的图使用一个大小为 V 的线性表和一些链表表示，每个顶点连接的链表表示与其有邻接关系的顶点。如果对查询的要求较高的话，链表也可以换成其他高效的查找结构（如哈希表）。 图的遍历 深度优先搜索（DFS） 广度优先搜索（BFS） 拓扑排序：给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的顶点指向排在后面的顶点。（如果一个有向图有环则没有拓扑排序） 最小生成树 图的生成树：是它的一棵含有其他所有顶点的无环连通子图。 加权无向图的最小生成树（MST）：是它的一棵所有边的权值之和最小的生成树。 Prime 算法（加点法）：先选择一个顶点，并不断将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入树中。（优先队列） Kruskal 算法（加边法）：按照边的权重顺序不断将最小的边加入到生成树中，不能和已有的边产生环。（优先队列和并查集） 关于最小生成树算法的详细信息  最短路径 加权有向图的最短路径问题：找到从一个顶点到达另一个顶点的成本（权重和）最小的路径。 DFS 和 BFS（单源最短路径） Floyd 算法（允许负权边（但不能在环路上），多源最短路径，动态规划思想）：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转，直到允许经过 1~n 号所有顶点进行中转，求任意两点之间的最短路程。（$O(v^3)$ 时间复杂度和 $O(v^2)$ 空间复杂度） Dijkstra 算法（不允许负权边，单源最短路径，贪心法思想）：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。（$O(v^2)$ 的时间复杂度，如果边数远小于 $v^2$ 则可以使用堆优化到 $O(e\\log v)$ 的时间复杂度） Bellman-Ford 算法（允许负权边，单源最短路径）：对所有的边进行 n-1 轮松弛操作，得到从某一点出发到其他点的最短路径，同时可以判断是否存在负权环。（时间复杂度 $O(ve)$，空间复杂度 $O(e)$） 关于最短路径算法的详细信息  "},{"title":"Leetcode 238.除自身以外数组的乘积","date":"2021-07-23T14:57:00.000Z","url":"/2021/07/23/Leetcode%20238.%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 进阶：你可以在常数空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 示例: 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 链接： 题目分析&emsp;&emsp;题目中要求我们不使用除法，而实际上使用除法也存在的一定的问题：如果数组中含 0，除以 0 也会出现问题。我们要求的是除了本身以外其余各元素的乘积，而且要达到 $O(n)$ 的时间复杂度，也即前面的乘积结果最好能使用上，怎么使用呢？其实我们要求的结果，可以看做是左边部分的乘积乘上右边部分的乘积。那么先不考虑空间复杂度的问题，我们可以使用两个数组，一个记录从左到右分别乘起来的乘积，一个记录从右到左分别乘起来的乘积，则 result[i] = left[i-1] * right[i+1]。按照这个思路，我们只需要从左到右和从右到左分别遍历一次，得到这两个数组，最后再遍历一次求出各个位置的结果就可以。&emsp;&emsp;接下来考虑，该如何减小空间复杂度呢？答案数组是不计入所需空间的，我们从左到右的遍历，可以直接记入答案数组中，当然，需要一点小小的变化，第一个数直接记入到第二个空位中，因为第二个结果才需要第一个数的乘积。然后进行从右到左的遍历中，我们只需要使用一个数记录最后的乘积值，作为转移的依据，而乘积结果则可以直接乘入到答案数组中，这样还省去了第三次遍历的过程。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们对数组进行了两次遍历。&emsp;&emsp;空间复杂度：$O(1)$。答案数组不计入空间复杂度中，而我们只需要额外的常数个变量。"},{"title":"Leetcode 236.二叉树的最近公共祖先","date":"2021-07-23T14:29:00.000Z","url":"/2021/07/23/Leetcode%20236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中 最近公共祖先 的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 示例 2： 示例 3： 提示： 树中节点数目在范围 $[2, 10^5]$ 内。 $-10^9 &lt;= Node.val &lt;= 10^9$ 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 链接： 题目分析&emsp;&emsp;这道题应该是使用递归的方法，按照深度优先搜索寻找两个结点的最近祖先。我们使用函数 bool dfs() 进行递归遍历，而函数的返回值是子树中是否含有 p 或者 q。为什么要这么做？题目中给出的条件中提到，p != q，并且最近祖先的定义中，祖先是包含本身的。那么 p 和 q 的最近祖先可能是 p 本身或者 q 本身或者某个结点满足 p 和 q 分别在它的两个子树中。那么我们的返回值就无需区分 p 和 q，只需要知道子树中是否包含这两个之一（因为我们是从上往下遍历，递归的时候是从下往上返回，找到的第一个祖先就是最近祖先）。&emsp;&emsp;只要 root 的左右子树都含有 p 或 q，或者 root 是 p 或 q 中的一个，并且左右子树中含有 p 或 q，则 root 就是答案了，我们可以使用一个全局变量直接进行记录。而函数的返回结果就是左右子树中含有 p 或 q 或者本身就是 p 或 q。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们对二叉树进行了一次深度优先遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。取决于递归栈的深度，最坏情况下二叉树是一条链，栈深度达到了 $n$。"},{"title":"Leetcode 234.回文链表","date":"2021-07-23T13:59:00.000Z","url":"/2021/07/23/Leetcode%20234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：请判断一个链表是否为回文链表。进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;判断回文我们可以使用双指针的方法，从两边同时遍历判断是否相等，但是这道题的数据结构是单链表。第一个方法是将其拷贝到数组中再使用双指针，第二个方法是使用递归，反向获得链表的值，并与正向的相比较。但是这两种方法的空间复杂度都是 $O(n)$。如何达到 $O(1)$ 的空间复杂度呢？我们应该要使用迭代的方法。&emsp;&emsp;我们可以先使用快慢指针找到链表的中点，并用 Leetcode 206.反转链表 中的迭代法将后半部分翻转。翻转后两条链表应该是相同的（除了奇数结点的中间结点），这样我们就可以迭代判断是否符合回文特性了。然后我们再将后半部分翻转一遍（相当于复原）接回原链表。这样做是为了不破坏原链表的结构。&emsp;&emsp;注意代码中快慢指针寻找到的中点是前半部分的最后一个结点，并且如果结点数是奇数，最中间的结点会包含在前半部分中。这样做的好处是后半部分的开头可以直接通过前半部分结尾获得，并且复原后也是接到前半部分的结尾中。而由于奇数中间结点包含在前半部分中，我们判断回文的退出条件是后半部分遍历完成，这样这个结点无需进行判断。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是链表的长度。我们对链表进行的寻找中点操作、反转操作、判断回文操作都是 $O(n)$ 的。&emsp;&emsp;空间复杂度：$O(1)$。我们所有的操作都是通过指针迭代进行的，需要的空间是常数级的。"},{"title":"Leetcode 226.翻转二叉树","date":"2021-07-23T13:19:00.000Z","url":"/2021/07/23/Leetcode%20226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：翻转一棵二叉树。 示例：输入： 输出： 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 链接： 题目分析&emsp;&emsp;非常经典的递归问题。递归遍历二叉树并将它们的左右子树交换即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是二叉树的结点数。取决于递归栈的深度，在最坏的情况下二叉树是一条链，深度会达到 $n$，最好情况下是平衡二叉树，深度为 $\\log n$。"},{"title":"Leetcode 221.最大正方形","date":"2021-07-23T12:21:00.000Z","url":"/2021/07/23/Leetcode%20221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：在一个由 &#39;0&#39; 和 &#39;1&#39; 组成的二维矩阵内，找到只包含 &#39;1&#39; 的最大正方形，并返回其面积。 示例 1： 示例 2： 示例 3： 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 300 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 链接： 题目分析&emsp;&emsp;我们首先思考一下，形成一个 n*n 的正方形的条件是什么？我们可以有这样的递归定义：四个角都可以形成 (n-1)*(n-1) 的正方形。那么我们就可以使用动态规划的方法了。我们使用 dp[i][j] 表示以 matrix[i][j] 为右下角的最大正方形边长，那么 dp[i][j] &gt;= n 的充要条件是 dp[i-1][j]、dp[i][j-1] 和 dp[i-1][j-1] 都大于等于 n-1。而 dp[i][j] 的值，就取决于这三个数中最小的那个。当 matrix[i][j] 为 &#39;0&#39; 时，显然 dp[i][j] 为 0，也即其无法构成正方形。而当 matrix[i][j] 为 &#39;1&#39; 时，我们有这样的动态转移方程： dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1&emsp;&emsp;而我们按顺序遍历矩阵，记录出现过的最大 dp 值（也即最大正方形边长）即可。需要注意的是当 i 或 j 为 0 时的边界情况。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是矩阵的行数和列数。我们对矩阵进行了一次遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是矩阵的行数和列数。我们需要和矩阵同样大小的 dp 数组。"},{"title":"Leetcode 215.数组中的第K个最大元素","date":"2021-07-23T09:50:00.000Z","url":"/2021/07/23/Leetcode%20215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","tags":[["C++","/tags/C/"],["堆","/tags/%E5%A0%86/"],["快速排序","/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 示例 2: 提示： $1 &lt;= k &lt;= nums.length &lt;= 10^4$ $-10^4 &lt;= nums[i] &lt;= 10^4$ 链接： 题目分析1.快速排序改进&emsp;&emsp;这道题就是非常经典的 Top-K 问题。当然最简单的方法就是直接将整个数组进行排序后再返回第 K 个数。但是这样的处理方法做了很多没有用的功课，比如我们其实只需要获取第 K 大的数，而比它大的那些数和比它小的那些数是无需进行排序的。我们可以想到快速排序的原理，就是每一次选取一个哨兵节点并且将比它大的和比它小的数放到它的两边。那么我们只需要这样做，并且根据放置后的结果选择大的那些数还是小的那些数进行同样的操作，直到最后划分的哨兵刚好分出来 K-1 个比它大的数就可以。&emsp;&emsp;具体的操作是这样的：我们使用一个 quicksort 函数对 [begin, end] 区间进行排序，哨兵结点就是 nums[begin]，将这个区间划分为大于 nums[begin] 和小于 nums[begin] 两边后，返回 nums[begin] 最后的下标。然后我们根据返回的这个下标判断需要对左边的区间还是右边的区间进行新一轮的选择。如此迭代直到最后找到第 k 个数。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组中元素的个数。我们每次划分都相当于对该区间进行了一次遍历。假设每次刚好划分出一半的数组，则我们需要划分的数组分别为 $n、n/2、n/4…$，他们的和趋近于 $2n$，因此平均时间复杂度是 $O(n)$ 的。但是最坏的情况下，我们每一次划分都只分出一个元素，则每次划分的数组分别为 $n、n-1、n-2…$，他们的和是 $O(n^2)$ 的。&emsp;&emsp;空间复杂度：$O(1)$。我们都在原数组上进行操作，也没有使用到递归函数，所需要的空间是常数级的。 2.堆&emsp;&emsp;上面的方法有什么缺点呢？一个是不稳定，受数组划分的影响比较大。另外一个缺点与实际应用相关，如果需要进行处理的数组非常大，没有办法一次性加载到内存中，或者是经常需要添加新元素（例如某个游戏的积分 Top 100 榜），上面的方法是一次性的，没有办法进行处理。这个时候，我们就可以使用堆的做法。&emsp;&emsp;我们维护一个大小为 K 的最小堆，则堆顶就是这个堆中第 K 大的元素。之后我们遍历数组，不断将遍历到的数字与堆顶进行比较，如果比堆顶大则置换掉堆顶，并且重新调整堆使得堆顶仍然为堆里最小的元素。遍历整个数组后堆顶就是这个数组中第 K 大的元素。 &emsp;&emsp;时间复杂度：$O(n\\log k)$，其中 $n、k$ 分别是数组的大小和题目中的 K。对于一个已经建立好的堆，置换堆顶元素后只需要从上往下调整需要交换的那条分支，因此时间复杂度为 $O(\\log k)$，并且是稳定的。我们在建堆之后只需要遍历数组，如果置换则需要调整堆，因此时间复杂度为 $O(n\\log k)$。而建堆的时间复杂度为 $O(k)$（根据调和级数的积分公式得出）。因为 $k\\leq n$，总的时间复杂度为 $O(n\\log k)$。（在实际应用中 K 的值一般不会很大，因此当 $n$ 很大的时候时间复杂度是近似于 $O(n)$ 的，并且比较稳定。）&emsp;&emsp;空间复杂度：$O(1)$。我们的最小堆直接建立在了原数组中。如果原数组不能改动的话则另外需要 $O(k)$ 的空间保存堆。"},{"title":"Leetcode 208.实现 Trie (前缀树)","date":"2021-07-21T15:12:00.000Z","url":"/2021/07/21/Leetcode%20208.%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 $3 * 10^4$ 次 链接： 题目分析&emsp;&emsp;前缀树是一种树形数据结构，每个字母应该是一个结点，则它的子结点最多有 26 个（也即 26 个字母）。并且我们需要一个布尔变量 isEnd 标记该结点是否是字符串终点。以下分别是前缀数的三种操作： 插入。我们按照单词的字母顺序从树的根部开始搜索。 如果字母存在于当前结点的子结点中，则移动到该子结点，继续下一个字母的搜索。 如果字母不存在于当前结点的子结点中，则创建新的子结点，继续处理下一个字母。 完成插入后，需要将最后一个结点的 isEnd 标记为 true，表示该结点是一个字符串的终点。 搜索。我们按照单词的字母顺序从树的根部开始搜索。 如果字母存在于当前结点的子结点中，则移动到该子结点，继续下一个字母的搜索。 如果字母不存在于当前结点的子节结点中，则说明该字符串不存在于前缀树中，直接返回 false。 完成搜索后，检查该结点是否是字符串的终点（isEnd 是否为 true），是则说明该字符串存在于前缀树中，返回 true，反之返回 false。 搜索前缀。我们按照单词的字母顺序从树的根部开始搜索。 如果字母存在于当前结点的子结点中，则移动到该子结点，继续下一个字母的搜索。 如果字母不存在于当前结点的子节结点中，则说明该前缀不存在于前缀树中，直接返回 false。 完成搜索后，返回 true，表示该前缀存在于前缀树中。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是每次操作字符串的长度。初始化的复杂度是 $O(1)$，而对于每次操作（包括插入和搜索），我们都需要按照字符串进行搜索，搜索的深度就是字符串的长度。&emsp;&emsp;空间复杂度：$O(T)$，其中 $T$ 是结点的数目。每一个结点含有大小为 26 的指针数组和一个布尔变量。"},{"title":"Leetcode 207.课程表","date":"2021-07-21T13:56:00.000Z","url":"/2021/07/21/Leetcode%20207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/","tags":[["C++","/tags/C/"],["BFS","/tags/BFS/"],["DFS","/tags/DFS/"],["图论","/tags/%E5%9B%BE%E8%AE%BA/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 示例 1： 示例 2： 提示： $1 &lt;= numCourses &lt;= 10^5$ $0 &lt;= prerequisites.length &lt;= 5000$ $prerequisites[i].length == 2$ $0 &lt;= a_i, b_i &lt; numCourses$ prerequisites[i] 中的所有课程对 互不相同 链接： 题目分析1.深度优先搜索&emsp;&emsp;这个题目其实就是要我们根据先修课程信息建立一个有向图，然后分析该图是否存在拓扑排序（也即有向无环图）。而寻找一个有向图是否有环可以使用深度优先搜索或者广度优先搜索的方法。&emsp;&emsp;首先使用深度优先搜索，我们可以使用一个 visited 数组来记录是否已经遍历过结点。如果一个结点的后置结点都已经遍历完成，则它在拓扑排序中可以出现在这些结点的前面，可以满足拓扑排序的要求的。而若一个结点的后置结点还未遍历，则需要进行搜索，保证这些结点都遍历后才能进行回溯，在搜索时需要将其标记为遍历中，如果某个后置结点的后置结点是遍历中，则说明构成了环，就不存在拓扑排序。因此对一个结点存在三种状态：未遍历、遍历中、已遍历。我们分别用 0、1、2 表示这三种状态。&emsp;&emsp;另外，题目中给出的边（也即先修课程对）是成对的，而我们每次搜索的时候是需要搜索一个结点的所有的后置结点（也即以其为起点的边），则我们将其使用邻接表的形式重新存储，便于遍历。&emsp;&emsp;由于题目只需要判断是否有拓扑排序，而不需要输出排序结果，所以我们仅仅使用 valid 来记录是否出现不合法情况（存在环）即可，不合法则可以直接退出返回 false，在遍历所有的结点之后如果没有出现不合法就返回 true。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是课程数和先修课程的要求数（也即结点和边的数目）。我们对图进行了一次深度优先搜索，每个结点和边都遍历了一次。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m、n$ 分别是课程数和先修课程的要求数（也即结点和边的数目）。我们采用邻接表的形式存储了结点和边的信息，大小为 $O(m+n)$，而递归的最大深度也即结点数目 $O(m)$。因此总的时间复杂度为 $O(m+n)$。 2.BFS&emsp;&emsp;图的广度优先遍历则是和深度优先搜索相反的过程，深度优先搜索是将没有后置结点的结点加入已遍历队列，广度优先搜索则是将没有前置结点的结点加入已遍历队列。我们维护一个队列，将没有入度（没有前置结点）的结点加入队列。每次从队列取出一个结点视为遍历该结点，删除其发出的所有边（也即后置结点的该门先修课程已经能够满足）。&emsp;&emsp;我们还是和前面一样将边信息转化为邻接表。并且使用一个 indeg 数组记录每个结点的入度。删除边的操作其实就是将其指向的结点入度减 1。然后入度为 0 的结点就可以加入到队列中。&emsp;&emsp;由于我们只需要保证所有的结点都能被遍历，则只需要维护一个遍历结点的数目，最后能够等于总的结点数目即可。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是课程数和先修课程的要求数（也即结点和边的数目）。我们对图进行了一次广度优先搜索，每个结点和边都遍历了一次。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m、n$ 分别是课程数和先修课程的要求数（也即结点和边的数目）。我们采用邻接表的形式存储了结点和边的信息，大小为 $O(m+n)$，而队列的最大长度也即结点数目 $O(m)$。因此总的时间复杂度为 $O(m+n)$。"},{"title":"Leetcode 206.反转链表","date":"2021-07-20T15:50:00.000Z","url":"/2021/07/20/Leetcode%20206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 链接： 题目分析1.迭代&emsp;&emsp;按照链表顺序逐个结点反向连接即可。注意反向连接之前需要先保存好下个结点，获取 next 的前提是指针不为空。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是链表的长度。我们对链表进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个指针的空间。 2.递归&emsp;&emsp;递归解法应该也是遍历链表，那么我们需要思考子递归的结果能够给我们带来什么。函数的结果是反转链表，如果我们将下一个结点作为头结点进行递归，那么我们应该得到的是一条除去头结点的反转链表。就像下面这样，1-&gt;2-&gt;3-&gt;4-&gt;...-&gt;n 变成 1-&gt;2&lt;-3&lt;-4&lt;-...&lt;-n。那么我们只需要将下一个结点的 next 赋为头结点，将头结点的 next 置为空，得到的就是结果。&emsp;&emsp;需要注意的是函数的返回结果是反转后链表的头结点，而我们拼接上当前结点后的返回结果也是这个结点。递归的终止条件就是只有一个结点的时候，反转链表的结果其实是相同的，并且这个结点实际上就是新链表的头结点，直接进行返回。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是链表的长度。递归实际上也是对链表进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是链表的长度。递归的深度就是链表的长度。"},{"title":"Leetcode 200.岛屿数量","date":"2021-07-20T14:56:00.000Z","url":"/2021/07/20/Leetcode%20200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","tags":[["C++","/tags/C/"],["BFS","/tags/BFS/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 示例 2： 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39; 链接： 题目分析1.DFS&emsp;&emsp;我们可以使用深度优先搜索的方法，对于每一个陆地，寻找它的周围是不是也是陆地，以此遍历与其连接的所有陆地，并记录为一个岛屿。注意为了防止重复遍历陷入死循环，我们每遍历一个陆地直接将其置为 &#39;0&#39;，然后再对其周围进行搜索。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是二维网格的行数与列数。每个结点最多被遍历一次。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是二维网格的行数与列数。当整个网格都是陆地时，深度优先搜索的深度达到了 $mn$。 2.BFS&emsp;&emsp;我们也可以使用宽度优先搜索来对岛屿进行搜索。对于每一个岛屿我们都需要维护一个搜索队列，将搜索到的相邻陆地添加到队列中，并按照队列的顺序进行搜索，直到队列为空，记录为一个岛屿。同样的，我们也需要将已经遍历过的陆地置为 &#39;0&#39;。&emsp;&emsp;需要注意的是标记的位置，在加入队列的时候就需要同时进行标记，不然在没有处理到队列的这个元素时，其他相邻陆地也可能再次将其当做相邻陆地加入到队列中，造成队列中有非常多的重复元素，从而超时。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是二维网格的行数与列数。每个结点最多被遍历一次。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是二维网格的行数与列数。队列的长度不会超过二维网络的结点总数（实际上不会达到这个上限）。 &emsp;&emsp;PS：官方题解中还有一种并查集的解法，没有很明白。"},{"title":"Leetcode 198.打家劫舍","date":"2021-07-20T13:49:00.000Z","url":"/2021/07/20/Leetcode%20198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 示例 2： 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 链接： 题目分析&emsp;&emsp;很容易就看出这是一道经典的动态规划题目。我们使用 dp[i] 表示能够从前 i 间房屋获取最高金额的现金。则对于第 i 间房屋，我们有两种选择。 偷。则需要保证的是我们不能偷第 i-1 间房屋（不能偷相邻两间房屋）。因此能够获取的最大金额是 dp[i-2] + nums[i-1]。（第 i 间房屋是 nums[i-1]） 不偷。则我们能够获取的最大金额就是 dp[i-1]。 &emsp;&emsp;这样我们便得到了我们的动态转移公式 dp[i] = max(dp[i-2] + nums[i-1], dp[i-1])。而边界条件是 dp[0] = 0，dp[1] = nums[0]。可以注意到的是，每个状态只跟前两个状态有关，并且我们最后的结果就是 dp[nums.size()]，也即动态规划的最后一个状态。则我们可以使用滚动数组的思想，丢弃前面的状态，只用三个变量分别存储当前的状态 money、前一个状态 one、前两个状态 two。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们只需要对数组进行一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。经过优化之后我们只需要常数个变量的空间。"},{"title":"Leetcode 169.多数元素","date":"2021-07-20T13:07:00.000Z","url":"/2021/07/20/Leetcode%20169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["排序","/tags/%E6%8E%92%E5%BA%8F/"],["摩尔投票","/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 示例 1： 示例 2： 链接： 题目分析1.哈希表&emsp;&emsp;先不考虑进阶要求的话最容易想到的方法就是建立一个哈希表，只需要遍历一次数组并且记录每个数字出现的次数即可。在遍历的同时我们维护出现次数最多的元素，就无需再对哈希表进行一次遍历寻找最大值。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组元素的个数。我们对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组元素的个数。由于数组中存在多数元素，因此其实数组中最多只有 $n-\\lfloor n/2\\rfloor$ 种不同的元素。而我们主要的空间开销就是哈希表，哈希表的最大大小就是 $n-\\lfloor n/2\\rfloor$，也即是 $O(n)$。 2.排序&emsp;&emsp;由于数组中存在多数元素，如果对整个数组进行排序，则多数元素肯定占据了数组一半以上的空间，则数组的中位数肯定就是多数元素。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 是数组元素的个数。也即排序所需的时间复杂度。&emsp;&emsp;空间复杂度：$O(\\log n)$ 或 $O(1)$。取决于排序函数所需的空间，使用自带的排序函数应该是 $O(\\log n)$ 的。 3.摩尔投票&emsp;&emsp;如何实现进阶要求中的 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度呢？由于多数元素占了数组一半以上的数量，则把每个众数记为+1，非众数记为-1，最后得到的结果依然是正数。则我们维护一个众数和一个投票数，如果遍历到的数字是众数则投票数+1，不是则投票数-1，当投票数为 0 时当前众数需要更换，保证投票数非负。这样存在着一个问题：局部众数并不一定是全局的众数，在未获得真正的众数之前，情况会是怎么样的？&emsp;&emsp;假如当前维护的众数并不是真正的众数，则遇到真正的众数时投票数会-1，遇到虚假的众数时会+1，刚好也是符合我们所想要的“抵消”关系，而遇到其他不是当前众数也不是真正众数的数字投票数也会-1，这样只会更快地导致当前虚假众数“下台”。而真正众数的数量是比其他所有数都多的，因此最后推举出来的众数一定会是真正的众数。当前维护的众数如果是真正的众数则投票一切正常。综上所述，我们可以得到正确结果。&emsp;&emsp;这样我们只需要维护一个当前众数和一个投票数，对数组进行一次遍历进行投票即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组元素的个数。我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放变量。"},{"title":"Leetcode 160.相交链表","date":"2021-07-19T14:55:00.000Z","url":"/2021/07/19/Leetcode%20160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 示例 2： 示例 3： 提示： listA 中节点数目为 m listB 中节点数目为 n $0 &lt;= m, n &lt;= 3 * 10^4$ $1 &lt;= Node.val &lt;= 10^5$ $0 &lt;= skipA &lt;= m$ $0 &lt;= skipB &lt;= n$ 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 链接： 题目分析&emsp;&emsp;首先想到最简单的方法就是使用哈希表记录一条链表的所有结点，再遍历另一条链表比对是否存在相同结点即可。这样的算法时间复杂度是 $O(m+n)$，因为需要分别遍历两条链表；而空间复杂度是 $O(m)$，也即需要保存一条链表的所有结点所构成的一个哈希表。&emsp;&emsp;如何达到进阶要求中线性的时间复杂度和常数的空间复杂度呢？我们需要思考的是如何让两个指针同时到达相交的那个交点。两条链表在相交前的结点数可能是不一样的，但是相交后就是一条链表，如果我们让两个指针分别遍历两个链表，则它们走过的路程就是一样的了。&emsp;&emsp;具体的算法是这样的，让两个指针分别从两个链表头部出发，每次前进一个结点，如果前进到链表末尾就换另一条链表头部开始遍历，两个指针相遇或者同时为空的时候结束遍历得到结果。我们分别对四种情况来验证这个算法的正确性： 两条链表有相交且相交前结点数相同。假设相交前的结点有 a 个，则两个指针前进了 a 步就相遇了，得到结果。 两条链表有相交且相交前结点数不同。假设相交前的结点分别为 a 和 b 个，由于 a 和 b 不相等，在第一次进入相同部分时两个指针并不会相遇，假设相同部分长度为 c，则两个指针一前一后完成了对链表的遍历（不会同时为空），这个时候两个指针分别去到了另外一条链表开始遍历，到相同结点时，第一个指针走了 a+c+b 的路程，第二个指针走了 b+c+a 的路程，是相等的，于是他们相遇了，我们就得到了结果。 两条链表没有相交且结点数相同。两个指针分别遍历了各自链表之后同时到达终点成为空指针。 两条链表没有相交且结点数不同。两个指针分别遍历了两条链表之后同时到达终点成为空指针。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两条链表的长度。两个指针最多都只对两条链表进行一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个指针的额外空间。"},{"title":"Leetcode 155.最小栈","date":"2021-07-19T14:28:00.000Z","url":"/2021/07/19/Leetcode%20155.%E6%9C%80%E5%B0%8F%E6%A0%88/","tags":[["C++","/tags/C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 链接： 题目分析1.辅助栈&emsp;&emsp;题目中要求在 $O(1)$ 的时间内寻找到栈中的最小值，那么我们需要一个机制可以在出入栈的同时更新栈中的最小值。找到新的最小值比较简单，直接更新最小值就好了；如果是最小值出栈了，那么如何快速地获得第二小的值呢（也即新的最小值）？因为栈有后进先出的特性，一个元素出栈后其实就是回到了还未入栈的状态，相应的最小值也是一样的，则我们可以维护一个与主栈同步的辅助栈，用于存放栈中的最小值，检索栈中最小值的时候直接返回辅助栈的栈顶就可以。（辅助栈初始化的时候多存放了一个 INT_MAX，便于更新最小值的判定。） &emsp;&emsp;时间复杂度；$O(1)$。各个操作的时间复杂度都是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是栈的元素个数。除了题目中所必要的栈，我们还需要一个相同大小的辅助栈。 2.保存差值&emsp;&emsp;有没有存在一种算法，可以不用额外的辅助栈也能够获得每个状态对应的最小值呢？我们可以观察辅助栈的特性，因为辅助栈中存放的总是栈中的最小值，则其中的数字是非递增的，我们如果主栈存放的是数字与最小值的差值，则如果一个数是新的最小值，这个数与当前最小值的差值就会小于 0，我们就可以知道最小值更新了。则我们只需要维护一个全局的最小值变量就可以了，而存放在栈中的数字就是这个差值。当元素出栈的时候检查差值，如果大于等于 0 则说明最小值无需回退，栈顶实际值也就是最小值加上差值；当差值小于 0 时说明最小值需要回退，而回退的最小值其实就是当前最小值减去差值。&emsp;&emsp;需要注意的细节是两个 int 的差值可能会超过 int 所能表示的范围，因此需要使用 long 类型来存储。 &emsp;&emsp;时间复杂度；$O(1)$。各个操作的时间复杂度都是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(1)$。除了题目中所必要的主栈，我们只需要常数的空间来保存最小值。 &emsp;&emsp;PS：一开始看到这个题目的时候我以为是要手写一个栈，后面瞄了一眼题解才知道原来只是为了处理这个最小值，官方题解就是直接使用 STL 中封装好的栈的。本来我也是想手写一个栈的，需要用到的数据结构是数组，并维护一个栈顶下标就可以。但是数组大小如何确定呢？按照实际使用的情况来说需要先定义一个大小，遇到不够用的情况再进行扩容。然后想想自己实现扩容有点麻烦，要不用一下 STL 中的 vector 吧，直接使用 push_back 就可以，扩容交给容器。然后又想，我既然都使用 STL 的 vector 了，为什么不直接使用 stack 呢…"},{"title":"Leetcode 152.乘积最大子数组","date":"2021-07-16T11:59:00.000Z","url":"/2021/07/16/Leetcode%20152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;这道题跟 Leetcode 53.最大子序和 有点相似，我们当时采用的是动态规划的方法，对于每个数字都选择是否要将其加入前面的子数组中或者单独作为一个新子数组的开始，这道题能不能用同样的方法呢？答案是不能的。因为乘积并不符合“最优子结构”的定义。比如前面子数组的乘积是一个负数，现在乘上一个正数只会“负的更多”，但是如果后面出现了一个负数，乘上之后可以变得更大。因此当前位置的最优解并不一定是前一个位置的最优解转移得到的。&emsp;&emsp;通过上面的分析我们可以知道其实原因出在负数上面，那我们先分开讨论试试。如果当前位置是一个负数，则我们希望前面子数组的乘积也是负数，并尽可能“负的更多”，这样得到的结果是最大的。如果当前位置是一个正数，则我们希望前面子数组的乘积也是正数，并且尽可能“正的更多”。而其实“负的更多”也是由两个绝对值更大的正负数相乘得到的，那么实际上我们只需要维护两个动态转移的数，一个是最大数 Max，一个是最小数 Min，分别用于存放“正的更多”和“负的更多”两个数。对于每一个状态，将 nums[i]、Max*nums[i]、Min*nums[i] 三个数的最大值更新为 Max，最小值更新为 Min。并且记录遍历过程中出现过最大的 Max 即可。&emsp;&emsp;这里需要注意一个细节：不能直接将最大值赋给 Max，因为参与下面获取最小值的运算所需要的 Max 是上一个状态的。为了代码美观我们使用了两个变量 newMax 和 newMin 用于临时存放运算结果。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的长度。我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 148.排序链表","date":"2021-07-16T11:08:00.000Z","url":"/2021/07/16/Leetcode%20148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["归并排序","/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目在范围 $[0, 5 * 10^4]$ 内 $-10^5 &lt;= Node.val &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;题目中进阶要求我们使用 $O(n\\log n)$ 时间复杂度的算法，则我们想到的有快速排序、归并排序、堆排序。而我们需要进行排序的不是数组而是链表，最适合的应该是归并排序。如何进行归并排序呢？我们可以将链表拆分成子链表，分别进行排序后再重新连接起来，而连接两个链表的算法可以使用我们前面做过的题目 Leetcode 21.合并两个有序链表。连接的时间复杂度是 $O(n)$ 的，而我们需要做 $O(\\log n)$ 次归并排序，能够符合题目要求。&emsp;&emsp;具体需要怎么做呢？一种是自顶向下拆分链表，递归地将链表拆分成两部分，直到变成只有单个结点，就可以视为有序的链表进行合并，慢慢地往上连接返回，但是这样需要 $O(\\log n)$ 的递归空间，不能符合进阶要求中常数的空间复杂度。另一种是自底向上的方法，直接从长度 1 开始进行每两个链表的合并，然后再进行长度为 2 的每两个链表的合并（最后一个链表长度可以不用达到这个数值），以此类推直到合成一个链表。&emsp;&emsp;外循环是子链表的长度 subLength，从 1 开始，每次翻倍，直到达到原链表大小（因此我们也需要先获取原链表长度）。而对于每个循环，则维护一个 head1，按照 subLength 的长度遍历链表进行截取（获取 head2 开始的结点之后就可以进行切断），同理也切出 head2，然后就可以调用合并两个有序链表的函数对这两个链表进行合并，然后再重新连接到原链表中。这样每两个子链表切割出来后排序再连接到原链表中，完成一次循环。完成所有的循环后完成归并排序。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 是链表的长度。我们对链表进行了归并排序，需要进行 $O(\\log n)$ 次归并，每次归并的时间复杂度是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放若干变量。"},{"title":"编译原理 复习","date":"2021-07-06T10:00:00.000Z","url":"/2021/07/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%20%E5%A4%8D%E4%B9%A0%E9%A2%98/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;这篇文章是《编译原理》课程的复习笔记，可以作为期末考试的复习资料。 编译原理 大纲 绪论编译 定义将高级语言（源语言）翻译成汇编语言或机器语言（目标语言）的过程。 词法分析（Lexical Analysis）定义扫描源程序的字符流，识别并分解出有词法意义的单词或符号（称为 token） 输入：源程序 输出：token 序列（词法单元） token 表示：&lt;类别, 属性值&gt; 保留字、标识符、常量、运算符等 将各成分按其在语言中的作用分类 例如 z=1 进行词法分析之后得到 执行&emsp;&emsp;词法分析如何执行？ 识别子串所属的 token 类别 返回 token 单元 问题：输入串具有二义性，如何进行识别？ 正则表达式（RE） Alphabet 字母表：一个有限的符号集 String 串：一个由字母表中符号组成的有限句子 Language 语言：字母表中符号组成的串的集合 &emsp;&emsp;我们需要一种规范化的语言来对 token 进行识别 —— 正则表达式 原子（atomic） $\\epsilon$（空串） 单个字符 组合形式（compound） Union（并）：$A|B=\\{s|s\\in A or s\\in B\\}$ Concatenation（连接）：$AB=\\{ab|a\\in A\\; and\\; b\\in B\\}$ Iteration（迭代）：$A^*=\\cup_{i\\geq0}A^i\\;where\\;A^i=A…A(i\\;times)$ $A^*=\\{\\epsilon\\}+A+AA+AAA+…$ $A+=A+AA+AAA+…=AA^*$ $(A)\\equiv A$：$A$ 是一个正则表达式 优先级从低到高 一些其他的表示形式 Union（并）：$A|B\\equiv A+B$ Option（选择）：$A?\\equiv A+\\epsilon$ Range（区间）：$’a’+’b’+’c’+…+’z’\\equiv[a-z]$ Excluded range（排除区间）：$[a-z]$ 的补集 $[\\hat{\\;}a-z]$ 字母表运算 Product（乘积）：$\\sum_1\\sum_2=\\{ab|a\\in\\sum_1,b\\in\\sum_2\\}$ Power（幂）：$\\sum^n=\\sum^{n-1}\\sum,n\\geq1;\\sum^0=\\{\\epsilon\\}$ Positive Closure（正闭包）：$\\sum^+=\\sum\\cup\\sum^2\\cup\\sum^3\\cup…$ Kleene Closure（闭包）：$\\sum=\\sum^0\\cup\\sum^+$ 有穷自动机（Finite Automata）定义&emsp;&emsp;自动机指一个机器或者一个程序，有穷自动机指一个状态有限的自动机。 状态转移 拥有状态结点和带标签的边 有且只有一个起点状态，有一个或多个终点状态 NFA（不确定有穷自动机） 对于给定的一个状态和一个输入可以有多个转移方向 可以空边的状态转移 可以选择转态转移的方向 DFA（确定有穷自动机） 一个状态一个输入对应一个转移方向 没有空边的状态转移 对于一个串只有唯一的状态转移路径 词法分析过程 RE 转换为 NFA 自顶向下逐步分解 Top-Down 自下而上组合法 Bottom-Up NFA 转换为 DFA 找出 $\\epsilon$ 闭包以消除 $\\epsilon$ 边 对于不确定的状态转移构造子集 使用表驱动法 DFA 的最小化 找出 DFA 中的等价类 将所有的等价类进行合并 状态数最少的 DFA 就是最小 DFA 语法分析（Syntax Analysis）定义从词法分析器输出的 token 序列中识别出各类短语，并构造语法分析树（paser tree） 输入是来自词法分析的 token 序列 输出是一棵语法分析树 不是所有输入的 token 序列都是合法的（需要进行判别） 如何表明语法？（RE/FA？它们无法表示嵌套结构） 文法（Grammar）定义系统地描述程序语言结构的语法，例如表达式和声明语句。形式化定义：由4个部分组成 $\\{T, N, s, \\sigma\\}$ $T$：终结符 构成串的基本符号 不能单独出现在推导式左边（不能再进行推导） 语法分析树中的叶子结点 $N$：非终结符 不是终结符的其他符号 $s$：开始符号 一种非终结符 $\\sigma$：产生式 指定终结符和非终结符组成串的形式 文法推导 产生式规则：LHS $\\rightarrow$ RHS，表示 LHS 可以由 RHS 构建（代替） 推导（Derivation）：一系列对于产生式规则的应用 最左推导：每次推导代替最左的非终结符 最右推导：每次推导代替最右的非终结符 句型（Sentential form）：句型可以包含终结符和非终结符（也可以为空） 句子（Sentence）：句子只包含终结符 语言（Language）：由文法产生 文法归约 文法推导的逆过程 从 RHS 归约到 LHS 分析树分析树即是使用图表示的推导过程 最左推导：从左到右建树 最右推导：从右到左建树 如果一个文法是二义性的（Ambiguity），则它可能对同一个句子产生多棵分析树。对于大多数语法分析器来说，非二义性文法是更好的。 文法类型 0 型文法：无限制文法 LHS 不能为 $\\epsilon$ 1 型文法：上下文有关文法（CSG） LHS 的长度与 RHS 相等或更短 RHS 不能为 $\\epsilon$ 2 型文法：上下文无关文法（CFG） LHS 是单独的非终结符 RHS 不能为 $\\epsilon$ 3 型文法：正则文法 LHS 是单独的非终结符 RHS 是一个终结符或者一个终结符跟着一个非终结符 由上到下具有包含关系 消除二义性 重写文法，消除二义性 使用二义性文法，但是同时需要制定非二义性的规则 如何消除二义性？ 指定优先级（Precedence） 指定结合性（Associativity） 左结合 右结合 自顶向下分析（Top-Down）特点 从根结点开始 试图将开始符号展开成为输入串 使用最左推导 递归下降分析（RDP） 带有回溯（Backtracking） 带有预测分析（Predictive parser）（向前看）【常用】 无法解决左递归问题（需要进行消除左递归） 预测分析 左递归 消除左递归 共同前缀 提取左公因子 使用 First 集 解决回溯问题 新的问题：引入了大量的新非终结符和 $\\epsilon$ 产生式 使用 Follow 集 解决空字问题 LL(k) 含义 L：从左到右扫描 L：最左推导 k：向前看 k 个符号 LL(1) 文法上面提到的构造不带回溯的自上而下的语法分析，就是 LL(1) 文法的条件。 文法不含左递归 文法中每一个非终结符的各个产生式的 First 集两两不相交 文法中每一个非终结符 A，若 $\\epsilon\\in$ First(A)，则 First(A) $\\cap$ Follow(A) 为空 表驱动分析 输入缓冲区：包含待分析的串，由 \\$ 开始 栈：保存未匹配的推导串 分析表：记录推导过程的表 分析驱动：下一步动作基于栈顶或者当前 token 其他 LL 文法 LL(0)：没有预测分析，一个非终结符只能生成一个规则，一个语言只能生成一个串 LL(2) 乃至 LL(k)：分析表的大小 $O(|N|*|T|^k)$，其中 $N、T$ 分别是非终结符和终结符的数量。 自底向上分析（Bottom-Up）特点 从叶子结点开始 试图将输入串归约到开始符号 使用最右推导的逆（也称为最左归约、规范归约） 比 Top-Down 更强大 不需要提取左因子 可以解决左递归问题 可以表达多个语言 效率更高 使用移入-归约（Shift-Reduce） 移入-归约（Shift-Reduce） 移入：将 # 右移，移入一个新符号 归约：反向应用生成式，将生成式右边归约为左边的状态 将 0 或多个符号从栈中弹出 将相应的非终结符压到栈中 接收：栈中只包含开始符号、输入缓冲区为空，完成语法分析 报错：发现语法错误，无法继续进行语法分析，调用一个错误恢复子例程 句柄（Handle） 句型的最左直接短语 每次对句柄进行归约 LR(k) 含义 L：从左到右扫描 R：最右推导的逆 k：向前看 k 个符号 LR 自动机 句柄总是在栈顶 移入-归约策略 栈顶没有句柄，进行移入 栈顶含有句柄，进行归约，变成一个非终结符 可以使用一个移入-归约分析表进行记录 可能产生冲突 如果移入和归约都合法，则产生移入-归约冲突 如果同时存在两种或以上合法的归约，则产生归约-归约冲突 LR 语法分析器使用两张表 动作表 Action[s, a]，栈顶状态是 s 而下个输入的 token 是 a 接受终结符 移入、归约、接收、报错 跳转表 Goto[s, X]，非终结符 X，栈顶状态 s 接受非终结符 增广文法（Augmented Grammar） 在开始符号 S 前面加入一个 S’ S’ $\\rightarrow$ .S 作为初始状态 S’ $\\rightarrow$ S. 作为接受状态 保证表中只有一个 acc（接受）状态 几种 LR 文法 LR(0) 只对栈顶考虑移入/归约 最弱，由于其局限性使用不多，非常容易发生冲突 SLR(1) 简单的 LR，基于 LR(0)，归约时使用 Follow 集 动作表和跳转表保持和 LR(0) 一样小 只是简单的考察下一个输入符号是否属于归约项目相关的 Follow 集 依然容易产生冲突 LR(1) 向前看一个 token 对比 LR(0) 更复杂，有更大的表 LALR(1) 向前看的 LR(1)，寻找具有相同核心的 LR(1) 项集并进行合并 根据合并后得到的项集族构造语法分析表 分析表比 LR(1) 更小 不会引入移入-归约冲突 会引入归约-归约冲突 延迟错误识别 语义分析（Semantic Analysis）定义收集标识符的属性信息，并进行语义检查，上下文相关分析。 CFG 是上下文无关的，不能分析上下文信息 语义检查包括变量需要先声明后使用、变量类型一致、表达式类型一致等等 符号表（Symbol Table）定义跟踪程序的所有符号信息的一种编译器的数据结构 记录每个符号的信息 在语义分析阶段创建 在词法分析阶段准备 在代码生成阶段使用 在生成二进制流后丢弃 程序变量（Variable） 声明（declaration）：类型和名字 定义（definition）：内存空间分配 绑定（binding）：使用定义匹配标识符 作用域（Scope）：可以绑定定义的程序区域 静态作用域：一个声明起作用的那段区域 绑定最近封闭区域的定义 拥有更少的程序错误 拥有更高效的代码 动态作用域：运行时决定 绑定当前执行中的最新定义 在运行时才进行绑定 难以直接通过观察判断 符号表信息 串：标识符名称 类型：变量、函数、结构体、类 信息 变量：类型、地址 函数：返回类型、进入地址 结构体：域内变量名、域内变量类型 类：类的符号表 维护 进入作用域 退出作用域 发现符号 添加符号 检查符号 结构符号表访问的时间影响编译前端的性能 线性表 数组：插入删除 $O(n)$，搜索 $O(n)$，没有空间浪费 链表：插入删除 $O(1)$，搜索 $O(n)$，需要额外的指针空间 二叉树 插入删除搜索均是 $O(\\log n)$，最坏情况下会退化成链表 比线性表需要更多的空间 哈希表 插入删除搜索均是 $O(1)$，当哈希冲突过多链过长时退化成 $O(n)$ 处理多个作用域栈方法 每个作用域维护一个单独的符号表 对于每个开放的作用域维护一个入口 进入一个作用域时符号表指针入栈 退出一个作用域时符号表指针出栈 缺点 因为需要查找多个哈希表，查找比较低效（所有的全局变量都在栈底） 因为需要维护多个哈希表，对内存的使用比较低效 链方法 对所有的作用域只维护一个符号表 进入一个作用域时标记一个新的嵌套层次 退出一个作用域时将该嵌套层次的所有符号删除 符号表只维护当前活跃的作用域 作用 只适用于块作用域，不适用于类作用域 退出作用域时开销较大（需要进行删除） 查找时只需要一个哈希表 存储在内存里的只是一个大的哈希表 类型检查 静态类型检查：编译时（C/C++，Java） 有一些类型错误是无法在编译时就发现的 程序需要更严格的编写规范 通常程序 bug 更少，运行时间更快 动态类型检查：执行时（Python，JavaScript，PHP） 在执行时再检查可以发现更多错误，更可取 程序无需那么严格的规范 更多的程序 bug 和更长的运行时间 语法制导翻译（Syntax Directed Translation，SDT）定义使用 CFG 来引导对语言的翻译，是一种面向文法的翻译技术 语法制导定义（Syntax Directed Definitions，SDD）定义SDD 是对 CFG 的推广，翻译的高层次规则说明 将每个文法符号和一个语义属性集合相关联 将每个产生式和一组语义规则相关联 副作用（Side effect） 一般属性值计算之外的功能 例如：代码生成、打印结果、修改符号表 属性文法（Attribute grammar） 一个没有副作用的 SDD 属性文法的规则仅仅通过其他属性值和常量来定义一个属性值 标注分析树（Annotated parse-tree） 每个结点都带有属性值的分析树 文法符号的属性 综合属性 分析树结点 N 上的非终结符 A 的综合属性只能通过 N 的子结点或 N 本身的属性值来定义 终结符可以具有综合属性 继承属性 分析树结点 N 上的非终结符 A 的继承属性只能通过 N 的父结点、N 的兄弟结点或 N 本身的属性值来定义 终结符没有继承属性 产生式中的属性依赖依赖图 依赖图决定属性值的计算 依赖图描绘了分析树的属性信息流 SDD 的求值顺序 按照属性之间的依赖关系 在对一个结点属性求值之前，必须首先求出这个属性值所依赖的所有属性值 通过依赖图的边确定计算顺序 使用依赖图的拓扑排序 非常难确定是否有循环依赖 S-属性定义 只具有综合属性 可以使用任何自底向上的顺序计算属性值 可以在 LR 分析中实现 L-属性定义 依赖图的边只能从左到右 每个属性要么是一个综合属性，要么是满足以下条件的继承属性 对于产生式 $A\\rightarrow X_1X_2…X_n$，$X_i$ 的继承属性仅依赖下列属性 $A$ 的基础属性 产生式中 $X_i$ 左边的符号 $X_1,X_2,…,X_i$ 的属性 $X_i$ 本身的属性，但不能在依赖图中形成环路 可以在 LL 分析中实现 语法制导翻译方案（Syntax Directed Translation Scheme，SDT）定义 SDT 是在产生式右部嵌入了程序片段的 CFG，这些程序片段称为语义动作 SDT 是 SDD 的补充，是具体翻译的实施方案 SDT 显式地指明了语义规则的计算顺序，以便说明某些细节 具体实现 基于预先构建的分析树 在语法分析过程中实现 S-SDD 到 SDT 的转换 将每个语义动作都放在产生式的最后 使用 LR 语法分析实现，当归约发生时执行相应的语义动作 L-SDD 到 SDT 的转换 将计算某个非终结符 A 的继承属性的动作插入到产生式右部中紧靠在 A 的本次出现之前的位置上 将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端 可以在 LL 或 LR 语法分析过程中实现 递归预测分析 综合属性：最后计算 继承属性：参数传递 非递归预测分析 扩展语法分析栈 管理属性信息 LR 分析 中间代码生成（Intermediate Code Generation）定义编译器翻译源程序并生成一些中间表示形式（Intermediate Representation，IR），再将其转化为机器代码 IR 的好处 增加程序的抽象性（比起机器代码） 前后端分离（与不同高级程序语言、不同处理器架构无关） 目标重定向 易于优化和扩展 高层 IR：更趋向高级程序语言 抽象语法树（AST） 分析树 低层 IR：更趋向集成 三地址码 静态单赋值 机器层 IR：趋向机器 x86 IR ARM IR MIPS IR 三地址码（Three-Address Code，TAC） 每个操作最多具有三个操作数 可以是变量、常量、临时变量 长表达式可以转换成多条指令 控制流，跳转 与机器无关 目标：做出更简单的与机器无关的优化 操作 二元赋值 一元赋值 拷贝 无条件跳转 条件跳转 过程调用 过程调用返回 索引 地址和指针 执行 四元式（quadruples） op arg1, arg2, result 三元式（triples） op arg1 arg2 间接三元式（indirect triples） op arg1 arg2 静态单赋值（Single Static Assignment，SSA）"},{"title":"机器学习与数据挖掘 复习题","date":"2021-07-04T10:00:00.000Z","url":"/2021/07/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%A4%8D%E4%B9%A0%E9%A2%98/","categories":[["复习资料","/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"]],"content":"前言&emsp;&emsp;这篇文章是《机器学习与数据挖掘》课程的复习题，题目由老师期末复习课时给出，基本涵盖了这门课程的所有内容，因此将题目整理如下。 1.深度学习和机器学习的区别是什么？&emsp;&emsp;机器学习是从数据模式中学习算法，然后将其应用于决策中。深度学习则是通过自己处理数据进行学习，就像人脑一样，识别、分析、做出决策。主要的区别如下： 它们向系统提供数据的方法不同。 机器学习通常需要结构化数据而深度学习网络依赖于人工神经网络的层次。 &emsp;&emsp;实际上，深度学习也是机器学习的一种，只是由于其发展迅猛，并且有很多特有的学习手段被提出，因此视为一种比较独立的学习方法。 2.监督学习与无监督学习最主要的区别是什么？&emsp;&emsp;监督学习技术需要带标签的数据来训练模型，也即我们事先分好了类别，通过带有类别标签的训练集训练模型，再用其去预测未分类的数据，将其分类到我们已有的标签类别中。而无监督学习则不需要任何带标签的数据集，机器根据样本间的相似性寻找规律，进行分类等任务。 3.在处理数据集时如何选择重要变量？&emsp;&emsp;有很多种在一个数据集中选择重要变量的方法，包括以下几点 在确定重要变量之前不考虑无关变量。 Lasso 回归（L1 回归）。 随机森林。 基于可用特征集的信息增益选择特征。 4.现在有很多的机器学习算法。如果给定一个数据集，我们如何决定使用的算法？&emsp;&emsp;机器学习算法只决定于给定数据集的数据类型。如果数据是线性的，则我们选择线性回归算法；如果数据是非线性的，则我们选择袋装算法（Bagging）或者核算法（Kernel）会更优；如果是出于商业目的分析或解释数据，则我们可以使用决策树或者是支持向量机；如果数据集由图片、视频、音频组成，则使用神经网络算法更优。 5.正则化在机器学习中什么时候起作用？&emsp;&emsp;当模型开始出现过拟合时，正则化变得很有必要。它将系数估计向 0 转移或者正则化，是一种回归。它降低了模型的适应性，避免模型学习陷入过拟合的风险，模型预测的结果更优。 6.数据方差大是好是坏？&emsp;&emsp;方差越大，意味着数据范围越广，数据特征更多样，通常来说，方差大意味着结果不好，离散程度过大，可能存在过拟合现象。 7.数据集方差过大如何解决？&emsp;&emsp;如果数据方差过大，我们可以采用 Bagging 算法解决。Bagging 算法对数据进行重复随机采样，将数据分为多个子训练集，对于每个子训练集采用学习算法得到各自的弱学习器。如果是分类任务则各个分类器分别对测试数据投票，得票最多的类别作为输出的最终类别，如果是回归任务则各个弱学习器的回归结果进行算术平均得到最终的输出结果。我们对多个弱学习器求平均，可以减少模型的方差，提升模型的稳定性。 8.随机梯度下降（SGD）和梯度下降（GD）的区别是什么？&emsp;&emsp;梯度下降和随机梯度下降都是用于找到使得损失函数最小的参数集的方法。不同点在于梯度下降对于每一组参数都对所有的训练样本进行评估，在权值更新前汇总所有样例得到标准梯度；而随机梯度下降则仅仅对某个随机训练样本进行评估。&emsp;&emsp;因此通常来说，标准梯度下降的时间复杂度更高；由于得到的梯度是来自所有训练样本的标准梯度，则它的步长一般更长；对于某些含有多个局部最小值，标准梯度下降更可能陷入局部最小值中。 9.决策树的优点和缺点是什么？&emsp;&emsp;优点： 分类准确率高，易于解释 计算量相对较小 不需要任何的参数假设 对异常值不敏感，鲁棒性较强 需要调整的参数较少 &emsp;&emsp;缺点： 容易陷入过拟合 对于各类别样本数量不一致的数据, 信息增益偏向于那些更多数值的特征 容易忽略属性之间的相关性 10.什么是混淆矩阵？为什么要用到混淆矩阵？&emsp;&emsp;混淆矩阵常用于说明分类模型的性能，呈现出可视化的结果，通常用于监督学习。混淆矩阵每一行代表实际类别，每一列代表预测结果。正确和错误的分类结果数量都统计在对应的表格中。我们可以根据这些结果对分类器的性能做出总结。 11.解释“维数灾难”的概念。&emsp;&emsp;维数灾难是指数据拥有过多的特征。如果我们的特征数多于观察值，可能有过拟合的风险。而且过多的维数会导致数据集中的每个观察值与其他所有观察值的距离相等，无法形成有意义的聚类。&emsp;&emsp;降维技术可以用来解决维数灾难的问题，比如 PCA 技术。 12.正则化和归一化的区别是什么？&emsp;&emsp;归一化调整的是数据，而正则化调整的是预测函数。如果数据的规模过大，则需要进行归一化，把数据转化为 [0, 1] 之间的小数，消除不同数据间的量纲，方便数据进行比较和处理。而正则化则是利用先验知识，在预测函数中加入正则因子，可以有效降低模型复杂度，防止出现过拟合现象，提高模型稳定性。 13.归一化和标准化的区别是什么？&emsp;&emsp;归一化是将数据重新缩放到 [0, 1] 的范围，方便与其他数据进行比较或处理。而标准化是将数据缩放到均值为 0 方差为 1 的状态，为了方便数据的下一步处理。 14.回归和分类的区别是什么？&emsp;&emsp;分类和回归都是监督机器学习的一种类别。回归的输出是连续的（实数），而分类的输出是离散的（类别）。 15.哪种机器学习算法被称为“惰性学习”？为什么？&emsp;&emsp;KNN 算法是典型的惰性学习算法，也叫消极学习方法。积极学习方法是指在利用算法进行判断之前，先用训练集训练得到一个目标函数，在需要进行决策时可以利用已经训练好的目标函数进行预测。而消极学习算法则是单纯对训练集进行存储，不会进行主动学习或者拟合出一个函数，在需要进行预测的时候再根据已有的样本做出判断。如 KNN 算法，在需要预测的时候再从训练集样本寻找与待预测样本最相似的样本进行预测（也即 K 个近邻）。 16.K-Means 和 KNN 算法的区别是什么？&emsp;&emsp;KNN 是监督学习算法而 K-Means 是无监督学习算法。KNN 是通过样本的最近邻预测样本的标签，解决分类或者回归任务。K-Means 则应用于聚类任务，所给的数据集是不带有标签的，最终是要通过数据的特征将其分为 K 个类别。 17.什么是 SVM 算法的核技术？&emsp;&emsp;核方法是应用于数据点的数学函数，可以找到两个不同类别之间的分类边界。基于不同的核函数选择，如线性的或者是放射状的，根据数据的分布，一个核函数就可以建立一个分类器。 18.什么是集成模型？解释为何集成技术与传统的分类机器学习算法相比拥有更好的学习效果？&emsp;&emsp;集成技术是一组用于分类或者回归任务的预测模型。集成学习可以提升机器学习的效果，因为它结合了多个模型，比起单个模型拥有更好的预测效果。可以降低模型的方差、偏差，也不容易导致过拟合。 19.什么是过拟合和欠拟合？为什么决策树算法经常会发生过拟合问题？&emsp;&emsp;过拟合是指一个统计模型或者机器学习算法捕获了数据过多的噪声，导致过度拟合训练集属性而泛化性能较差。欠拟合则是指一个模型或者机器学习算法拟合数据的程度较差，因此导致模型的偏差较大，不能很好地拟合数据。&emsp;&emsp;在决策树里，树会被设计去拟合所有的训练数据集样本，产生具有严格规则的分支，或者是稀疏数据的分支，最终就会导致过度拟合训练集的样本，而不能够很好地预测不属于训练集的样本。 20.解释 Lasso 和 Ridge 的区别。&emsp;&emsp;Lasso（L1）和 Ridge（L2）都是回归技术中为了找到最佳解的惩罚系数。Ridge 中惩罚函数被定义为系数的平方和，而 Lasso 则定义为系数的绝对值之和。另一种回归方法则是弹性网络回归，它结合了 Lasso 回归和 Ridge 回归。 21.概率和似然的区别是什么？&emsp;&emsp;概率是对一个事件发生的可能性的度量。比如抛一枚硬币 20 次，正面向上 15 次的可能性有多大？这就是一个概率的问题。而似然函数则是描述在参数空间中获得观测数据概率参数的函数。比如抛一枚硬币 20 次，其中 15 次正面向上，问这个硬币均匀（正反面朝上概率为 50%）的可能性有多少？这就是个似然问题。&emsp;&emsp;所以概率依附于可能的结果，而似然依附于结果的假设。 22.为什么要进行剪枝操作？&emsp;&emsp;决策树进行剪枝可以减少树的大小，降低复杂度并降低发生过拟合的可能性。剪枝的操作是将决策树的某个分支转化为叶子结点并移除原始分支中的叶子节点。可以在划分结点前执行，称为预剪枝；或者是构建好再进行剪枝，称为后剪枝。 23.应该选择模型准确度还是模型性能？&emsp;&emsp;如果模型性能指的是模型的运行速度的话，则模型的性能要求取决于未来的应用要求，对于任何实时应用场景都需要较高的运行速度，是模型一个重要的指标。&emsp;&emsp;模型性能也可能意味着模型的准确性不是最重要的属性。实际上，对于不平衡数据集中，模型的 F1 值是比模型准确度更受商业案例青睐的评判标准。 24.对于不平衡数据集如何处理？&emsp;&emsp;抽样技术可以用于解决数据集不平衡的问题。有两种采样技术，分别为欠采样和过采样。&emsp;&emsp;欠采样中，我们减少了大规模数据类型的采样，使得模型对小规模的数据较敏感。但是欠采样也可能导致大规模数据中的一些重要信息被忽视。如果是进行多次欠采样，分别训练出模型再进行集成，可以提高大规模数据中各个数据被采样的几率，但是同时带来一个新的问题，小规模数据在多次采样中反复使用，可能造成过拟合。&emsp;&emsp;过采样中，我们是对小规模的数据类型进行多次采样，这样不会导致大规模数据类型中的重要信息丢失，但是很明显的，我们有陷入过拟合的风险。 25.说说为什么特征工程在模型构建中很重要？&emsp;&emsp;初始数据是未经过加工的。特征工程提取了数据特征并将其应用到算法中。如果拥有了关键特征，算法的复杂度就可以降低，能够让一个不太理想的算法也能够拥有不错的准确性。&emsp;&emsp;特征工程有两个目标： 准备合适的输入数据集，使之与机器学习算法的约束条件相兼容。 提升机器学习模型的效果。 26.Boosting 和 Bagging 的区别是什么？&emsp;&emsp;Boosting 和 Bagging 都是集成技术的变体。 Bagging 是一种用来减少方差的算法，在高方差的算法中发挥作用。如果分类器稳定，则集成分类器的误差主要由基分类器的偏差引起。如决策树就是分类器中一种容易产生高偏差的分类器。 Boosting 对样本进行操作获得多个样本子集并通过训练得到多个弱分类器，这些弱分类器加权融合共同构成一个强分类器（权重来自它们分类的准确率），每个弱分类器都可以补偿其分类器的缺点。Boosting 算法可以减少监督学习中的模型偏差。 27.生成式模型和判别式模型的区别是什么？&emsp;&emsp;两种模型都是应用于监督学习的模型。&emsp;&emsp;生成式模型学习联合概率分布，通过贝叶斯理论预测条件概率，显式地对每个类的分布进行建模。例如对于猫狗分类问题，通过学习建模猫和狗的模样，再进行分类。&emsp;&emsp;判别式模型学习条件概率的分布，寻找模型中各类别的边界。例如对于猫狗分类问题，只需要学习两者之间的差异，比如狗的体型通常比猫更大。 28.什么是超参数？和普通参数有什么区别？&emsp;&emsp;参数是模型内部的变量，通过训练数据进行估值，并作为模型的一个部分保存。典型的参数有权重参数等等。&emsp;&emsp;超参数则是模型外部给定的变量，不通过数据学习得到。超参数可以用于模型参数的评估，超参数的选择对模型的完成效果很重要。典型的超参数有模型的学习率，隐藏层的数量等等。 29.聚类算法中如何确定聚类的数量？&emsp;&emsp;聚类的数量可以通过寻找轮廓系数确定。若 $a$ 表示样本点与同一簇中所有其他点的平均距离，即样本点与同一簇中其他点的相似度，也即聚类的凝聚度；$b$ 表示样本点与下一个最近簇中所有点的平均距离，即样本点与下一个最近簇中其他点的相似度，也即不同聚类的分离度。则轮廓系数 $s$ 的定义如下： s=\\frac{b-a}{max(a,b)}&emsp;&emsp;则我们可以知道轮廓系数的取值为 $[-1,1]$，越接近 1 表示组内差异小而组间差异大，聚类效果越好。相反越接近 -1 则聚类效果越差。我们可以通过比较不同聚类数量分类后的轮廓系数确定聚类数量。 30.交叉验证的作用是什么？&emsp;&emsp;交叉验证是用于提升机器学习算法性能的技术。将训练样本随机划分为大小相同的几个部分，每次将一个部分作为测试集而其他部分作为训练集进行训练。如此多次训练模型并进行验证。通过交叉验证可以获得模型更好的性能评估，得到更加稳定可靠的模型。 31.KNN 的距离度量有哪些？&emsp;&emsp;以下的几种距离度量都可以用于 KNN 算法： 曼哈顿距离 闵可夫斯基距离 杰卡德距离 余弦距离 32.随机森林使用的集成技术是什么？&emsp;&emsp;随机森林中用到的集成技术是 Bagging。随机森林是对原始数据集样本进行处理的树的集合，最终的预测是所有树的投票的算术平均值。 33.信息熵和信息增益的区别是什么？&emsp;&emsp;信息熵指信息的混乱程度 $H(X)=-\\sum_{x\\in\\chi}p(x)\\log p(x)$，而信息增益是指数据集在某项属性上被分割后信息熵的减少。在决策树算法中，我们会选择信息增益最大的属性作为分割的属性。 34.列举一些使用 SVM 而不是随机森林的情况。&emsp;&emsp;如果问题是线性不可分的，则需要使用非线性核的 SVM，比如 RBF 核。另外一种情况是在更高维的空间里也需要使用 SVM 算法，例如在文本分类任务中使用 SVM 算法更优。 35.SVM 作为一种最大间隔分类器，是否会被异常值影响？&emsp;&emsp;当 C 很大的时候会受到影响。 36.我们能否在逻辑回归中使用核函数？&emsp;&emsp;逻辑回归在计算上比 SVM 复杂得多（$O(N^3)$ 的复杂度对比 $O(N^2k)$ 的复杂度，其中 $k$ 是支持向量的个数）。SVM 方法只考虑与分类相关的少数点，也即支持向量，而逻辑回归考虑的是所有的点，但是通过非线性映射减少离平面较远的点的权重。这使得 SVM 可以使用一些高效的代码编写模块加速，而逻辑回归却很难这样做。 37.SVM 是否有概率性的输出？&emsp;&emsp;SVM 不会直接提供概率性的评估。概率性的输出是通过一个昂贵的五折交叉验证得到的。 38.区分贝叶斯风险和经验风险。&emsp;&emsp;贝叶斯决策函数 $f^*:x\\rightarrow A$ 是对所有可能函数的风险最小化，贝叶斯决策函数的风险就是贝叶斯风险。贝叶斯决策函数通常称为目标函数，因为它是我们能够得到的最好的决策函数。&emsp;&emsp;而经验风险函数 $f:x\\rightarrow A$ 的定义如下 R_n(f)=\\frac{1}{n}\\sum^n_{i=1}l(f(x_i), y_i)&emsp;&emsp;它是所有训练样本的损失函数的平均值，反映了模型对样本的预测能力。经验风险最小化也即对训练集中的所有样本点损失函数平均最小化。 39.什么是拉格朗日乘数？&emsp;&emsp;在数学最优问题中，拉格朗日乘数法是一个在同等约束条件下计算局部最大值和最小值的方法。主要的思想是将一个约束问题转化为一个可以求导的无约束问题。拉格朗日对偶函数给定了最优解的下界。 40.随机森林的随机性如何体现？&emsp;&emsp;当随机森林中的任一棵树建立时，我们为了确保树独立，用了以下两种随机性质： 通过 Bagging 算法随机选择数据进行替换。 随机选择 $m$ 个特征。 41.为什么随机森林不容易导致过拟合？&emsp;&emsp;随机森林是决策树的集成模型。单棵决策树对数据异常非常敏感，非常容易拟合了数据中的噪声，所以只有一棵树的随机森林同样容易导致过拟合。而当我们添加多棵树到随机森林中，整片森林对于异常值就不会那么敏感，过拟合的可能性就会降低。然而泛化误差不会趋向 0，因为泛化误差中的方差会随着树的增加会逐渐趋于 0，偏差却不会。 42.说说深度学习模型和集成模型之间的联系。&emsp;&emsp;深度学习模型中诸如 CNN 和 Transformers 在集成策略中也有广泛应用。 43.集成分类器可能不会比它的任何一个单模型更精确，这句话是对的吗？为什么？&emsp;&emsp;这句话是对的。通常来说，集成模型确实可以提高模型的性能，但并不是绝对的。"},{"title":"Leetcode 146.LRU 缓存机制","date":"2021-07-03T15:21:00.000Z","url":"/2021/07/03/Leetcode%20146.LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例： 提示： $1 &lt;= capacity &lt;= 3000$ $0 &lt;= key &lt;= 3000$ $0 &lt;= value &lt;= 10^4$ 最多调用 $3 * 10^4$ 次 get 和 put 链接： 题目分析&emsp;&emsp;LRU 也即 Least Recently Used，最近最少使用。顾名思义，最近最少使用的结点会从缓存删去，那么怎么判断哪个结点是最近没有被使用到的呢？我们可以维护一个双向链表作为缓存，越靠近头部表示上一次被使用的时间越近，如果一个结点被使用，就将其移动到链表头部（没有则也是添加到头部），而如果缓存区已满，则删除链表末尾的结点。而我们怎么快速找到结点呢？题目说明了每个结点具有不同的关键字，则我们可以使用一个哈希表来存储结点的指针。所以我们采用的是一个双向链表加一个哈希表的数据结构。（PS：为什么要使用双向链表而不是单向链表呢？因为我们需要频繁地从链表中删除结点（包括移动操作和删除操作），使用双向链表才可以在定位后对前后进行连接操作。）&emsp;&emsp;从实现的细节上来说，我们经常操作的是链表的头结点和尾结点，为了避免多次判定链表是否为空（链表为空时添加的新结点既是头结点也是尾结点），我们使用了两个哨兵结点，分别作为伪头部和伪尾部。&emsp;&emsp;各操作的作用已经包含到代码的注释中。 &emsp;&emsp;时间复杂度：$O(1)$。哈希表的查询是 $O(1)$ 的，各项操作也都是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(capacity)$。我们需要建立哈希表和双向链表，他们的最大大小都是 $O(capacity)$ 的。"},{"title":"Leetcode 142.环形链表 II","date":"2021-07-03T13:37:00.000Z","url":"/2021/07/03/Leetcode%20142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶：你是否可以使用 O(1) 空间解决此题？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目范围在范围 $[0, 10^4]$ 内 $-10^5 &lt;= Node.val &lt;= 10^5$ pos 的值为 -1 或者链表中的一个有效索引 链接： 题目分析&emsp;&emsp;这道题是 Leetcode 141.环形链表 的进阶，在判断链表是否有环的基础上还需要返回环的开始结点。我们在那道题中采用的是快慢指针的做法，这道题应该可以使用的方法，但是我们需要解决一个问题：怎么获得环开始的结点？我们知道，快指针的速度是慢指针的两倍，而它们是同时出发的，则快指针走的路程也是慢指针的两倍。我们分析它们走过的路程是什么样的。如下图所示。蓝色的点是它们的相遇点。 &emsp;&emsp;则我们可以知道，快指针走过的路程应该是 $a+n(b+c)+b$，而慢指针走过的路应该是 $a+b$。而快指针走过的路程是慢指针的两倍，则我们可以得到下面的等式 a+n(b+c)+b=2(a+b)&emsp;&emsp;通过变换我们可以得到 $a=c+(n-1)(b+c)$，则我们可以发现，在快慢指针的相遇点出发，走 c 步就刚好到了环的入口，而链表头部到环入口的距离（也即 a），就是从相遇点到环入口加上 n-1 个环（也即 b+c）的距离。则我们可以在快慢指针相遇后，令一个新的指针从 head 出发，与慢指针同时前进，经过了 a 的单位时间后，他们的相遇点就是环的入口。&emsp;&emsp;需要注意的是，当时在做前一道题的时候，我们使用的是 while 循环，让快慢指针先走了一步，它们的出发点不是 head，因此他们的相遇点也不会是上面分析的那样。这道题我们使用了上一道题提到过的 do-while 循环，将出发点修改为 head。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为链表的长度。我们知道快慢指针相遇所需要的时间是 $O(n)$，而相遇后慢指针和新指针走的路程为 a，也不会超过 $n$。因此复杂度仍然是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要三个指针的空间。"},{"title":"Leetcode 141.环形链表","date":"2021-06-29T16:20:00.000Z","url":"/2021/06/30/Leetcode%20141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中节点的数目范围是 $[0, 10^4]$ $-10^5 &lt;= Node.val &lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 链接： 题目分析&emsp;&emsp;这道题也是一个典型的题目，可以使用快慢指针解决。我们知道，如果链表中存在环，则按照链表的顺序走，最终会在环里面一直转圈。所以如果按照链表顺序走能够走到终点（走到 nullptr）则说明链表不存在环。而如果我们使用两个指针同时在链表中行走，快指针一次走两步，而慢指针一次走一步，则如果存在环，快指针会比慢指针先进入环中并开始转圈，当慢指针也进入环后，它们会在环中的某一个节点相遇，此时快指针“套”了慢指针若干圈。（为什么一定会相遇？因为它们的速度差是 1，则每一次前进，它们之间的步数差增加 1，而当它们同时处于环中并且步数差是环长的整数倍时，它们就相遇了）因此如果快慢指针相遇，则说明存在环。&emsp;&emsp;一些细节：快指针一次走两步，在走之前需要判断 fast 和 fast-&gt;next 是否为空，避免非法访问。为空时其实也说明不存在环，可以直接返回 false。出发时，快指针在 head-&gt;next 而慢指针在 head，这是由于我们循环的终止条件是两个指针相遇，如果它们的出发点是相同的则不会进入循环。其实我们也可以理解为它们是在 head 之前才是起跑线，第一次行走时慢指针到 head 而快指针已经到了 head-&gt;next，如果使用一个 do-while 循环则可以从 head 起跑。由于它们在同一位置起跑，如果链表不存在环，则快指针一定先于慢指针到达终点，因此退出条件只设置快指针即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为链表的长度。当不存在环时，快指针到达终点就结束，每个结点至多被访问两次；当存在环时，至多行走了 $n$ 步慢指针就会进入环，而两个指针都进入环之后，至多行走 $n$ 步快慢指针就会相遇。因此复杂度都是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个指针的空间。"},{"title":"Leetcode 139.单词拆分","date":"2021-06-29T15:26:00.000Z","url":"/2021/06/29/Leetcode%20139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 示例 2： 示例 3： 链接： 题目分析&emsp;&emsp;字典中的单词不会重复，并且可以重复使用，我们可以考虑使用一个哈希表存储这个字典。而对于字符串 s，我们用动态规划的思想，dp[i] 表示 s 的前 i 个字母 s[0 ~ i-1] 是否可以使用字典中的单词表示，则我们知道，如果 dp[j] 为真，并且 s[j ~ i-1] 刚好是字典中的一个单词，则 dp[i] 也为真。而 dp[0] 作为起始条件，表示空串的结果为真。对于每一个 dp[i]，我们都要遍历 dp[0] ~ dp[i-1]，寻找以这个位置分割是否符合条件，一旦符合条件则可以置为真并提前退出遍历。遍历所有的 dp[i] 之后，我们的答案就是 dp[s.size()]。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 为字符串的长度。动态规划的状态数为 $n+1$，而对于每个状态最多都要枚举 $O(n)$ 个分割点，其实也即双层遍历，时间复杂度为 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(n+k)$，其中 $n、k$ 分别为字符串的长度与字典的大小。动态规划数组大小为 $n+1$，而哈希表大小为 $k$。 &emsp;&emsp;PS：这道题还存在优化空间，比如如果字典中的单词量较少，内层循环也可以设计成匹配字典中每个单词的形式；比如可以进行剪枝，内层循环中分割的位置无需从 0 开始，可以从字典中最长的单词长度作为右半部分开始。"},{"title":"Leetcode 136.只出现一次的数字","date":"2021-06-29T13:49:00.000Z","url":"/2021/06/29/Leetcode%20136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","tags":[["C++","/tags/C/"],["位运算","/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 非空 整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;很经典的一道题，以前已经做过，知道这道题的骚套路，这里需要用到的是位运算中的异或运算。首先异或运算有以下几个特点 一个数与 0 异或还是它本身，也即 $0\\oplus a = a$。 一个数与本身异或的结果为 0，也即 $a\\oplus a = 0$。 异或运算满足交换律与结合律，也即 $a\\oplus b = b\\oplus a$，$a\\oplus(b\\oplus c)=(a\\oplus b)\\oplus c$。 &emsp;&emsp;在这个题目中，有一个数字出现了一次，其他数字都出现了两次。如果我们将 0 与所有的数字异或一次，则出现了两次的数字得到的结果会变为 0，最后留下的就是 0 与出现了一次的那个数字的异或结果，也即留下的就是只出现了一次的那个数字。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们遍历了一次数组。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要使用一个变量记录异或结果。 &emsp;&emsp;如果没有这么骚的解法，其实也有很多其他需要额外空间但仍然是线性时间复杂度的解法，比如维护一个哈希表记录每个数字出现的次数；或者是将未在哈希表中的数字加入，而已经存在的数字删除，最后留下的也是那个只出现了一次的数字；或者利用元素和，分别记录出现的数字以及数组的数字和，这个和再加上那个只出现过一次的数字得到的结果应该是所有出现过的数字和的两倍。"},{"title":"Leetcode 128.最长连续序列","date":"2021-06-29T13:18:00.000Z","url":"/2021/06/29/Leetcode%20128.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"],["set","/tags/set/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？ 示例 1： 示例 2： 提示： $0 &lt;= nums.length &lt;= 10^4$ $-10^9 &lt;= nums[i] &lt;= 10^9$ 链接： 题目分析1.Set&emsp;&emsp;阅读示例后发现，题目所说的连续序列只需要数字的值连续，而不需要在数组中相对有序，更不需要连续出现，则某个数在数组中只有 “存在” 与 “不存在” 两种状态，它的个数、位置都是没有影响的，我们可以考虑使用一个 set 容器来存放这些数，这样在存放的时候就可以同时进行排序。&emsp;&emsp;存放所有的数后，我们只需要对 set 进行一次遍历，每次寻找数字的值是否连续，并维护一个 count 进行计数，一旦不连续则重置，寻找下一个连续序列，与此同时记录最大的序列长度即可。代码中的 result 用于存放最大序列长度（也即结果），count 用于序列长度计数，pre 用于存放遍历的上一个值（用于比较）。重置的时候是重置为 1 （也即已经算上当前的这个数）。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 为数组的大小。我们遍历了一次数组存入 set 容器中，每一个数的存入需要 $O(\\log n)$，再遍历一次 set 找到答案。&emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们需要一个 set 容器来存放数组中出现的所有数字，最大的大小为 $n$。 &emsp;&emsp;PS：进阶要求的时间复杂度是 $O(n)$，但是我看了官方题解仍然觉得是 $O(n\\log n)$，并没有更好的算法了吧。看了官方题解的评论，大概是说最优情况下是 $O(n)$，那倒确实。&emsp;&emsp;PPS：所以好像直接对原数组排序一遍再遍历更省事更快，还不需要那么多的额外空间…&emsp;&emsp;PPPS：发生了非常魔幻的事情，8月4日的这一天重新看这道题，发现官方题解和我之前看的不一样了，但是又是发布于2020年的题解，就好像做梦一样。这道题确实是存在 $O(n)$ 的解法的。 2.哈希表&emsp;&emsp;如果我们使用哈希表来存储这些数字，然后再遍历哈希表进行查找，每次查找的时候，如果这个数是连续序列的第一个数（也即其减一不存在于哈希表中），我们就查找这个连续序列的长度。而查找哈希表中是否存在某个数的复杂度是 $O(1)$，则我们遍历的时间复杂度为 $O(n)$。如此遍历完哈希表就可以获得所有的连续序列长度了。当然，我们只需要记录下最长的那个长度。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们遍历了一次数组存入哈希表中，所需时间复杂度为 $O(n)$。然后哈希表中的每个数字被遍历两次，一次为外层遍历时，一次是作为连续序列中的一个数被遍历一次（每个连续序列只会在第一个数进入内循环时被遍历，有且仅有一次），因此时间复杂度也是 $O(n)$。&emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的大小。我们需要一个哈希表来存放数组中出现的所有数字，最大的大小为 $n$。"},{"title":"Leetcode 124.二叉树中的最大路径和","date":"2021-06-29T07:31:00.000Z","url":"/2021/06/29/Leetcode%20124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 示例 2： 提示： 树中节点数目范围是 $[1, 3*10^4]$ $-1000 &lt;= Node.val &lt;= 1000$ 链接： 题目分析&emsp;&emsp;由于同一个节点在一条路径序列中至多出现一次，则某条路径中有且只有一个根结点，既可以是根结点作为路径端点，也可以是根结点连接来自左右子树的两个子路径。我们可以这样考虑，当一个结点作为根结点时，最大路径和即为左右子树中的最大子路径和（不超过 0 可以不要）加上结点本身的值。这样的话这个定义是递归的，结果应该可以通过递归遍历所有结点得到。&emsp;&emsp;但是存在着一个问题，我们需要计算的结果是一个结点连接左右子序列形成的序列和，而我们递归需要调用的子序列只能是以根结点作为端点的序列。如示例2，以结点 20 作为根结点的最大序列和是 [15, 20, 7]，但是当我们计算结点 -10 时，来自右子树 20 的子序列只能是 [20, 15] 或者是 [20, 7]。如果解决这个不同呢？由于我们要求的只是所有序列和中最大的那个，则我们可以使用一个全局变量存储最大序列和，而递归函数的返回值则是以这个结点为端点的最大序列和，以提供给上层函数使用。&emsp;&emsp;需要注意的是，结点值可以为负数，且必须至少选择一个结点，则有可能最终的最大路径和是负数，因此 result 的初始值需置为 INT_MIN 而不是 0。另外一个注意的点上面也已经提到，我们不一定要连接左右子序列，如果最大的左右子序列是负数的话，我们可以选择不连接。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。递归的最大深度为 $n$。 官方题解&emsp;&emsp;与我的代码有一点小小的不同（PS：第一次困难题（PPS：这题其实有点简单不像是困难题）自己有思路，在完全没看官方题解的前提下居然写出了几乎一样的代码，连全局变量的使用也一样，有点神奇），官方题解在计算 left 和 right 的值时就已经与 0 进行比较，下面更新 result 和函数返回值的时候就无需进行比较。在我的代码里，left 和 right 表示最大子序列和，可以为负数；在官方题解里，它们表示的含义变成了子树的 “贡献度”，如果子序列和为负数则不进行连接，贡献度为 0。 "},{"title":"Leetcode 121.买卖股票的最佳时机","date":"2021-06-25T19:02:00.000Z","url":"/2021/06/26/Leetcode%20121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 示例 2： 提示： $1 &lt;= prices.length &lt;= 10^5$ $0 &lt;= prices[i] &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;卖股票需要在买股票之后，如果我们卖股票的那一天为 i，则需要在 [0 ~ i-1] 天买入股票，买入股票的价格越低越好。我们可以动态维护一个 min 表示当前的最低价格，而当天卖出股票能赚的钱也即 prices[i] - min，如果 prices[i] 比 min 更小则可以更新 min 值。遍历数组得到 prices[i] - min 的最大值即可。这也算是一种动态规划的思想吧。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是 prices 的大小。我们进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 114.二叉树展开为链表","date":"2021-06-25T15:15:00.000Z","url":"/2021/06/25/Leetcode%20114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你二叉树的根结点 root ，请你将它展开为一个单链表。 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？ 示例 1： 示例 2： 示例 3： 提示： 树中结点数在范围 [0, 2000] 内 -100 &lt;= Node.val &lt;= 100 链接： 题目分析1.前序遍历&emsp;&emsp;如果先不考虑进阶的要求，我们可以直接按照先序遍历的顺序遍历一次二叉树，将其所有结点逐一添加到数组中，然后再逐一进行连接。（如果采用迭代的方法遍历二叉树则还可以边遍历边连接） &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历一次二叉树，重新连接了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们需要一个大小为 $n$ 的数组存放二叉树结点。 2.寻找前驱结点&emsp;&emsp;进阶的要求如何达到呢？我们如果能够直接在原树进行连接，则不需要额外空间。最终的树是按照前序遍历的顺序逐一连接到右子树中的，而前序遍历的顺序是 [根结点 左子树 右子树]。如果当前结点左子树为空，则与最终结果一样，无需进行操作。如果当前结点左子树不为空，则当前结点右子树应该是在左子树访问完毕后才进行访问，这个时候，右子树的前驱结点应该就是左子树的最右叶子。我们寻找到这个前驱结点，并将当前结点的右子树作为前驱结点的右子树连接，同时将当前结点的左子树变为右子树。如此处理所有的结点。&emsp;&emsp;如下面例子（第一棵树）所示，1 有左子树，我们找到左子树的最右叶子 4，并将 1 的右子树 [5, 6] 连接到 4 之后，如第二棵树所示。然后再将左子树根结点 2 变为 1 的右子树，如第三棵树所示。这个时候就处理好了 1 这个结点，接下来以同样的流程处理 2 这个结点。如第四第五颗树所示。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对于每个结点都需要访问一次进行处理，而寻找前驱结点的过程中每个结点至多被访问一次。&emsp;&emsp;空间复杂度：$O(1)$。这个算法为原地算法，我们只需要常数的空间存放若干变量。"},{"title":"Leetcode 105.从前序与中序遍历序列构造二叉树","date":"2021-06-25T05:50:00.000Z","url":"/2021/06/25/Leetcode%20105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。 注意：你可以假设树中没有重复的元素。 例如，给出 返回如下的二叉树： 链接： 题目分析1.迭代&emsp;&emsp;我们知道，在前序遍历中，结点的顺序按照 [根结点 左子树 右子树] 的顺序排列。则在连续的两个结点之间的关系只有两种情况，一种是后面结点是前面结点的左孩子，一种是后面结点是前面结点本身或者某个祖先的右孩子。而这两情况，可以通过中序遍历加以区分。中序遍历中，结点的排列是按照 [左子树 根结点 右子树] 进行排列的，若是第一种情况，则两种遍历的顺序相反，第二种情况则相同。并且第二种情况中是哪个祖先的右子树呢？其实就是前序遍历和中序遍历不再相反的那一个结点，也即局部的根结点。结合这样的数据特点，我们选择栈这种数据结构。栈中存放的结点是 还没考虑过右孩子的结点。&emsp;&emsp;我们使用一个 inorderIndex 来表示当前中序遍历的下标。我们按前序遍历的顺序作为循环，前序遍历的第一个结点就是根结点，加入到栈中。开始检查栈顶结点是否是当前中序遍历的结点，如果不是，也即意味着是第一种情况，前序遍历到的结点是栈顶结点的左孩子（这个左孩子会比栈顶结点更早出现于中序遍历中，因此栈顶结点不会是当前中序遍历的结点），连接到树中，并将其入栈；如果是，则说明是第二种情况，这个时候我们要找到是哪个祖先的右孩子，开始出栈，同时中序遍历下标也开始右移，不断比对直到栈为空或者栈顶结点不再是中序遍历的结点，则说明该结点是栈顶结点的右子树了。上面说的两种情况可能有点复杂，我们用下面的树进行理解。 &emsp;&emsp;中序遍历的第一个数字是 4。前序遍历中 1 为根，2 是第一种情况，也即是 1 的左孩子（可以采用反证法，如果不是，则 2 只能为 1 的右孩子，且左孩子为空，这个时候中序遍历一定是 1 开始的）。同理，在前序遍历遇到 4 之前的所有数字都要入栈，也即栈中为 [1, 2, 3, 4]。&emsp;&emsp;遇到 4 之后，我们可以知道，4 是最左的孩子了。那么前序遍历的下一个数字 5 是哪个祖先的右孩子呢？在中序遍历中，这个祖先的右孩子是比祖先的祖先更早出现的（因为他们在祖先的祖先的左孩子中），因此我们找到中序遍历中比栈更早出现的结点即可。我们将 4 出栈；inorderIndex 右移，栈顶为 3，中序遍历也为 3，继续出栈；栈顶为 2，中序遍历为 2，继续出栈；栈顶为 1，而中序遍历为 6。这个时候，我们可以知道，6 就是在 2 的右孩子中了（2 是祖先，1 是祖先的祖先，6 所在的子树比 1 更早出现，是 2 的右孩子）。而前序遍历到的结点 5 就是 2 的右孩子的根（前序遍历的根最早出现），所以可以直接将其连接到 2 的右孩子中，然后将 5 入栈。&emsp;&emsp;这个时候的栈是 [1, 5]。又可以继续上面的过程，6 不是 5，是第一种情况，也即 5 的左孩子，连接并入栈。重复以上的过程就可以得到最终的答案。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对前序遍历和中序遍历都进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。栈的最大元素个数为 $n$。 2.递归&emsp;&emsp;我们知道，前序遍历的结构是 [根结点, [左子树的前序遍历], [右子树的前序遍历]]，中序遍历的顺序是 [[左子树的中序遍历], 根结点, [右子树的中序遍历]]。可以发现，他们的定义是递归的，并且这三块中的内容也具有对应关系，左子树的前序遍历和中序遍历构造的树就是根结点的左子树，右子树同理。因此我们应该可以使用一个递归函数解决这个问题。&emsp;&emsp;递归的关键就是找到这三块内容的分界线。很容易可以想到利用根结点进行划分。前序遍历的第一个结点就是根结点，而我们在中序遍历中就可以根据根结点的值找到根结点的位置，划分好中序遍历后，再根据左子树序列的长度，可以划分前序遍历。为了提升寻找中序遍历中根结点的位置速度，我们给中序遍历建立了一个值和结点位置对应的哈希表。&emsp;&emsp;递归函数的返回值是一棵树，我们利用根结点新建结点，再递归调用函数建立左子树和右子树，然后向上层返回根结点即可。递归中止的条件也即结点为空。&emsp;&emsp;preorder[preLeft ~ preRight] 和 inorder[inLeft ~ inRight] 分别表示了前序遍历和中序遍历的区间。（代码是为了便于理解，实际上没有用到 inRight） &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对中序遍历行了一次遍历建立哈希表，而在递归的过程中实际我们对前序遍历和中序遍历进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。哈希表的大小为 $n$，递归栈的最大深度也为 $n$。"},{"title":"Leetcode 104.二叉树的最大深度","date":"2021-06-23T10:14:00.000Z","url":"/2021/06/23/Leetcode%20104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["BFS","/tags/BFS/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 链接： 题目分析1.广度优先搜索&emsp;&emsp;从 Leetcode 102.二叉树的层序遍历 我们可以很容易想到这个算法。层序遍历题目中对于每一层都需要新开一行进行存储，直接改成计数即可，代码比层序遍历更简单。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。 2.深度优先搜索&emsp;&emsp;搜索树的深度其实更常用的是深度优先搜索，只需要一个递归的过程即可完成，每一个结点从左右子树中选择深度更深的一边并加上自身往上返回即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们对二叉树进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。空间复杂度取决于栈的深度。在最坏情况下（树是一条链）栈的深度会达到 $n$，最好情况下（树是平衡的）则是 $O(\\log n)$。"},{"title":"Leetcode 102.二叉树的层序遍历","date":"2021-06-23T09:36:00.000Z","url":"/2021/06/23/Leetcode%20102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["C++","/tags/C/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["BFS","/tags/BFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 返回其层序遍历结果： 链接： 题目分析&emsp;&emsp;我们知道，二叉树的层序遍历跟广度优先搜索的过程是一样的，所用到的数据结构都是队列。每次将队头出列，并将其左右子结点加入队尾，这样即可以按照层次的顺序得到二叉树的结果。但是阅读示例可以发现，返回的结果是二维的数组，不同层次之间需要隔开，怎么分隔呢？我们可以在每一层的开始先检查队列中的元素个数，然后按照这个数目进行循环，循环结束也即该层遍历结束。下一层的时候重复这个过程即可，直到队列为空则遍历结束。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。所有结点各入队一次出队一次。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。"},{"title":"Leetcode 101.对称二叉树","date":"2021-06-23T08:46:00.000Z","url":"/2021/06/23/Leetcode%20101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"],["队列","/tags/%E9%98%9F%E5%88%97/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，检查它是否是镜像对称的。 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 链接： 题目分析1.递归&emsp;&emsp;什么样的树是镜像对称的？对应的结点值相同，并且他们的左右子树也刚好对称。这个定义是递归的，因此我们可以使用一个递归函数 check 来检查两个树是否对称。结点同时为空则对称，若同时不为空，则需满足结点值相同，并且左右子树互相对称。而我们只需要检查根结点的左右子树是否满足这样的对称树即可。这样的遍历是前序遍历。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历了二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。也即栈空间的最大深度。 2.迭代&emsp;&emsp;迭代算法可以模拟递归的过程。我们维护一个队列，队列中的每两个结点是对应的结点。每次检查时从队头出列两个结点，判断他们是否同时为空或者是值相同，并且将他们的左右子树按照对称关系两两加入到队列中。直到队列为空也即遍历所有的结点，仍然符合的话则为对称树。这样的遍历是层序遍历。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。我们遍历了二叉树。每个结点最多进队一次，出队一次。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点数。队列的最大长度为 $n$。"},{"title":"Leetcode 98.验证二叉搜索树","date":"2021-06-22T17:16:00.000Z","url":"/2021/06/23/Leetcode%2098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 示例 2: 链接： 题目分析&emsp;&emsp;我们知道二叉搜索树按照中序遍历的话得到的一定是升序序列。则我们根据中序遍历检查是否满足升序序列即可。我们维护了一个 pre 表示已经遍历过的最后一个结点的值，而当前结点的值必须大于 pre，出现不满足的结点则可以直接返回 false。遍历完这个结点后，我们更新 pre 的值为当前结点值。&emsp;&emsp;注意到题目中结点值 val 是 int 类型的，最小可以达到 INT_MIN（测例中真的有一个 INT_MIN）。我们设置的哨兵值要比这个值还小，因此采用了 long 类型，并赋初始值为 LONG_MIN。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。我们最多对二叉搜索树进行了一次中序遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。也即递归栈的深度，而当二叉树是一条链时，最大深度为 $n$。"},{"title":"Leetcode 96.不同的二叉搜索树","date":"2021-06-22T16:31:00.000Z","url":"/2021/06/23/Leetcode%2096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","tags":[["C++","/tags/C/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 19 链接： 题目分析&emsp;&emsp;二叉搜索树也即中序遍历是一致的（升序序列）。我们分析一下结点数为 n 时，有几种不同的情况呢？我们设根结点为第 i 个数，则在 i 的左边的所有数构成左子树，右边所有的数构成右子树。我们设结点数为 n 的二叉搜索树种数为 $f(n)$，那么其实左子树的种数就为 $f(i-1)$，右子树的种数为 $f(n-i)$。而我们一共可以有 n 个数可以成为根结点，也即有如下递推公式，其中 $f(0)=1$。 f(n)=\\sum^n_{i=1}f(i-1)*f(n-i)&emsp;&emsp;这其实就是我们曾经接触过的卡特兰数。而第 $n$ 个卡特兰数计算公式为 $\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}$。需要注意的是必须使用 long long int 类型才不会越界。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉搜索树的结点数。计算卡特兰数用到了一个 $O(n)$ 的循环。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放变量。"},{"title":"Leetcode 94.二叉树的中序遍历","date":"2021-06-22T14:26:00.000Z","url":"/2021/06/22/Leetcode%2094.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","tags":[["C++","/tags/C/"],["递归","/tags/%E9%80%92%E5%BD%92/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个二叉树的根节点 root ，返回它的 中序 遍历。 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 链接： 题目分析1.递归解法&emsp;&emsp;非常容易想到的解法，也即按照 左子树-根结点-右子树 的顺序递归遍历二叉树即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。我们遍历了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。也即栈的深度，而当二叉树是一条链时，最大深度为 $n$。 2.迭代解法&emsp;&emsp;其实我们需要做的就是将递归的栈显式地模拟出来。寻找左结点之前将根结点压栈，直到最左的结点，然后将栈顶出栈并加入到结果中，然后开始遍历右子树。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。我们遍历了一次二叉树。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为二叉树的结点个数。也即栈的大小。"},{"title":"Leetcode 85.最大矩形","date":"2021-06-22T12:45:00.000Z","url":"/2021/06/22/Leetcode%2085.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","tags":[["C++","/tags/C/"],["单调栈","/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： rows == matrix.length cols == matrix[0].length 0 &lt;= row, cols &lt;= 200 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 链接： 题目分析&emsp;&emsp;做这道题之前先看看与之关联的上一道题 Leetcode 84.柱状图中最大的矩形。我们可以发现，如果我们按照每一列的顺序维护 heights，就可以复用上一题的代码。就像下面这样。这样是可以遍历所有可能存在的矩形的，因此得到的答案就是最终答案。&emsp;&emsp;PS：下面的代码中 largestRectangleArea 函数来自上一题，使用的是单调栈的做法，具体过程可以参阅上一题题解。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是矩阵的行数和列数。我们遍历矩阵的一行进行一次处理，而处理的函数时间复杂度是 $O(n)$。因此总的时间复杂度就是 $O(mn)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是矩阵的列数。因为我们需要维护一个 heights 数组，大小为 $O(n)$，并且进行处理的 largestRectangleArea 函数也需要 $O(n)$ 的栈空间。"},{"title":"Leetcode 84.柱状图中最大的矩形","date":"2021-06-17T12:44:00.000Z","url":"/2021/06/17/Leetcode%2084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","tags":[["C++","/tags/C/"],["单调栈","/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 链接： 题目分析&emsp;&emsp;通过观察我们可以知道，对于每一个柱子，都有以它为高的矩形存在，我们只需要遍历所有这样的矩形即可得到最大矩形。每一个矩形的宽边界是哪里呢？是这个柱子两边低于它的第一个柱子。获取这个信息并不需要每次都进行遍历，我们只需要使用单调栈的做法。按照从左到右的顺序遍历，我们维护一个升序的柱子序列，则对于栈顶的柱子，它的左边界就是栈中的前一个柱子，而当我们遍历到某个柱子不符合升序序列，也即比栈顶元素小时，它就是栈顶矩形的右边界。这个时候就可以计算以栈顶为高的矩形的大小了。并且计算后可以将其出栈，这是因为它是目前遍历过的柱子中最高的值，不会对其他矩形产生影响。出栈后，如果这个柱子仍然比新的栈顶小，则仍需要继续这个过程，因此我们使用的是 while 循环。结束过程之后，我们要将这个柱子进栈。&emsp;&emsp;对于连续两个同样高度的柱子是怎么处理的呢？以它们为高的矩形应该是一样的，因此我们只需要计算其中一个即可。两个都加入栈中的话，右边那个的左边界会被认为是左边这个，因此计算得到的矩形面积会比实际小，左边那个的计算则不会受到影响。我们的结果是要求最大的矩形面积，因此偏小的那个不会对最终结果造成影响。由此可知，我们可以直接将同样高度的也加入到栈中。&emsp;&emsp;栈中存放的信息是什么？我们需要知道柱子的高度，也即矩形的高；而柱子的宽度是以它的左右边界的下标差来计算的，因此我们也需要知道柱子的下标。因此我们有两种方法，一种是直接存放柱子的下标，每次需要用到柱子高度时再通过柱子下标查询高度；另外一种是直接用一个 pair 将这两个信息存放进去。&emsp;&emsp;这个题目对于边界是怎么处理的？我们可以利用哨兵的技巧。也即在柱子序列两边添加一个高度为 0 的柱子，这样就可以直接处理边界的柱子了。可是数组不能有下标为 -1 的情况，heights[-1] 是非法的，因此我采用的是 pair 的做法，最开始就在栈中直接添加了一个 &#123;-1, 0&#125;，表示下标为 -1 的柱子高度为 0。这样的好处是栈永远不会为空，并且这个哨兵可以处理其作为左边界的情况。对于右边界的哨兵就更简单了，直接在数组最后添加一个 0 表示一个高度为 0 的柱子即可，这样到最后可以处理掉栈中剩余的所有柱子，只留下两个哨兵。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是柱子的数量。我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是柱子的数量。也即栈的开销。"},{"title":"Leetcode 79.单词搜索","date":"2021-06-17T10:41:00.000Z","url":"/2021/06/17/Leetcode%2079.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","tags":[["C++","/tags/C/"],["DFS","/tags/DFS/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例 1： 示例 2： 示例 3： 提示： m == board.length n = board[i].length 1 &lt;= m, n &lt;= 6 1 &lt;= word.length &lt;= 15 board 和 word 仅由大小写英文字母组成 链接： 题目分析&emsp;&emsp;这道题是在一个二维的表格中寻找一个单词，由于每次搜索的格子是相邻的，我们很容易可以想到 DFS（深度优先搜索）的方法。因为题目要求结点不能重复使用，我们使用一个和 board 同样大小的布尔数组 use 来标记结点是否已经被使用。我们从符合 word[0] 的某个单元格开始搜索，每次往某个方向搜索，如果这个方向的邻结点还没有被使用，并且符合我们需要的下一个字母（word[index]），则从这个结点进行下一层的搜索。当我们搜索到 word 的尽头仍然可以找到符合的字母时，则说明这个单词 word 存在于 board 中，直接返回 true，不再进行搜索。如果当前方向搜索不到则进行回溯，将标记为已使用的单元格还原为未使用，继续进行其他方向的搜索。如果经历了所有的搜索都无法找到，则结果为 false。需要注意的是，初始的 use 需要全部标记为未使用。 &emsp;&emsp;时间复杂度：$O(mn\\times3^L)$，其中 $m、n、L$ 分别为 board 的行数、列数和 word 的长度，这是一个比较宽松的上界。我们最多对整个 board 的所有单元格作为起点进行搜索，除了起点，每次搜索最多只有三个方向可以搜索（上一个结点的方向已经被使用），最大搜索长度是单词的长度。我们对于已使用的单元格或者是不符合的字母都是不会进行搜索的，有了这些剪枝实际上的时间复杂度会远远小于这个上界。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别为 board 的行数和列数。我们建立了一个 $m\\times n$ 的数组用于标记某个单元格是否已经使用。而 DFS 最大的搜索深度为单词的长度或者是搜满 board，也即 $O(\\min(L,mn))$。因此总的空间复杂度为 $O(mn)$。"},{"title":"Leetcode 78.子集","date":"2021-06-17T09:31:00.000Z","url":"/2021/06/17/Leetcode%2078.%E5%AD%90%E9%9B%86/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 示例 2： 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 链接： 题目分析&emsp;&emsp;对于 nums 中的每个数，选择或者不选择都是两种不同的情况，也即幂集的个数为 $2^n$。我们可以使用回溯的方法，不选择 nums[i] 进行递归，得到一种结果后回溯，选择 nums[i] 进行递归。每次遍历完 nums[i] 即得到一个结果，将其加入到结果数组中。 &emsp;&emsp;时间复杂度：$O(n\\times2^n)$，其中 $n$ 为 nums 数组的大小。因为总共有 $2^n$ 种结果，而对于每种结果我们需要 $O(n)$ 的时间将其加入到答案中。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为 nums 数组的大小。递归的最大深度为 $n$。"},{"title":"Leetcode 76.最小覆盖子串","date":"2021-06-16T18:33:00.000Z","url":"/2021/06/17/Leetcode%2076.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 进阶：你能设计一个在 $o(n)$ 时间内解决此问题的算法吗？ 示例 1： 示例 2： 提示： $1 &lt;= s.length, t.length &lt;= 10^5$ s 和 t 由英文字母组成 链接： 题目分析&emsp;&emsp;通过观察示例我们可以得知，覆盖 t 并不需要按照顺序，也即 s 的某个子串中只需要包含 t 中的所有字母即可。并且 t 中的字母是可以重复的，比如有两个 &#39;a&#39;，则符合条件的 s 子串也必须包含至少两个 &#39;a&#39;。那么我们可以考虑使用一个哈希表来记录 t 中的所有字母以及它们的个数，作为 s 子串需要满足的 target。&emsp;&emsp;而对于子串的问题，我们可以使用滑动窗口的思想，使用 left 和 right 两个变量记录窗口的边界，并且维护另一个哈希表 now，记录当前子串中各字符的个数，使用一个布尔变量 flag 表示 now 是否能覆盖 target。如果能够覆盖，则 left 右移，缩小窗口；如果不能覆盖，则 right 右移，扩大窗口。这样动态地维护窗口并且记录能够覆盖的最小长度，记录为答案。&emsp;&emsp;需要注意的地方有以下几点。 s 的长度小于 t 的长度时，肯定无法覆盖 t，可以直接返回空串。 left 和 right 都是从 0 开始的，其中 left 处于窗口内，right 处于窗口外，也即子串为 s[left ~ right-1]，长度刚好为 right-left。 即使 right 到了终点，也仍然存在 left 继续右移缩小窗口的可能，因此退出循环条件还必须是子串已经无法覆盖 target（也即 flag 变为 false）。 当 left 右移时（此时 flag 为 true），无需对右移后的整个哈希表进行判断，因为改变的只有 s[left]，还能不能覆盖只取决于 s[left] 的数目会不会因此而变得不足。（实际上，如果维护的是能够满足覆盖的字母种类，right 右移时也可以只检查新添字母之后，该字母数目的增加能否使得满足覆盖的字母种类已经达到了 t 的字母种类。） minlength 记录了最小子串长度，初始值赋为 INT_MAX，如果到最后这个值仍然没有被修改，则说明不存在能够覆盖 t 的子串，按照题目要求返回空串。 &emsp;&emsp;时间复杂度：$O(\\alpha|s|+|t|)$，其中 $\\alpha、s、t$ 分别是字符集的大小、字符串 s 和 t。t 的字符要加入哈希表中，而最坏情况下，s 的所有字符都需要加入哈希表一次、从哈希表删除一次，并且每次加入都需要遍历一次 target 检查是否满足覆盖，而 target 的大小也即字符集的大小。&emsp;&emsp;空间复杂度：$O(\\alpha)$，其中 $\\alpha$ 是字符集的大小。也即两张哈希表的空间开销。"},{"title":"Leetcode 75.颜色分类","date":"2021-06-16T09:41:00.000Z","url":"/2021/06/16/Leetcode%2075.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 进阶： 你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 链接： 题目分析1.计数&emsp;&emsp;题目中要求使用原地算法，并且最好不用排序函数，而数字只有三种，我们可以很容易想到使用计数的方法。先遍历一次数组记录 0 和 1 的个数，剩下的就是 2，之后对整个数组进行重写即可。一共需要两次遍历。 2.双指针&emsp;&emsp;由于只有三种数字，最后的结果中 0 一定在左边，2 一定在右边。那我们只进行一次遍历，每次将 0 放到左边，2 放到右边，最后剩下的 1 就都在中间，也就完成了。我们需要两个指针 p0 和 p2 分别指示 0 和 2 的边界位置。&emsp;&emsp;注意我们是从左往右遍历，而 p2 是位于右边，因此与 p2 交换后，i 所指示的位置的新数字依然是没有处理过的，因此 i 不能自增。 3.官方题解&emsp;&emsp;官方题解中还提到了其他同样使用指针的方法。一种是单指针的方法，先遍历一次处理 0（遇到 0 就交换到最左边），再从 0 结束的位置遍历一次处理 1，一共需要两次遍历。 &emsp;&emsp;还有一种是另外一种双指针的方法，记录的是 0 和 1 的边界位置，放入 0 时两个指针同时右移（若有 1 被 0 替换还需在末尾补 1），放入 1 时 p1 右移，这种方法也是一次遍历。 复杂度分析&emsp;&emsp;以上的所有方法不管是两次遍历还是一次遍历，时间复杂度都是 $O(n)$，而作为原地算法，空间复杂度都是 $O(1)$。"},{"title":"Leetcode 72.编辑距离","date":"2021-06-16T08:24:00.000Z","url":"/2021/06/16/Leetcode%2072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 示例 2： 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 链接： 题目分析&emsp;&emsp;我们需要做的是将 word1 转换到 word2，而每一步操作都只涉及到 1 个字母的变化，一共有 3 种操作，也即插入、替换、删除。其中插入和删除的操作比较难以处理，可能会陷入死循环，有没有办法解决呢？其实 word1 的删除操作和 word2 的插入操作是等价的。比如 abcd -&gt; abc，既可以看做是左边删除了一个 d，变成 abc = abc，也可以视为右边添加了一个 d，变成 abcd = abcd，操作步数都是 1，同样能让两个单词相同。因此我们的方法有以下三种 word1 插入一个字符 word2 插入一个字符 word1 替换一个字符 &emsp;&emsp;注意到以上的操作方法次序对结果是没有影响的，因此我们可以从左到右逐步对字符进行操作，便可以使用动态规划的方法解决。我们逐步分析两个字符串，并保留操作次数最少的方法。dp[i][j] 的值表示 word1 的前 i 个字符与 word2 的前 j 个字符进行匹配需要的最少步数（也即它们的编辑距离）。而每次我们只在字符串的最后进行操作。我们分析状态转移方程，也即 dp[i][j] 的值如何确定。 如果最后一步操作是 word1 插入字符，也即进行了 dp[i][j-1] 的操作之后，我们将 word2 的第 j 个字符插入到 word1 最后。 如果最后一步操作是 word2 插入字符，也即进行了 dp[i-1][j] 的操作之后，我们将 word1 的第 i 个字符插入到 word2 最后。 如果最后一步操作是 word1 替换字符，也即进行了 dp[i-1][j-1] 的操作之后，我们将 word1 的第 i 个字符替换为 word2 的第 j 个字符（如果这两个字符本来就是相同的，则无需替换）。 &emsp;&emsp;以上的三种操作中，我们总是选取操作次数最小的那个作为 dp[i][j] 的值进行状态转移，最后就能够得到 dp[m][n] 也即 word1 转换为 word2 的最少操作数。而边界情况是什么样的？边界情况是其中某一个字符串为空的时候，操作数就是另一个字符串的字符数。也即 dp[0][j] = j，word1 为空时，word1 变为 word2 的操作就是往 word1 插入 j 个字符。同理，dp[i][0] = i。&emsp;&emsp;注意字符串的下标是从 0 开始的，因此 word1 的第 i 个字符是 word1[i-1]。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。我们进行了双层遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是 word1 和 word2 的长度。也即动态规划所需的数组大小。"},{"title":"Leetcode 70.爬楼梯","date":"2021-06-15T17:03:00.000Z","url":"/2021/06/16/Leetcode%2070.%E7%88%AC%E6%A5%BC%E6%A2%AF/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 示例 2： 链接： 题目分析1.递归&emsp;&emsp;记得这道题是第一次学递归的时候就做的例题。爬 n 阶的楼梯，可以看做是爬了 n-1 阶的楼梯，最后一步再爬 1 个台阶；也可以看做是爬了 n-2 阶的楼梯，最后一步再爬 2 个台阶。而方法数就是这两种方法的和。这便是一个递归的过程，即有 $f(n)=f(n-1)+f(n-2)$。&emsp;&emsp;递归的终结条件是什么呢？还没开始爬的时候 $n=0$ 就是爬楼梯的开始，记为 1 种方法。而 $n=1$ 的时候，前一步只能爬 1 个台阶而不能爬 2 个台阶，因此方法数也是 1。&emsp;&emsp;PS：这种方法会超出时间限制。 &emsp;&emsp;时间复杂度：$O(2^n)$，其中 $n$ 为楼梯的阶数。一共 $n$ 层递归，而每一层递归我们都需要调用两次递归函数。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即递归的深度。 2.动态规划&emsp;&emsp;递归的方法虽然容易理解，代码也十分简洁，但是其实时间复杂度非常高，即使是简单题也是毫不意外地超出了时间限制。这是因为每层递归都会调用两次递归函数，而且这个操作存在的大量的重复计算，比如 $f(n-1)$ 的计算中也需要用到 $f(n-2)$。如何复用这些函数的值呢？我们可以很容易想到动态规划。&emsp;&emsp;与递归相反，我们正向地推导这个过程。上面已经推出了状态转移方程 $f(n)=f(n-1)+f(n-2)$，起始条件也即 $f(0)=1$，$f(1)=1$。我们注意到状态转移只与前两个状态有关，而最后的结果是最后一个状态，则我们可以丢弃前面的状态，只用三个变量分别存储当前的状态、前一个状态、前两个状态。result 表示 $f(n)$，one 表示 $f(n-1)$，two 表示 $f(n-2)$。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为楼梯的阶数。也即循环的次数。&emsp;&emsp;空间复杂度：$O(1)$。经过优化，我们只需要使用三个变量来进行状态转移，因此所需空间是常数级的。 3.数学方法&emsp;&emsp;通过前面的状态转移方程和初始值我们可以发现，其实这就是一个斐波那契数列。而通过 特征方程法 是可以得到斐波那契数列的通项公式的，也即 $a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$。注意上面的通项公式是从 1 开始的，而我们的函数 $f$ 是从 0 开始的，因此在代入时需要将 n 加 1。 &emsp;&emsp;这个通项公式中包含了幂运算，具体时间复杂度取决于 CPU 的指令集，因此不分析。&emsp;&emsp;空间复杂度为 $O(1)$。 4.矩阵快速幂 - 官方题解&emsp;&emsp;来自于官方题解的方法，涉及了矩阵的知识。由于递推的关系可以视为矩阵相乘。 \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix} \\begin{bmatrix}f(n)\\\\f(n-1)\\end{bmatrix}= \\begin{bmatrix}f(n)+f(n-1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}&emsp;&emsp;则有 \\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}= \\begin{bmatrix}1 & 1\\\\1 & 0\\end{bmatrix}^n \\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}&emsp;&emsp;因此我们需要计算的就是 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^n$，可以将其拆分成 $\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}\\begin{bmatrix}1 &amp; 1\\\\1 &amp; 0\\end{bmatrix}^{n/2}$，以此类推。计算的时间复杂度是 $O(\\log n)$，也即在较大的 $n$ 下，计算速度比动态规划更快。&emsp;&emsp;另外官方题解还提到了非齐次线性递推转化为矩阵快速幂的计算方法，上面的方法代码也包含其中。具体请阅读 爬楼梯 - 力扣官方题解。"},{"title":"Leetcode 64.最小路径和","date":"2021-06-15T16:18:00.000Z","url":"/2021/06/16/Leetcode%2064.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 示例 2： 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 链接： 题目分析&emsp;&emsp;由于只能往右或往下走，则每一格最多来自两个方向（左边或者上边）。我们采用动态规划的方法，dp[i][j] 记录从左上角到 grid[i][j] 的最小路径和，从左到右，从上到下遍历 grid，直到右下角，得出答案 dp[m-1][n-1]。而每一格的最小路径和也即从左边或者上边选择值较小的那一个，然后加上本身的数值。&emsp;&emsp;注意左上角的最小路径和也即其本身，第一列只能来自上边，第一行只能来自左边。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别是 grid 的行数和列数。动态规划的过程对 grid 进行了一次遍历。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别是 grid 的行数和列数。也即动态规划数组的大小。（可以优化到 $O(\\min(m,n))$，具体方法是只存储上一行或者上一列的 dp 值）"},{"title":"Leetcode 62.不同路径","date":"2021-06-10T12:55:00.000Z","url":"/2021/06/10/Leetcode%2062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","tags":[["C++","/tags/C/"],["数学方法","/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= m, n &lt;= 100$ 题目数据保证答案小于等于 $2*10^9$ 链接： 题目分析&emsp;&emsp;这是一道很经典的数学题。机器人处在 m x n 的网格中，并且只能往右和往下移动，则从左上角移动到右下角，总的移动路程是一定的，一定是往右走了 n-1 步，往下走了 m-1 步，也即总的移动路程是 m-1+n-1。而不同的移动方案，也即是在 m-1+n-1 步中，选择其中的 m-1 往下（或者选择 n-1 步往右），也即是一个数学组合问题。答案就是 $\\binom{m-1+n-1}{m-1}$ 或 $\\binom{m-1+n-1}{n-1}$。为了减少运算量，我们可以选择 m 和 n 其中更小的那个来计算。&emsp;&emsp;虽然题目中保证答案小于等于 $2*10^9$，也即答案不会超过 int 的范围，但是在计算的过程还是会超过，需要使用 long long int 类型。 &emsp;&emsp;时间复杂度：$O(\\min(m,n))$，其中 $m、n$ 分别是网格的行数和列数。也即计算组合数的时间复杂度。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数的空间存放变量。"},{"title":"Leetcode 56.合并区间","date":"2021-06-10T09:15:00.000Z","url":"/2021/06/10/Leetcode%2056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","tags":[["C++","/tags/C/"],["排序","/tags/%E6%8E%92%E5%BA%8F/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] = [start_i, end_i]$ 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 示例 2： 提示： $1 &lt;= intervals.length &lt;= 10^4$ $intervals[i].length == 2$ $0 &lt;= starti &lt;= endi &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;可以合并的区间存在着这样的性质：假设左端点靠左的区间为 interval_1，左端点靠右的区间为 interval_2，则有 interval_1-&gt;end &gt;= interval_2-&gt;start，也即存在重叠。则如果我们按照区间的左端点大小进行排序，则可以进行合并的区间一定是连续的。&emsp;&emsp;声明一个 result 数组作为结果返回，我们先将第一个区间加入结果。之后对于后面的每一个区间，我们有这样的操作：如果该区间和 result 中的最后一个区间不存在重合（满足 intervals[i]-&gt;start &gt; result[count]-&gt;end），则将其作为新区间加入到 result 中；若该区间与 result 中的最后一个区间重合，则更新 result 的最后一个区间，变成合并后的结果，也即 result[count]-&gt;end = max(result[count]-&gt;end, intervals[i]-&gt;end)。顺序遍历所有的区间后得到结果。 &emsp;&emsp;时间复杂度：$O(n\\log n)$，其中 $n$ 为区间的个数。对所有的区间进行排序需要 $O(n\\log n)$ 的时间，而排序后只需要一次遍历，也即 $O(n)$ 的时间，因此总的时间复杂度为 $O(n\\log n)$。&emsp;&emsp;空间复杂度：$O(\\log n)$，其中 $n$ 为区间的个数。作为答案返回的数组不计入所需空间，则所需的额外空间也即排序所需要的空间。"},{"title":"Leetcode 55.跳跃游戏","date":"2021-06-10T08:50:00.000Z","url":"/2021/06/10/Leetcode%2055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","tags":[["C++","/tags/C/"],["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 示例 2： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $0 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;这道题目可以使用贪心的思想。对于某个位置 y 是否可以到达，需要满足两个条件：前面的某个位置 x 可以到达，x 可以跳跃到 y，也即有 x + nums[x] &gt;= y。那我们可以遍历数组，贪心地获取当前可以到达的最远位置，直到遍历到所有的可到达位置，若可以到达的最远位置没有超过数组的最后一个下标，则数组的最后一个下标不可达。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组的大小。我们最多只需要遍历一遍数组。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 53.最大子序和","date":"2021-06-09T09:04:00.000Z","url":"/2021/06/09/Leetcode%2053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= nums.length &lt;= 3 * 10^4$ $10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析1.动态规划&emsp;&emsp;我们用 dp[i] 表示以 nums[i] 结尾的最大子序列和。那么 dp[i] 只有两种情况，第一种是 nums[i] 加上 dp[i-1] 所表示的那一段，第二种是 nums[i] 单独作为新的一段。而我们只需要保留这两种中较大的那一个。也即状态转移方程为 dp[i] = max&#123;dp[i-1]+nums[i], nums[i]&#125;。而我们所要求的结果也即 dp 数组中最大的值。&emsp;&emsp;另外我们通过观察可以发现，每一个 dp[i] 只取决于 dp[i-1]，并且在遍历的时候便可以边记录最大值，则其实我们无需建立一个 dp 数组，只需要一个变量 pre 来表示每一个 dp[i-1] 即可。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只对数组进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。 2.分治法 - 官方题解&emsp;&emsp;这是题目中提到的更为精妙的进阶方法，没有想到，参阅了官方题解 最大子序和 - 力扣官方题解。主要思路是利用了线段树，对于每一个区间 [l, r]，维护了 4 个变量，分别是 $lSum$，表示 [l, r] 中以 l 为左端点的最大子序和。 $rSum$，表示 [l, r] 中以 r 为右端点的最大子序和。 $iSum$，表示 [l, r] 的区间和。 $mSum$，表示 [l, r] 中最大子序和。 &emsp;&emsp;对于每一个区间 [l, r] 这些变量的赋值都来自于 [l, m] 和 [m+1, r] 的这些变量，也即分治后递归回升的整合。具体整合方法为 $iSum = iSum_l + iSum_r$，也即左右子区间的和即为该区间的和。 $lSum = max(lSum_l, iSum_l+lSum_r)$，也即要不是左区间的 $lSum$，要不是整个左区间加上右区间的 $lSum$。 $rSum = max(rSum_r, iSum_r+rSum_l)$，同理，要不是右区间的 $rSum$，要不是整个右区间加上左区间的 $rSum$。 $mSum = max(mSum_l, mSum_r, rSum_l+lSum_r)$，也即如果 $mSum$ 不跨越 m，则可以是左区间或者是右区间的 $mSum$，如果跨越 m，则是左区间的 $rSum$ 加上右区间的 $lSum$。 &emsp;&emsp;最后递归到最外层，求出 [0, nums.size()-1] 区间的 $mSum$ 即可。 &emsp;&emsp;时间复杂度：$O(n)$，这样的方法下其实相当于是进行了一颗二叉树的先序遍历。&emsp;&emsp;空间复杂度：$O(\\log n)$，也即递归的深度。 &emsp;&emsp;这样的方法下使用了递归，实际运行的时间比动态规划更长，也需要更多的空间，但是它的意义是它可以解决任意区间下的最大子序和问题，并且建立成为一颗树之后，所有的子区间信息都可以用堆的方法来存储，就可以在 $O(\\log n)$ 的时间内找到任意区间的答案。并且假如序列中的某些值发生修改，只需要对有影响的区间值进行修改维护，所需的时间只要 $O(\\log n)$，便可以继续使用。这样的特性对于大规模的查询优势便十分明显。"},{"title":"Leetcode 49.字母异位词分组","date":"2021-06-09T08:30:00.000Z","url":"/2021/06/09/Leetcode%2049.%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 链接： 题目分析&emsp;&emsp;题目中要求我们给字符串分类，很容易可以想到哈希的思想。我们可以建立一个哈希表，把一组字母异位词放到同一个 key 里作为哈希表的值。那么如何选取 key 值呢？观察字母异位词的共同点，它们的字母是相同的，但排列不同，也即是说，经过排序，它们会变成同一个字符串。则我们可以将这个排序好的字符串作为这一组字母异位词的 key 值。遍历所有的字符串加入哈希表之后，哈希表中的每一个 key 即对于一组字母异位词，将哈希表转化为结果即可。 &emsp;&emsp;时间复杂度：$O(nk\\log k)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。因为我们总共需要添加 $n$ 个字符串，而每个字符串需要 $O(k\\log k)$ 的时间排序，$O(1)$ 的时间加入到哈希表中，$O(k)$ 的时间复制到结果中。因此最后的总时间复杂度为 $O(nk\\log k)$。&emsp;&emsp;空间复杂度：$O(nk)$，其中 $n$ 是字符串的个数，$k$ 是字符串的长度。也即哈希表的开销。 官方题解&emsp;&emsp;官方题解中将字符串加入到 vector 中的使用的函数都是 emplace_back，通过搜索学习发现原来是 C++11 的新特性，这个函数是将参数而不是对象传递给构造函数，而构造函数直接在容器空间中构造元素，因此省去了一次构造临时对象的过程，减少了内存开销。"},{"title":"Leetcode 48.旋转图像","date":"2021-06-08T17:21:00.000Z","url":"/2021/06/09/Leetcode%2048.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","tags":[["C++","/tags/C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 示例 2： 示例 3： 示例 4： 提示： matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 链接： 题目分析&emsp;&emsp;题目要求我们使用原地算法，也即直接对矩阵进行操作。通过观察我们可以发现，顺时针旋转 90 度，也即每 4 个位置进行了依次更替。如下图所示。 &emsp;&emsp;一共有多少组需要进行这样的更替呢？其实也就是矩阵的 1/4。下面以 4 × 4 和 5 × 5 的矩阵为例展示需要旋转的范围。我们只需要以左上角的色块为起点，对每一个位置进行对应位置的依次更替即可。需要注意依次更替的坐标对应关系，还有矩阵宽度为奇数时的划分方式（中心块无需更替）。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 为矩阵的宽度。我们其实就是对矩阵的每个位置进行了相应的更替，需要操作的子矩阵大小为 $O(\\lfloor{\\frac{n+1}{2}}\\rfloor\\times\\lfloor{\\frac{n}{2}}\\rfloor)=O(n^2)$，每次操作 5 步，为常数。&emsp;&emsp;空间复杂度：$O(1)$。原地算法，只用到了常数的额外空间。 官方题解&emsp;&emsp;官方题解中提到了另外一种巧妙的方法，也即利用翻转代替旋转。先将矩阵上下翻转，再按左上到右下的主对角线翻转，也可以得到答案。 "},{"title":"Leetcode 46.全排列","date":"2021-06-08T15:40:00.000Z","url":"/2021/06/08/Leetcode%2046.%E5%85%A8%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 6$ $-10 &lt;= nums[i] &lt;= 10$ nums 中的所有整数 互不相同 链接： 题目分析&emsp;&emsp;全排列也即题目中所给数字填在不同的位置构成的所有情况，我们可以按顺序从左到右填上数字，利用回溯的方法即可穷举所有的情况。我们需要填入的数字也即 nums 数组，如何标记已经填入的数字呢？一个方法是维护一个布尔数组用于记录，将已填入的数字标记为 true。每次填入时按顺序遍历，寻找未填入的数字进行填入，并更新这个标记。回溯之后记得将标记回溯为 false。 &emsp;&emsp;上面的代码我们可以发现，每一次填数时，都需要遍历 flag 数组寻找未填入的数字，这样需要的时间更长，也需要额外的空间，有没有什么办法可以不需要这个标记数组呢？答案是肯定的。我们可以将 nums 数组分割为两个部分，一部分表示已经填入的数，一部分表示未填入的数，每次填入一个数，就将其与分割线的位置交换，例如 &#123;2, 3, | 4, 5, 6&#125; 这样的数组，下一个填入 6 时就将 4 与 6 交换，并且移动分割线，变成 &#123;2, 3, 6, | 5, 4&#125;，这样每次只需要从分割线的位置开始遍历就可以了，并且不需要额外的空间进行标记。值得注意的是，这样的交换会打乱数组的顺序，所以最后输出的结果并不是按照字典序来排列的。题目中说明可以按照任意顺序返回答案，因此可以这样做，如果有要求按照字典序，则只能按照上面的做法。 &emsp;&emsp;时间复杂度：$O(n\\times n!)$，其中 $n$ 是数组的大小。因为我们遍历了所有的排列，全排列的个数为 $n!$。 而对于每一个解，我们都需要 $O(n)$ 的时间将其复制到答案数组中，因此总的时间复杂度为 $O(n\\times n!)$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是数组的大小。因为作为答案返回的数组不计入所需空间中，而我们需要的额外空间即递归调用的深度，最大深度为 $n$。 官方题解&emsp;&emsp;看完官方题解才发现，我们在动态维护的 nums 数组，左边表示的已填入的数字就是按照填入的顺序进行排列的，因此可以不用额外的一个 now 数组对结果进行存储，在填完所有的数字后 nums 即为这种排列本身，将其复制到答案中即可。 "},{"title":"Leetcode 42.接雨水","date":"2021-06-08T06:37:00.000Z","url":"/2021/06/08/Leetcode%2042.%E6%8E%A5%E9%9B%A8%E6%B0%B4/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 示例 2： 提示： 链接： 题目分析&emsp;&emsp;这道题有点像 Leetcode 11.盛最多水的容器，因此也是考虑用双指针的做法。与那道题不同的是，这里的每个柱子并不是没有厚度的“壁”，而且对于所有的“坑”都会盛上水，而不是只选取其中两个壁之间盛水。但是思路应该是一致的，我们可以从两边往中间搜索。这是因为观察可以发现，每个较低的柱子，只要两边有高于它的柱子，则可以填上水直到和较低的一边柱子平齐。而我们在利用双指针搜索的时候，优先扩展较低的那边，则可以保证未搜索的区域不会影响已搜索区域填水的高度。&emsp;&emsp;具体的算法是，维护两个变量记录左边已搜索区域的最大高度 maxleft 和右边已搜索区域的最大高度 maxright，而 left 和 right 分别记录当前搜索的左右指针（下标）。如果当前是左边的最大高度 maxleft 较小，则扩展左边，若出现了更高的柱子则更新 maxleft，较低的柱子则填上雨水直到和 maxleft 平齐，也即更新 water 值；同样的，如果是 maxright 较小，则扩展右边，相应地更新 maxright 或者 water 值。最后两个指针相遇的时候搜索结束，得到结果。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 官方题解&emsp;&emsp;下面的代码是官方题解中双指针的代码，减少了一次判断，将更新 max 值和 water 值（这里是变量 ans)整合到了一起。相应的指针相遇条件有所不同（因为我们上面的代码更新完 max 值也对指针进行了移动，因此指向的永远是未搜索的区域，必须两个指针已经重合后错开才算搜索完毕）。&emsp;&emsp;官方题解中还有动态规划和栈等其他解法，也可以提供一定的解决思路，时间复杂度都是一样的 $O(n)$，但是动态规划和栈解法均需要 $O(n)$ 的空间。感兴趣的可以阅读 接雨水 - 力扣官方题解。 "},{"title":"Leetcode 39.组合总数","date":"2021-06-07T17:45:00.000Z","url":"/2021/06/08/Leetcode%2039.%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 示例 2： 提示： $1 &lt;= candidates.length &lt;= 30$ $1 &lt;= candidates[i] &lt;= 200$ candidate 中的每个元素都是独一无二的。 $1 &lt;= target &lt;= 500$ 链接： 题目分析&emsp;&emsp;题目要求所有的可行解，则依然可以使用回溯的方法来进行搜索遍历，也即对于每一个数 candidates[i]，都可以选择是否将其加入结果中，然后再转化为搜索 target-candidates[i] 的问题。为了避免产生重复解，我们按照 candidates 的顺序添加，也即若当前选择不添加 candidates[i]，则转化的子问题也不能再添加 candidates[i]。注意到题目中的数字可以无限制重复选取，则我们每次都需要保持从上一次添加的数字开始（也即上一次添加的数字仍然可以添加）。每当 target 为 0，意味着当前添加的数字的和为 target，也即找到了一组解，将其添加到结果列表中。&emsp;&emsp;而为了加快搜索速度，我们可以进行剪枝。比如我们可以先对 candidates 进行排序，当 target 已经小于当前想添加的数字时，也肯定小于后面所有的数字，则都不会是结果，则可以直接跳出循环返回。 &emsp;&emsp;时间复杂度：$O(S)$，$S$ 是可行解的长度之和。我们遍历了所有的可行解得到结果，而对于不可行的情况马上剪枝，则时间复杂度是可行解的长度之和。因为这道题确实比较难给出一个较紧密的上界。对于每个数字选或者不选，一共拥有非常多的可能，这是指数级别的。但是我们进行的剪枝可以排除掉非常多的情况，因此实际的运行情况不好以target 的大小或者是 candidates 的大小界定。&emsp;&emsp;空间复杂度：$O(target)$。作为结果返回的数组不计入所需空间中，而所有的数字都是正整数，则最大的可行解长度也就是 target 的值（全由 1 构成可行解），这也是我们栈递归的最大深度，因此空间复杂度为 $O(target)$。"},{"title":"Leetcode 34.在排序数组中查找元素的第一个和最后一个位置","date":"2021-06-07T17:06:00.000Z","url":"/2021/06/08/Leetcode%2034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 10^5$ $-10^9 &lt;= nums[i] &lt;= 10^9$ nums 是一个非递减数组 $-10^9 &lt;= target &lt;= 10^9$ 链接： 题目分析&emsp;&emsp;这个题目仍然可以使用二分查找的思路，但是由于我们要找到的是 target 值在数组中的开始位置和结束位置，则我们可以转变一下思路，变成寻找到小于 target 的最大数和大于 target 的最小数，则若还有数存在它们中间，那就是 target 了。下面给出的代码中，ansleft 表示小于 target 的最大数下标，ansright 表示大于 target 的最小数下标，这两个数允许超出数组的界限，也即可以为 -1 或者 nums.size()，这样可以应对 target 在数组边界的情况。我们先寻找 ansleft，再从 ansleft 的右边寻找 ansright，这样既缩小了搜索范围，又可以保证 ansright 大于 ansleft。注意最后返回结果之前检查一下夹在中间的值是不是 target 就可以了。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 33.搜索旋转排序数组","date":"2021-06-07T16:12:00.000Z","url":"/2021/06/08/Leetcode%2033.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ 示例 1： 示例 2： 示例 3： 提示： $1 &lt;= nums.length &lt;= 5000$ $-10^4 &lt;= nums[i] &lt;= 10^4$ nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 $-10^4 &lt;= target &lt;= 10^4$ 链接： 题目分析&emsp;&emsp;对于有序数组的搜索我们一般都是使用二分查找的方法，但是题目中的数组经过了一次旋转，只是局部有序，是否还仍然能使用二分查找的方法呢？答案是肯定的。通过观察我们可以发现，我们在任意位置将旋转后的数组分割为两个部分，则仍然可以保证至少其中一部分是有序的。判断是否有序只需要将该部分的头尾两个值进行比较即可，非常便捷。那么便有以下情况。&emsp;&emsp;左边有序，也即 nums[0] &lt;= nums[mid]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。&emsp;&emsp;右边有序，也即 nums[mid] &lt;= nums[n-1]。若 target 的值也在这个区间中，则只需在这个区间搜索；否则到另一个区间搜索。 &emsp;&emsp;时间复杂度：$O(\\log n)$，其中 $n$ 是数组的大小。因为我们是采用二分查找的方法得到结果的。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 32.最长有效括号","date":"2021-06-03T12:39:00.000Z","url":"/2021/06/03/Leetcode%2032.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= s.length &lt;= 3 * 10^4$ s[i] 为 &#39;(&#39; 或 &#39;)&#39; 链接： 题目分析1.动态规划&emsp;&emsp;我们用 dp[i] 表示以 s[i] 作为结尾的最长有效括号串长度。则可以得到以下性质，当 s[i] 为 ( 时，dp[i] = 0，这是因为有效的括号串一定是以右括号结尾的。而当 s[i] 为 ) 时最长有效括号串是怎么样的呢？&emsp;&emsp;假若 s[i-1] 为 (，则我们可以认为这个括号串是 dp[i-2] 的括号串加上了一个 ()，这样的括号串仍然是有效括号串，并且长度增加了2。即有 dp[i] = dp[i-2] + 2。&emsp;&emsp;假若 s[i-1] 为 )，则 s[i-1] 应该和 dp[i-1] 所表示的部分相匹配，如下图所示。而若 s[i] 能够匹配，则只能是匹配到 s[i-dp[i-1]-1] 为 (，与此同时，dp[i-dp[i-1]-2] 所表示的部分也能一并加入到有效括号串中。最后一共为 dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2。 &emsp;&emsp;而我们所要求的答案，便是 dp 数组中的最大值了。按照上面分析的状态转移公式遍历一次括号串即可。需要注意的是，以上的分析都是默认没有越界的情况，因此实际编写代码时均需要首先对这些下标是否存在进行判断。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为括号串的长度。因为我们只需要遍历一次字符串并更新 dp 数组即可得到结果。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 为括号串的长度。即为 dp 数组的大小。 2.括号计数&emsp;&emsp;通过观察我们可以发现，只要左括号和右括号的数量一致，并且右括号不先于未匹配的左括号出现，换句话说，就是从左往右遍历时，左括号数量总是大于等于右括号数量，这样的括号串一定是有效的，这是因为只存在一种括号。则我们可以只维护两个计数器，分别表示左括号和右括号的数量，从左往右遍历一次字符串，每次遇到左括号就将左括号计数加1；遇到右括号就将右括号计数加1，并且进行以下判断：①若右括号数量等于左括号，则这是有效的括号串，长度为左右括号数量之和。②若左括号数量小于右括号，则说明出现了无法匹配的右括号，此时需要将左右括号的计数都重置为0，也即抛弃之前的部分，重新进行匹配。&emsp;&emsp;而对于左括号始终多于右括号的情况，例子 (()，我们没有一种状态是左括号数量等于右括号。则我们从右往左遍历，用类似的方法，让左右括号的含义交换即可解决。&emsp;&emsp;注意左右括号数量不相等时是不能保证有效的，例子 ()(()，这个时候左括号数量 3，右括号数量 2，有效的括号串长度并不是 right*2=4。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为括号串的长度。因为我们只需要分别从左和从右遍历两次字符串并更新计数器即可得到结果。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量的空间。"},{"title":"Leetcode 31.下一个排列","date":"2021-06-02T10:31:00.000Z","url":"/2021/06/02/Leetcode%2031.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","tags":[["C++","/tags/C/"],["原地算法","/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"],["字典序","/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 100 链接： 题目分析&emsp;&emsp;首先我们要分析 “字典序” 中下一个排列是什么，下一个排列是比当前排列大的最小的排列。&emsp;&emsp;为了获取到比当前排列 “大” 的排列，则表明在从左往右数的某一位中，新排列的数字比原排列的大，而在此之前所有的数字均与原排列一样。由于越往右表示的权重越小，则为了使新排列尽可能的 “小”，我们应该令改变的数字尽可能地靠右。另一方面，改变的数字必须从原数字的右边选取，并且必须比原数字大。那么靠右的极限是什么？应该是后面的每个数的右边均不存在比自己小的数了，也即意味着，右边的数是降序排列（包含相同）的。我们只需要从数组最后往前找，找到第一个降序的数（不包含相同），这样就找到了需要换数字的某一位数（最右的降序排列反着找就是升序排列，而我们要找到第一个不符合的数），我们把这个下标记为 left。&emsp;&emsp;为了使新排列尽可能的小，我们需要换的数字也必须尽可能的小，因此我们需要在右边的降序排列中找到比 nums[left] 大，但是又尽可能地小的数。也即从数组最后往前找，找到第一个比 nums[left] 大的数（此时相当于是升序查找的，因此可以保证尽可能地小），我们把这个数记为 nums[right]。&emsp;&emsp;将 nums[right] 与 nums[left] 交换后，已经可以保证新排列比原排列大，为了使新排列尽可能地小，我们需要另 nums[left] 之后的序列变为升序序列，这样是最小的情况。而我们进行交换的时候，有 nums[right-1] &gt;= nums[right] &gt; nums[left] &gt;= nums[right+1]，则可以保证将 nums[left] 交换到 nums[right] 原本的位置后，右边的降序序列仍然是降序序列，则使用一个 reverse 函数将这部分反转为升序序列即可。同时的，这个函数是由双指针实现的，可以保证题目要求的原地修改。 &emsp;&emsp;对于题目中的边界情况有 ①原数组是降序排列（最大排列），这个时候寻找不到 nums[left]，也即寻找到的 left 值为 -1。而我们需要反转的区间原本应该是 left+1 ~ end，刚好 left 为 -1 时，反转区间从 0 开始，也即将整个数组进行反转，成为升序排列（最小排列），符合题意。②原数组只有一个数，这种情况其实等同于上一种情况，只是最大排列和最小排列是相同的，将其进行反转也不会改变什么，因此不需要进行单独处理。因此最后的代码如下。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 为数组的长度。因为我们只进行了两次扫描，一次反转操作，这些操作的时间复杂度均为 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要两个变量存放交换的数字位置，一个变量用于数组反转。"},{"title":"Leetcode 23.合并K个升序链表","date":"2021-06-02T08:40:00.000Z","url":"/2021/06/02/Leetcode%2023.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["分治","/tags/%E5%88%86%E6%B2%BB/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 示例 2： 示例 3： 提示： $k == lists.length$ $0 &lt;= k &lt;= 10^4$ $0 &lt;= lists[i].length &lt;= 500$ $-10^4 &lt;= lists[i][j] &lt;= 10^4$ $lists[i]$ 按 升序 排列 $lists[i].length$ 的总和不超过 $10^4$ 链接： 题目分析&emsp;&emsp;这道题是 Leetcode 21.合并两个有序链表 的升级版，原题链接以及相关题解都已经在这篇文章里面。 1. 顺序逐一合并&emsp;&emsp;根据我们对两个有序链表合并的思路，我们很容易想到，可以将其拆分成 k-1 个两链表合并的过程，逐一进行合并即可。代码中的 mergeTwoLists 函数即为合并两个有序链表的题解。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。这是由于对于每一次合并时间复杂度都是两个链表的长度和，而对于第 $i$ 次合并 lists[0] 的长度应该为 $i\\times n$，而 lists[i] 的长度为 $n$，一共需要合并 $k-1$ 次，则总的时间复杂度为 $O(\\sum^{k-1}_{i=1}(i+1)\\times n)=O(\\frac{(k+2)(k-1)}{2}\\times n)=O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。同两个链表合并，没有用到与 $k、n$ 规模相关的辅助空间。 2.分治合并&emsp;&emsp;从方法1中，我们可以发现，作为答案进行返回的 lists[0] 数组在每一次合并的时候都要遍历一次，这样的遍历是比较多余的，我们可以采用分治的思想进行优化。每一轮对每两条链表进行合并，得到 $\\frac{k}{2}$ 条链表，然后再继续合并得到 $\\frac{k}{4}$ 条链表，以此类推直到所有的链表合并完毕。下面所给的代码中已略去 mergeTwoLists 函数。 &emsp;&emsp;时间复杂度：$O(kn\\log k)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。对于第 $i$ 轮合并，每一条链表长度为 $2^{i-1}n$，则每一组合并的时间代价为 $O(2^in)$，一共有 $\\displaystyle\\frac{k}{2^i}$ 组。则总时间复杂度为 $O(\\sum^{\\infty}_{i=1}\\frac{k}{2^i}\\times2^in)=O(kn\\log k)$。&emsp;&emsp;空间复杂度：$O(\\log k)$，其中 $k$ 表示链表的数目。这是由于在分治合并中递归层数是 $\\log k$。 3.K个链表一起合并&emsp;&emsp;类似于合并两个链表的双指针思路，我们可以直接使用k个指针分别指向k条链表，每一次合并时进行比较并将最小的加入到答案链表中。实际上这是我第一个想到的解法，然而这样的方法每一次加入都需要进行比较，每一次比较都必须遍历k条链表（即便为空也进行判断），并且没有任何剪枝，时间复杂度是非常高的，最后以 952ms 的运行时间勉强通过了测例。&emsp;&emsp;代码中的 flag 表示了当前是否获得第一个非空链表的头结点，这个结点值作为每一轮比较的初值；当所有的链表都为空时也即合并完毕。 &emsp;&emsp;时间复杂度：$O(k^2n)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共有 $kn$ 个结点需要进行添加，而每一次添加都需要对 $k$ 个链表的头结点进行遍历比较得到最小值，因此时间复杂度为 $O(k^2n)$。&emsp;&emsp;空间复杂度：$O(1)$。对于每一次添加我们只需要维护两个变量分别记录最小值以及最小值所在的链表。 4.合并后排序再连接&emsp;&emsp;简单粗暴的解法，直接按顺序读取所有的结点到数组中存放，然后对整个数组进行排序，之后再逐一连接起来。出乎意料的是，这样的运行时间其实蛮快的。真是暴力而又省事的解法。 &emsp;&emsp;时间复杂度：$O(kn\\log(kn))$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。一共 $kn$ 个结点，将其逐一添加到数组中需要 $kn$ 的时间代价，而后进行排序我们认为是 $O(kn\\log(kn))$ 的，其实他们已经相对有序，相当于已经进行了一部分的分治排序，sort 函数底层如果有实现相对于的优化的话实际耗时是比较短的。最后重连接的时候也需要 $kn$ 的时间代价。&emsp;&emsp;空间复杂度：$O(kn)$，其中 $k、n$ 分别表示链表的数目和每个链表的长度。我们开辟了一个新的数组用来存放 $kn$ 个结点。"},{"title":"Leetcode 22.括号生成","date":"2021-05-24T05:49:00.000Z","url":"/2021/05/24/Leetcode%2022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 8 链接： 题目分析&emsp;&emsp;类似于 Leetcode 17.电话号码的字母组合，我们要获得所有的括号排列组合，则可以使用回溯的方法，维护一个字符串，每次加入一个左括号或者右括号，直到所有的括号添加完毕得到一个结果，再回溯删除，添加另外一种括号，如此穷举得到所有的结果。我们使用 n 来记录还未添加的左括号数目，使用 left 来记录还未匹配的左括号数目，则可以添加左括号的条件是 n &gt; 0，可以添加右括号的条件是 left &gt; 0，当 n == 0 &amp;&amp; left == 0 时表明所有的括号已经添加并且匹配完毕，则得到一种结果。 &emsp;&emsp;时间复杂度：$O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$，其中 $n$ 是需要生成的括号对数目。这是由于 generateParenthesis(n) 的数目是第 $n$ 个卡特兰数 $\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}$，而这个数字由 $\\displaystyle\\frac{4^n}{n\\sqrt{n}}$ 渐进界定。我们每得到一种结果，都需要耗费 $O(n)$ 的时间将其添加到答案数组中，因此总的时间复杂度为 $O(\\displaystyle\\frac{4^n}{n\\sqrt{n}}\\times n) = O(\\displaystyle\\frac{4^n}{\\sqrt{n}})$。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是需要生成的括号对数目。因为返回结果不计入空间开销，而其他开销主要取决于栈递归的层数，最大层数为 $2n$，每次递归调用的空间开销为 $O(1)$，因此空间复杂度为 $O(n)$。 &emsp;&emsp;PS：相关阅读：卡特兰数-百度百科"},{"title":"Leetcode 21.合并两个有序链表","date":"2021-05-23T17:42:00.000Z","url":"/2021/05/24/Leetcode%2021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 示例 2： 示例 3： 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 链接： 题目分析&emsp;&emsp;合并两个升序链表，只需要用两个指针分别遍历两个链表，每次将值小的那个结点添加到合并链表中即可。如果一个链表为空，则直接返回另一个链表（当两个都为空时返回的也是空）。当迭代到某一个链表为空之后，只需将另外一个链表剩下的部分接到最后即可。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别为两个链表的大小。因为我们最多只对两个链表进行了一次遍历便可以完成合并的操作。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。 官方题解&emsp;&emsp;思路与上面相同，但是我们可以使用一个哨兵结点 prehead 作为开头，这样就可以不用额外判断合并后的链表是以哪个链表作为头结点，从而代码可以合并到后面迭代的循环中，更为简洁。这里的 prev 相当于上面的 tail。 "},{"title":"Leetcode 20.有效的括号","date":"2021-05-23T17:07:00.000Z","url":"/2021/05/24/Leetcode%2020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $1 &lt;= s.length &lt;= 10^4$ s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 链接： 题目分析&emsp;&emsp;使用栈解决即可。遇到左括号入栈，遇到右括号判断当前栈顶元素是否是相匹配的括号，匹配则进行出栈，不匹配则直接返回 false。需要注意的是当栈为空时调用 top() 函数会出错，并且最后遍历完成之后若栈中还剩余有未匹配的左括号也说明结果为 false。 &emsp;&emsp;时间复杂度：$O(n)$，其中 $n$ 是括号串的长度。因为我们对该串进行了一次遍历。&emsp;&emsp;空间复杂度：$O(n)$，其中 $n$ 是括号串的长度。我们维护了一个栈存放未匹配的括号，这个栈的最大大小为 $n$。 官方题解&emsp;&emsp;官方题解也是同样用栈的思路，但是建立了一个哈希表进行匹配，代码显得漂亮一点。另外有一点是匹配的括号串一定是偶数个，如果括号串字符数为奇数则可以直接返回 false。 "},{"title":"Leetcode 19.删除链表的倒数第N个结点","date":"2021-05-23T16:30:00.000Z","url":"/2021/05/24/Leetcode%2019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 链接： 题目分析&emsp;&emsp;最简单的办法当然是先对链表进行一次遍历得到长度，然后再得到需要删除的结点位置，第二次遍历到该位置并进行删除，如此一共需要进行两趟扫描。但是如果我们采用前后双指针的做法，让前指针先走 $n$ 步，之后两个指针再一起前进，则当前指针到达链表末尾的时候，后指针就到了需要删除的位置，这样只进行一趟扫描就可以解决问题。&emsp;&emsp;由于删除链表结点的操作是令前置结点的 next 指向其后置结点，则实际上我们搜索到删除结点的前置结点就停下更方便删除，因此循环退出条件也变为前指针的 next 是否已经指向空而不是前指针本身为空。&emsp;&emsp;注意到，如果 $n$ 的值等于链表长度，也即需要删除的结点是头结点时，头结点没有前置结点，则直接返回头结点的后置结点即可。而这种情况下前指针走了 $n$ 步刚好为空，可以作为判断的条件。&emsp;&emsp;PS：代码中含有的注释部分是另一种写法，包括了释放删除结点的内存。 &emsp;&emsp;时间复杂度：$O(L)$，其中 $L$ 是链表的长度。我们总共对链表进行了一次遍历。&emsp;&emsp;空间复杂度：$O(1)$。只需要常数个指针进行遍历即可。"},{"title":"Leetcode 17.电话号码的字母组合","date":"2021-05-22T18:52:00.000Z","url":"/2021/05/23/Leetcode%2017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 示例 2： 示例 3： 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 链接： 题目分析&emsp;&emsp;题目要求返回所有的可能情况，则我们可以使用回溯的方法，维护一个字符串，不断将数字代表的字母加入到字符串中，得到一种结果后再进行回溯，删除加入的字母，将数字代表的另一个字母加入到字符串中，这样便可以穷举所有的可能结果。而数字与字母的对应关系可以使用一个哈希表解决。注意当输入的串为空串时，也要返回一个空的字符串数组作为结果。 &emsp;&emsp;时间复杂度：$O(3^m\\times4^n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，也即 2、3、4、5、6、8 数字的数量，$n$ 是输入中对应 4 个字母的数字个数，也即 7、9 数字的数量。这是因为我们需要遍历所有可能的字母组合。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m$ 是输入中对应 3 个字母的数字个数，$n$ 是输入中对应 4 个字母的数字个数。因为返回值不计入空间复杂度中，而其他开销还有哈希表和递归调用中的层数开销。哈希表大小是固定的，可以视为常数；而最大递归层数为 $m+n$。"},{"title":"Leetcode 15.三数之和","date":"2021-05-22T14:22:00.000Z","url":"/2021/05/22/Leetcode%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例 1： 示例 2： 示例 3： 提示： $0 &lt;= nums.length &lt;= 3000$ $-10^5 &lt;= nums[i] &lt;= 10^5$ 链接： 题目分析&emsp;&emsp;对于三个数字的和，我们可以拆分为一个数字和另外两个数字的和，这两个数的和等于另外一个数的相反数就可以让三个数的和为 0。而对于两数之和的问题，我们进行排序后便可以用双指针的思想，从两端向中间寻找从而降低复杂度。&emsp;&emsp;首先对整个数组进行排序。然后我们先确定第一个数的位置，并得到另外两个数的目标和 target，之后我们使用两个指针 left 和 right 分别初始化到剩下的数组两端，并计算他们的和，如果小于 target，则 left 往右移动，若大于 target，则 right 往左移动。每找到一组和为 target 的元组就和第一个数一起加入到结果数组中。&emsp;&emsp;需要注意的问题是，题目要求三元组不能重复。所以我们在进行遍历的时候，如果和前一个数相同，就跳过，继续往后寻找。而每次找到某个三元组之后，直接令 left 往右而 right 往左，因为他们不能再构成一组不重复的解了。因为第一个数字也是从左到右确定的，并且是三元组中的最小值，因此也不会造成重复。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是数组的长度。外层循环确定第一个数的位置，而内层循环中使用双指针搜索，一共只对剩下的数组进行了一次遍历，因此一共两层遍历，时间复杂度为 $O(n^2)$。&emsp;&emsp;空间复杂度：$O(\\log n)$ 或 $O(n)$，其中 $n$ 是数组的长度。一般计算空间复杂度的时候会忽略作为答案进行输出的空间。而我们需要对数组进行排序，如果传入的数组不允许更改，则我们需要复制一个副本进行排序，则需要 $O(n)$ 的空间。如果可以直接对原数组进行排序，则只需要额外的 $O(\\log n)$ 空间进行排序。"},{"title":"Leetcode 11.盛最多水的容器","date":"2021-05-22T13:08:00.000Z","url":"/2021/05/22/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你 $n$ 个非负整数 $a_1，a_2，…，a_n$，每个数代表坐标中的一个点 $(i, a_i)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$ 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $n = height.length$ $2 &lt;= n &lt;= 3 * 10^4$ $0 &lt;= height[i] &lt;= 3 * 10^4$ 链接： 题目分析1.暴力解法&emsp;&emsp;直接对数组进行双层遍历，两个变量分别表示容器的两边下标。那么水容量就是短边乘上容器宽，记录最大容量即可。不出意外，这样的算法超时了。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 2.暴力解法改进&emsp;&emsp;考虑到，如果我们遍历的时候，从两边往中间遍历，宽是不断变小的，如果边也在同时变小的话，那么肯定不是最大的容量，对于这样的情况是可以进行剪枝的。于是我们稍微修改了遍历的顺序，容器左壁从左边开始遍历，容器右壁从右边开始遍历。分别记录左右边最大值，小于这个值的情况就可以直接进行剪枝了。内层遍历结束后，我们需要将右壁的最大值归为 0 再进行下一个内层遍历。经过剪枝后刚好能够通过测试，并不优良，因为本质上还是双层遍历。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 表示数组大小。虽然经过剪枝，但本质上还是双层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。 3.双指针解法&emsp;&emsp;其实上面的暴力解法改进的思路已经非常接近双指针的思路了。上面的暴力解法都是先确定左壁再遍历右壁进行计算，但实际上，容器高只取决于短的那条边。那么如果我们还是从左右两边往中间遍历，是不是可以按照实际情况选择移动左壁还是右壁呢？实际上我们应该移动短的那边就可以了。因为进行移动的话，容器宽变小了，而容器高却还是取决于短边，移动长边不会增加还可能更少，因此一定不会使容量更大。而移动短边的话，可能提高了容器高的值，就可能使容量增大。所以我们实际上只需要进行一层遍历，两个指针开始时分别在数组两端表示两个容器壁，而后短边不断向对方移动，每次移动的时候判断容积是否变大，变大则更新结果，最后直到两个容器壁相遇则结束。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 表示数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量进行记录。"},{"title":"Leetcode 10.正则表达式匹配","date":"2021-05-22T11:46:00.000Z","url":"/2021/05/22/Leetcode%2010.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 &#39;.&#39; 匹配任意单个字符 &#39;*&#39; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。 示例 1： 示例 2: 示例 3： 示例 4： 示例 5： 提示： $0 &lt;= s.length &lt;= 20$ $0 &lt;= p.length &lt;= 30$ s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 链接： 题目分析&emsp;&emsp;对于字符串 s 和 p，我们是逐步匹配的。对于普通字符是一对一匹配，采用一个匹配函数判断即可，对于 . 匹配任意字符的情况也可以在这里得到解决。我们可以采用动态规划的思路，dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。注意 s 和 p 的下标都是从 0 开始的，因此 s 的第 i 个字符是 s[i-1]。那应该有以下的状态转移方程。 若 $p[j-1]\\neq *$ dp[i][j] = \\begin{cases} dp[i-1][j-1], & s[i-1] = p[j-1] \\\\ flase, & s[i-1]\\neq p[j-1] \\end{cases} &emsp;&emsp;而当出现了字符 * 时，表示我们可以对 p[j-1] 匹配任意次，也包括 0 次。这时候，我们可以分情况，如果是匹配 0 次，则相当于我们直接把 p[j] 和 p[j-1] 去掉。如果是匹配 1 次或多次，我们可以直接认为是匹配 1 次，然后将 s[i] 去掉，而 p[j] 和 p[j-1] 继续保留到下次匹配中。这样的话可以得到下面的状态转移方程。 若 $p[j-1]= *$ dp[i][j] = \\begin{cases} dp[i-1][j]\\quad or\\quad dp[i][j-2], & s[i-1] = p[j-2] \\\\ dp[i][j-2], & s[i-1]\\neq p[j-2] \\end{cases} &emsp;&emsp;我们最后的答案也即 dp[s.size()][p.size()]，也就是两个字符串完全匹配的结果。&emsp;&emsp;对于边界条件，我们规定 dp[0][0] = true，也即两个空串是匹配的。而由于 p 中可能开头就存在 a* 而匹配到 s 中空串的情况，i 需从 0 开始。另外代码中存在着一定的冗余，例如 p 中的 a* 必须视为一个整体，但是我们在逐步匹配中，首先直接让 a 进行了匹配，这样的匹配是多余的。但是对于这样的情况，在检查到 * 时，我们的状态转移和 dp[x][j-1] 完全没有关系，因此不对最后结果产生任何影响。 &emsp;&emsp;时间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。因为动态规划的状态总数是 $(m+1)*n$，而对于每个状态转移的时间复杂度是 $O(1)$。&emsp;&emsp;空间复杂度：$O(mn)$，其中 $m、n$ 分别表示字符串 s 和 p 的长度。即存储动态规划状态所需要的空间。"},{"title":"Leetcode 5.最长回文子串","date":"2021-05-22T09:41:00.000Z","url":"/2021/05/22/Leetcode%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 示例 2： 示例 3： 示例 4： 提示： $1 &lt;= s.length &lt;= 1000$ s 仅由数字和英文字母（大写和/或小写）组成 链接： 题目分析1.暴力遍历解法&emsp;&emsp;最容易想到的解法，就是分割每一个子串，并用函数判断这个子串是否是回文串，如果是则更新到结果中。对所有的子串进行判断会超时，我们可以进行稍微的改进，也就是只从比当前结果长的子串开始判断，因为比当前结果短的子串即使是回文串也不会是答案，这样可以节省大量的时间。 &emsp;&emsp;时间复杂度：$O(n^3)$，其中 $n$ 是字符串的长度。因为我们一共需要判断 $O(n^2)$ 个数的子串，而每个子串判断时间是 $O(n)$。&emsp;&emsp;空间复杂度：$O(1)$。进行判断时并没有真的分割出子串，只是对下标进行记录，一共需要常数个变量进行记录。 2.动态规划解法&emsp;&emsp;对于某一个子串，只需要满足它的首尾去掉是一个回文串，而首尾本身也是相同的字符，那么它也是一个回文串。也即有dp[left, right] = dp[left+1][right-1] &amp;&amp; s[left]==s[right]。其中 dp[left][right] 记录了由 s[left] 到 s[right] 的子串是一个回文串。需要注意的是，动态规划的转移方程是从短的子串向长的子串转移，则我们应该从短的字符串向长的字符串进行循环。而对于边界条件，子串字符个数为 1 时一定是一个回文串；子串字符个数为 2 时，两个字符相同时是一个回文串。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。因为动态规划的状态总数是 $O(n^2)$ ，而状态转移时间是 $O(1)$。&emsp;&emsp;空间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。即存储动态规划状态所需要的空间。 3.中心扩展解法&emsp;&emsp;类似于动态规划方法的状态转移思路，我们可以从某一个中心出发，向字符串两端不断扩展匹配是否是相同字符，这样可以得到某一个位置为中心时最大的回文子串长度，若比当前记录的长度更长则进行记录即可，反过来说，其实动态规划的边界情况也就是中心扩展解法的“回文中心”。而每次选择回文中心，有一个字符或者是两个字符的情况，我们要对其分别进行扩展。&emsp;&emsp;注意到我们进行扩展的子函数中循环是首先有对 s[left] 和 s[right] 是否相同进行判断的，这样字符个数为 1 时一定相同，而字符个数为 2 时是否相同也同时进行了判断，因此不必再单独判断字符为 2 时的边界情况。 &emsp;&emsp;时间复杂度：$O(n^2)$，其中 $n$ 是字符串的长度。我们一共需要扩展 $n$ 个长度为 1 的回文中心和 $n-1$ 个长度为 2 的回文中心，而对于每次扩展，最大长度为 $n/2$。因此总的时间复杂度为 $O((n+n-1)*n/2)=O(n^2)$。&emsp;&emsp;空间复杂度：$O(1)$。进行扩展时只需要进行判断并记录，一共需要常数个变量进行记录。"},{"title":"Leetcode 4.寻找两个正序数组的中位数","date":"2021-05-20T12:32:00.000Z","url":"/2021/05/20/Leetcode%204.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： $nums1.length == m$ $nums2.length == n$ $0 &lt;= m &lt;= 1000$ $0 &lt;= n &lt;= 1000$ $1 &lt;= m + n &lt;= 2000$ $-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6$ 链接： 题目分析1.合并数组解法&emsp;&emsp;由于这是两个已经有序的数组，很容易想到归并排序。也就是将两个数组合并成一个，然后再返回处在中间的数字即可。注意合并的时候要考虑某一个数组已经遍历完毕的情况，另外对于奇数个数字和偶数个数字，中位数的计算也不同。 &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为顺序遍历了两个数组进行合并，合并后返回中位数的过程是 $O(1)$ 的。&emsp;&emsp;空间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。因为开辟了一个新数组用来存放合并后的数组。 2.合并数组解法改进&emsp;&emsp;由于我们只需要寻找中位数，其实可以不用将真的将两个数组合并，只需要按顺序寻找到中位数就可以了。由于奇数和偶数计算中位数方式的不同，我们用变量 right 来记录当前第 cnt 小的数，而用 left 来记录上一个 right 也即第 cnt-1 小的数。遍历次数 cnt 为 $(m+n)/2+1$，这样当 $(m+n)$ 为奇数时，我们找到了第 $(m+n)/2+1$ 小的数也即中位数，返回 right；当 $(m+n)$ 为偶数时，left 是第 $(m+n)/2$ 小的数，right 是第 $(m+n)/2+1$ 小的数，中位数是这两个数的平均值，返回 (left+right)/2.0。（这也是变量命名的含义，中位数是左右两个数的平均值） &emsp;&emsp;时间复杂度：$O(m+n)$，其中 $m、n$ 分别是两个数组的大小。思路和上面一致，但是只需要遍历一半，因为我们只需要找到中位数就可以停止了。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对遍历结果进行记录。 3.二分查找解法&emsp;&emsp;由于数组都是有序的，而我们只需要找到处在中间的那个数，可以考虑用二分查找的方法加快搜索速度。一个思路是对于 nums1、nums2 两个数组，我们要寻找第 k 小的数，则每个数组都寻找第 k/2 个数，假设分别为 nums1[k/2-1] 和 nums2[k/2-1]，比较他们的大小。 若 nums1[k/2-1] &gt;= nums2[k/2-1]，则说明 nums2[k/2-1] 最多也只能比 nums1[0 ~ k/2-2] 和 nums2[0 ~ k/2-2] 都大，最多只有 $(k/2-1)+(k/2-1)=k-2$ 个数比它小，则它小于第 k 小的数，也即 nums2[0 ~ k/2-1] 都可以进行排除。 若 nums1[k/2-1] &lt; nums2[k/2-1]，则相应排除 nums1[0 ~ k/2-1]。 &emsp;&emsp;在剩下的数组中，我们就要找第 k-(k/2) 小的数了。如此二分排除下去就能够得到答案，我们可以采用循环的写法，依然将 k-(k/2) 当做下一个 k。这样的算法下，也有几种特殊情况。 数组中剩下的数字已经不够 k/2 个，这个时候，我们只需要选取数组最后一个数字作为比较对象，若进行排除则整个数组排除即可。当然，相应的，我们排除的数字个数可能就不再是 k/2，更新 k 值的时候需要注意。 如果一个数组已经全部排除，则说明中位数存在于另外一个数组中，我们直接返回另外一个数组中第 k 个数即可。 若 k 为 1，则到了循环的终点，我们返回两个数组中首元素值更小的那个数即可。 &emsp;&emsp;时间复杂度：$O(log(m+n))$，其中 $m、n$ 分别是两个数组的大小。因为初始 $k=(m+n)/2$ 或 $k=(m+n)/2+1$，而每一次搜索会将范围减半。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对搜索结果进行记录。 4.划分数组解法&emsp;&emsp;从另一个角度想，中位数其实就是将数组分割为两个相等长度的子集。而数组的长度我们是知道的，则每个子集的长度我们也是知道的。则我们在 i 处将 nums1 分割为两部分时，相应也就知道了在 nums2 中的哪一处分割为两部分，假设为 j。如果满足 nums1[i-1] &lt;= nums2[j] 且 nums1[i] &gt;= nums2[j-1]。即左半部分为 nums1[0 ~ i-1] 和 nums2[0 ~ j-1]，右半部分为 nums1[i ~ m-1] 和 nums2[j ~ n-1]。此时可以满足左边的所有值都小于右边，则中位数就找到了。这样我们只需要对其中某一个数组进行二分查找，时间复杂度会更低一些。 若 m+n 为偶数，则我们应该有 $i+j=m-i+n-j$。 中位数是 (max(nums1[i-1], nums2[j-1])+min(nums1[i], nums2[j]))/2。 若 m+n 为奇数，则我们应该有 $i+j=m-i+n-j+1$。（左半部分多一个数） 中位数是 max(nums1[i-1], nums2[j-1])。 根据上面两点可以得到 $j = \\lfloor\\frac{m+n+1}{2}\\rfloor-i$。 我们令 nums1 的长度小于 nums2 的长度，则可以保证 $j\\in[0,n]$。 如果 nums1 长度大于 nums2 则交换两个数组即可。 对于整个数组都存在某半部分的情况，我们可以令 nums1[-1]=nums2[-1]=INT_MIN，nums1[m]=nums2[n]=INT_MAX。这样不会对左半部分的最大值或者右半部分的最小值产生影响。 &emsp;&emsp;PS:：代码来自官方题解。 &emsp;&emsp;时间复杂度：$O(log(min(m,n)))$，其中 $m、n$ 分别是两个数组的大小。这是因为我们只对长度较小的那个数组进行了二分查找。&emsp;&emsp;空间复杂度：$O(1)$。我们只需要常数个变量对查找结果进行记录。"},{"title":"Leetcode 3.无重复字符的最长子串","date":"2021-05-19T09:41:00.000Z","url":"/2021/05/19/Leetcode%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 示例 2: 示例 3: 示例 4: 提示： $0 &lt;= s.length &lt;= 5 * 10^4$ $s$ 由英文字母、数字、符号和空格组成 链接： 题目分析&emsp;&emsp;由于题目要求寻找的子串是连续的，则我们可以使用滑动窗口的思想。也就是说，right 向右遍历添加字符进入窗口，而当添加的字符与窗口中已有字符重复时，我们将左边的字符移出窗口，直到字符不再重复。而我们维护这样一个窗口，若窗口是目前最大长度时，对这个长度进行记录即可。查找字符是否存在使用一个哈希表解决。注意字符串为空的情况直接返回 0。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是字符串的长度。滑动窗口的两头指针分别遍历了一次字符串。&emsp;&emsp;空间复杂度：$O(|\\Sigma|)$，$\\Sigma$ 是字符串中出现过的字符集，$|\\Sigma|$ 表示字符集的大小。因为我们需要维护字符串出现过的字符构成的哈希表。"},{"title":"Leetcode 2.两数相加","date":"2021-05-19T09:02:00.000Z","url":"/2021/05/19/Leetcode%202.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":[["C++","/tags/C/"],["迭代","/tags/%E8%BF%AD%E4%BB%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1： 示例2： 示例3： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 链接： 题目分析&emsp;&emsp;类似于大数加法，链表中的数字是逆序存储的，刚好就像我们列竖式计算的过程，直接将每一位相加，并将进位 carry 存储即可。结果中的某一位为 res[i] = (l1[i] + l2[i] + carry) % 10 而 carry = (l1[i] + l2[i] + carry) / 10。而对于不一样长的链表，我们只需认为短链表的结点值为 0。迭代遍历整个链表并将结果不断增加到结果链表中得到答案。需要注意的点是，若两个链表的所有结点都已经遍历完毕而仍然有进位，需要将进位也添加到结果链表中；对于链表的迭代，一定要先判断指针是否已经为空。 &emsp;&emsp;时间复杂度：$O(max(m,n))$，其中 $m、n$ 分别是两个链表的长度。因为只需遍历一次链表，而对于每个结点处理的时间开销为 $O(1)$。&emsp;&emsp;空间复杂度：$O(1)$。返回值不计入空间开销，而我们只需要一个变量存储进位值，无需其他额外开销。"},{"title":"Leetcode 1.两数之和","date":"2021-05-19T08:20:00.000Z","url":"/2021/05/19/Leetcode%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 示例 1： 示例 2： 示例 3： 提示： $2 &lt;= nums.length &lt;= 10^3$ $-10^9 &lt;= nums[i] &lt;= 10^9$ $-10^9 &lt;= target &lt;= 10^9$ 只会存在一个有效答案 链接： 题目分析1.暴力解法&emsp;&emsp;我们可以直接对数组进行双层遍历，对于整数 nums[i]，寻找数组中是否存在另外一个整数 nums[j] 使得他们的和为 target，如果存在则返回答案。当然，由于我们在寻找 nums[j] 时，位于 nums[i] 前面的元素已经和 nums[i] 匹配过，而且每个元素不能使用两次，因此向后寻找元素进行匹配即可。 &emsp;&emsp;时间复杂度：$O(n^2)$，$n$ 是数组元素数目。最坏情况下对任意两个元素都需进行比较。&emsp;&emsp;空间复杂度：$O(1)$。只需进行求和比较，无需额外的空间。 2.哈希表解法&emsp;&emsp;从暴力解法我们可以注意到，我们对查找的要求较高。如果能够快速找到 target-nums[i] 的数组下标，则可以较快完成目标。我们考虑使用 unordered_map 存放元素及其下标。依然是遍历整个数组，对于每个元素 nums[i]，查找 target-nums[i] 是否存在于哈希表中，如果有，则返回 target-nums[i] 的下标以及 i；如果没有，则将 nums[i] 的值和下标添加到哈希表中。&emsp;&emsp;对于重复元素，case1：有三个或以上，则说明这些重复元素并不构成解（因为只会存在一个有效答案），没有影响；case2：有两个，且为解，则只能两个重复元素的和刚好为 target（因为只会存在一个有效答案），对于这种情况，第二个重复元素并未进入哈希表就已经作为答案进行返回；case3：有两个，且不为解，没有影响。因此对于重复元素直接进行插入覆盖不会产生问题。 &emsp;&emsp;时间复杂度：$O(n)$，$n$ 是数组元素数目。只进行一次遍历，哈希表每次查找的时间复杂度为 $O(1)$。&emsp;&emsp;空间复杂度：$O(n)$，$n$ 是数组元素数目。主要为建立哈希表的开销。"},{"title":"C++华容道","date":"2019-07-25T16:00:00.000Z","url":"/2019/07/26/C++%E5%8D%8E%E5%AE%B9%E9%81%93/","tags":[["C++","/tags/C/"],["程序设计","/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"],["Project","/tags/Project/"]],"categories":[["Project","/categories/Project/"]],"content":"引言&emsp;&emsp;快乐的暑假就需要折腾来充实自己，折腾的第一项是自己写一些游戏，第一个project选择了华容道。 华容道 （中国民间智力游戏） &emsp;&emsp;华容道是古老的中国民间益智游戏，以其变化多端、百玩不厌的特点与魔方、独立钻石棋一起被国外智力专家并称为“智力游戏界的三个不可思议”。它与七巧板、九连环等中国传统益智玩具还有个代名词叫作“中国的难题”。据《资治通鉴》注释中说“从此道可至华容也”。华容道原是中国古代的一个地名，相传当年曹操曾经败走此地。由于当时的华容道是一片沼泽，所以曹操大军要割草填地，不少士兵更惨被活埋，惨烈非常。 &emsp;&emsp;通过移动各个棋子，帮助曹操从初始位置移到棋盘最下方中部，从出口逃走。不允许跨越棋子，还要设法用最少的步数把曹操移到出口。曹操逃出华容道的最大障碍是关羽，关羽立马华容道，一夫当关，万夫莫开。关羽与曹操当然是解开这一游戏的关键。四个刘备军兵是最灵活的，也最容易对付，如何发挥他们的作用也要充分考虑周全。“华容道”有一个带二十个小方格的棋盘，代表华容道。 --来源：百度百科 &emsp;&emsp;详见 华容道-百度百科 &emsp;&emsp;初步考虑使用打印字符来代表棋子。使用getch()函数来获取键盘输入，然后通过算法得出相应的棋子坐标变化，并重新打印。&emsp;&emsp;游戏中采用 wasd 进行移动，空格键切换选择状态。当状态为未锁定时，wasd 为切换人物；当状态为锁定时，wasd 为移动人物。 代码目录 color.h&emsp;&emsp;此段代码对输出流进行了重载，可以通过调用函数 cout &lt;&lt; red 直接将控制台输出颜色转变为红色，其他颜色同理。&emsp;&emsp;代码来源于CSDN，感谢。 piece.h&emsp;&emsp;首先定义一个piece类，表示棋子。&emsp;&emsp;其含有变量lx、ly、rx、ry，分别表示棋子的左上角横纵坐标以及右下角横纵坐标；变量status表示棋子的状态，0表示未选中状态，1表示选中状态，2表示锁定状态。代码如下。 &emsp;&emsp;2.0版本时加入了多个关卡，主要区别是棋子的初始位置不同。因此定义一个chapter类，表示一个关卡。变量name储存关卡名字，变量status表示选中/未选中状态。代码如下。 &emsp;&emsp;main.cpp 中的 main 函数定义了 chapter a[12]、piece hrd[10]，分别表示12个关卡和10枚棋子，并在各个函数中以指针形式进行通讯。 &emsp;&emsp;1.0版本选择的关卡是横刀立马，各棋子初状态如下： &emsp;&emsp;于是定义各棋子的编号如下： 棋子 张飞 曹操 马超 黄忠 关羽 赵云 兵1 兵2 兵3 兵4 编号 0 1 2 3 4 5 6 7 8 9 &emsp;&emsp;我们定义5×4棋盘中左上角的坐标为（0，0），以此得出棋盘上各位置的坐标。&emsp;&emsp;我们初定提供12个关卡，按照各关卡各棋子的初始坐标，我们可以按照如下代码定义两个结构体的初始化函数。其中 coordinatex、coordinatey 函数初始化的值均为左上角坐标。 &emsp;&emsp;我们设定初始选择的关卡是横刀立马，于是其变量status的值为true，初始状态的选择在曹操身上，于是hrd[1].status的值为1。&emsp;&emsp;值得一提的是，变量lx、ly、rx、ry存放的是在控制台打印的实际坐标，我们在控制打印棋盘的单位格子大小为3×6，于是可以看到四个变量初始化的代码块进行了相应的坐标换算。X、Y表示棋盘即墙体的初始打印位置（左上角），以方便棋盘的整体移动，为后续调整棋盘在控制台的位置提供了较大的便利。在这里我们可以直接在文件头部进行define，后续需移动整个棋盘时修改X、Y的值即可。 print.h&emsp;&emsp;需包含的头文件如下，同时仍然对X、Y进行定义。 &emsp;&emsp;首先我们有函数gotoxy，可以将运行窗口的光标移动到（x，y）的位置。调用此函数之后再进行打印可以实现在需要的位置打印。其中x为横向（列数），y为纵向（行数） &emsp;&emsp;该头文件的函数一览： &emsp;&emsp;函数 printTimes、changeColor 代码如下。设定未选择状态为白色，选择状态为蓝色，锁定状态为红色。 &emsp;&emsp;函数 printSelectionScreen、printchapter 代码如下。初始化关卡选择并进行打印。打印位置通过不断运行观察调整得到。 &emsp;&emsp;打印效果如图 &emsp;&emsp;函数 printMap、printWall 代码如下。 &emsp;&emsp;printWall 函数打印墙体效果如图。 &emsp;&emsp;函数 printpiece 代码如下。提供了打印各棋子的总接口。选择打印颜色也在此处完成。 &emsp;&emsp;函数 printZF 代码如下。在（x，y）处开始打印棋子，一行一行打印。（x，y）为左上角坐标。此处提供一个打印示例，其他各棋子的打印函数也大抵如此。 &emsp;&emsp;打印棋子初始状态及关卡名称后的效果如图。 &emsp;&emsp;函数 erasepiece 代码如下。提供了擦除各型号大小棋子的总接口。不同棋子对应各自大小的擦除函数。 &emsp;&emsp;示例擦除函数代码如下。在对应位置打印空格即可实现棋子的擦除。注意每格大小3×6（高×宽） &emsp;&emsp;至此，print.h 头文件已经完成。 control.h&emsp;&emsp;需包含的头文件有 conio.h 和 print.h 。其中 conio.h 头文件用于获取键盘输入。仍然对 X、Y 进行宏定义。&emsp;&emsp;该头文件所包含的函数一览： &emsp;&emsp;函数 choosecontrol 的代码如下。返回值为选择的关卡编号。可以利用此值进行棋盘初始化。 &emsp;&emsp;getch()函数为获取一次键盘输入。当输入wasd时，我们需要改变相应的关卡。以 case &#39;w&#39; 为例。 &emsp;&emsp;获取输入后我们对关卡状态进行更新，并且重新打印，体现在了游戏界面上。 &emsp;&emsp;函数 clickcontrol 代码如下。获取键盘输入并调用相应函数，作为总控制中心。&emsp;&emsp;返回值为 10000 时表示回到选择关卡界面，返回值为 10001 时表示当前关卡重新开始，返回值为 1 表示继续进行游戏。值得一提的是，down 函数是有 bool 返回值的，因为游戏胜利的最后一步一定是曹操从下方缺口逃出。因此 down 函数的返回值表示当前关卡通过与否。若通关返回 true，相应地 clickcontrol 函数返回 10086 。 &emsp;&emsp;函数 click 代码如下。通过循环不断调用 clickcontrol 函数，若需回到主界面，则返回 true （通关也是返回主界面），若需当前关卡重新开始，则返回 false 。当 clickcontrol 返回 10086 即关卡胜利时，我们可以知道游戏的最后一步一定是曹操出现在缺口上，于是可以重新打印曹操使曹操“越过棋盘”，并打印游戏通关恭喜字句，同时使用 getchar() 函数使游戏暂停。 &emsp;&emsp;游戏通关效果如图。 &emsp;&emsp;函数 space 代码如下。使用循环检测10枚棋子中处于选择/锁定状态的，切换其状态，并对其重新进行打印（颜色改变）。 &emsp;&emsp;函数 movejudge 代码如下。我们定义棋子的时候记录了其左上角及右下角。当棋子空间 judge 不与棋子 i 重合时，我们返回 true 。由于棋子占领的空间是矩形，因此未重合时，应该至少两个棋子占领的 x 范围或者 y 范围没有交集。 &emsp;&emsp;接下来看看 up 函数。 &emsp;&emsp;可以看到，核心难点即在于对于不同大小的棋子，我们该如何在切换棋子的时候，选择到尽可能符合认知的那枚棋子，而且还要保证所有的棋子都一定能被选择到。该程序还有不足之处便是只能选择严格在其正上方最靠近的棋子，若仍然不止一枚的话只会打印编号靠前的第一枚。如以下这种情况，关羽进行up操作，只会选择两个兵中编号靠前的那一个。 兵 兵 关羽 &emsp;&emsp;其他的 down、left、right 函数基本如上，只需改变相应的变量名和一些常量值，这里便不再赘述。&emsp;&emsp;此外，down 函数中增加了一行代码如下。当曹操到达这个位置（缺口上方）之后按下down时，曹操逃脱，游戏胜利，返回 true 。注意此行代码必须在处于低端格子直接返回之前，因为此时的曹操也同样是处于低端格子。 &emsp;&emsp;至此，control.h 完成。 main.cpp&emsp;&emsp;main.cpp 的代码如下。上面已经说到，click 的返回值为 true 时返回选择界面，返回值为 false 时重新打印关卡。在主函数中得到了体现。另外，主函数的另一个功能是声明了关卡和棋子，并以指针形式传入各函数进行相应操作。 &emsp;&emsp;至此便完成了所有的代码。 历程 v 0.5 &emsp;2019-7-20还没有想好用 wasd 进行切换人物的算法，于是先写出了一个用 space 换人，wasd 移动的版本，由于人物有10个之多，用 space 按照编号顺序切换人物显得非常僵硬，于是不算为第一个版本，算是一个未完成品吧。 v 1.0 &emsp;2019-7-21实现了 wasd 切换人物，空格切换选择/锁定状态，大大提高游戏操作的流畅性。 v 2.0 &emsp;2019-7-22加入了不同的关卡，因此对整套代码进行重构，使用较易理解的5×4坐标，便于后续关卡的加入。 win7版 &emsp;2019-7-23发现win7控制台打印的字符大小与win10不同，字符打印的方框没有重合。修改了打印函数即解决问题。 Future 考虑可以锁定时直接移动。因为移动的选择只有一个或两个。 五虎将只需满足大小为1×2，横竖并不是严格定义的。重构定义代码才能加入更多的关卡。 学习鼠标捕捉并采用鼠标操作。 重构后加入界面 下载&emsp;&emsp;采用photoshop为游戏制作了图标，文件已存放在 这里 。可自行下载并添加到工程中。 &emsp;&emsp;所有代码已经存放到  ，可自行下载查看。 写在最后&emsp;&emsp;很开心，考试月萌生的暑假要好好学习的想法在刚考完试浪完之后还是能开始实施（寒假的时候也有想法但是最终浪过去了）。写完这个项目的代码之后决定要写成博客于是又挖了新坑。花了好几天部署了博客，当然要好好感谢坎爷，基本是克隆了坎爷的博客然后再进行修改的。然后书写这个博客又花了两天，写出来和讲出来的区别还是很大的啊，markdown也是以前没怎么接触（其实以前在matrix上写题目说明用的就是markdown的格式，但是只写过一点点。而且当时也不知道那是什么），书写的确花了不少时间。不过经过这些天来的摸索以后应该就是轻车熟路了。&emsp;&emsp;回头想想，这几天接触学习了好多新东西啊。在路上总是好事。"},{"title":"Hello World","date":"2019-07-23T16:00:00.000Z","url":"/2019/07/24/helloworld/","tags":[["test","/tags/test/"]],"categories":[["Test","/categories/Test/"]],"content":"第一篇博客，作为测试。 那就按照惯例编写一个hello world吧。 试一试 $\\LaTeX$ 公式能不能正常显示 斐波那契数列通项公式：$a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]$ "}]