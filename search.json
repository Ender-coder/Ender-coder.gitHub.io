[{"title":"Hello World","date":"2021-05-26T07:39:52.763Z","url":"/2021/05/26/helloworld/","tags":[["test","/tags/test/"]],"categories":[["Test","/categories/Test/"]],"content":" 第一篇博客，作为测试。 那就按照惯例编写一个hello world吧。 试一试 LaTeX\\LaTeXLATE​X 公式能不能正常显示 斐波那契数列通项公式：an=15[(1+52)n−(1−52)n]a_n=\\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right]an​=5​1​[(21+5​​)n−(21−5​​)n] "},{"title":"Leetcode 22.括号生成","date":"2021-05-24T14:36:08.494Z","url":"/2021/05/24/Leetcode%2022.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 示例 2： 提示： 1 &lt;= n &lt;= 8 链接：  题目分析 类似于 Leetcode 17.电话号码的字母组合，我们要获得所有的括号排列组合，则可以使用回溯的方法，维护一个字符串，每次加入一个左括号或者右括号，直到所有的括号添加完毕得到一个结果，再回溯删除，添加另外一种括号，如此穷举得到所有的结果。我们使用 n 来记录还未添加的左括号数目，使用 left 来记录还未匹配的左括号数目，则可以添加左括号的条件是 n &gt; 0，可以添加右括号的条件是 left &gt; 0，当 n == 0 &amp;&amp; left == 0 时表明所有的括号已经添加并且匹配完毕，则得到一种结果。 时间复杂度：O(4nn)O(\\displaystyle\\frac{4^n}{\\sqrt{n}})O(n​4n​)，其中 nnn 是需要生成的括号对数目。这是由于 generateParenthesis(n) 的数目是第 nnn 个卡特兰数 1n+1(2nn)\\displaystyle\\frac{1}{n+1}\\begin{pmatrix}2n\\\\n\\end{pmatrix}n+11​(2nn​)，而这个数字由 4nnn\\displaystyle\\frac{4^n}{n\\sqrt{n}}nn​4n​ 渐进界定。我们每得到一种结果，都需要耗费 O(n)O(n)O(n) 的时间将其添加到答案数组中，因此总的时间复杂度为 O(4nnn×n)=O(4nn)O(\\displaystyle\\frac{4^n}{n\\sqrt{n}}\\times n) = O(\\displaystyle\\frac{4^n}{\\sqrt{n}})O(nn​4n​×n)=O(n​4n​)。 空间复杂度：O(n)O(n)O(n)，其中 nnn 是需要生成的括号对数目。因为返回结果不计入空间开销，而其他开销主要取决于栈递归的层数，最大层数为 2n2n2n，每次递归调用的空间开销为 O(1)O(1)O(1)，因此空间复杂度为 O(n)O(n)O(n)。 PS：相关阅读：卡特兰数-百度百科"},{"title":"Leetcode 21.合并两个有序链表","date":"2021-05-24T14:36:08.490Z","url":"/2021/05/24/Leetcode%2021.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 示例 2： 示例 3： 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 链接：  题目分析 合并两个升序链表，只需要用两个指针分别遍历两个链表，每次将值小的那个结点添加到合并链表中即可。如果一个链表为空，则直接返回另一个链表（当两个都为空时返回的也是空）。当迭代到某一个链表为空之后，只需将另外一个链表剩下的部分接到最后即可。 时间复杂度：O(m+n)O(m+n)O(m+n)，其中 m、nm、nm、n 分别为两个链表的大小。因为我们最多只对两个链表进行了一次遍历便可以完成合并的操作。 空间复杂度：O(1)O(1)O(1)。只需要常数个指针进行遍历即可。 官方题解 思路与上面相同，但是我们可以使用一个哨兵结点 prehead 作为开头，这样就可以不用额外判断合并后的链表是以哪个链表作为头结点，从而代码可以合并到后面迭代的循环中，更为简洁。这里的 prev 相当于上面的 tail。 "},{"title":"Leetcode 20.有效的括号","date":"2021-05-24T14:36:08.488Z","url":"/2021/05/24/Leetcode%2020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","tags":[["C++","/tags/C/"],["栈","/tags/%E6%A0%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： 1&lt;=s.length&lt;=1041 &lt;= s.length &lt;= 10^41&lt;=s.length&lt;=104 s 仅由括号 '()[]&#123;&#125;' 组成 链接：  题目分析 使用栈解决即可。遇到左括号入栈，遇到右括号判断当前栈顶元素是否是相匹配的括号，匹配则进行出栈，不匹配则直接返回 false。需要注意的是当栈为空时调用 top() 函数会出错，并且最后遍历完成之后若栈中还剩余有未匹配的左括号也说明结果为 false。 时间复杂度：O(n)O(n)O(n)，其中 nnn 是括号串的长度。因为我们对该串进行了一次遍历。 空间复杂度：O(n)O(n)O(n)，其中 nnn 是括号串的长度。我们维护了一个栈存放未匹配的括号，这个栈的最大大小为 nnn。 官方题解 官方题解也是同样用栈的思路，但是建立了一个哈希表进行匹配，代码显得漂亮一点。另外有一点是匹配的括号串一定是偶数个，如果括号串字符数为奇数则可以直接返回 false。 "},{"title":"Leetcode 19.删除链表的倒数第N个结点","date":"2021-05-24T14:36:08.484Z","url":"/2021/05/24/Leetcode%2019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","tags":[["C++","/tags/C/"],["快慢指针","/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 示例 2： 示例 3： 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 链接：  题目分析 最简单的办法当然是先对链表进行一次遍历得到长度，然后再得到需要删除的结点位置，第二次遍历到该位置并进行删除，如此一共需要进行两趟扫描。但是如果我们采用前后双指针的做法，让前指针先走 nnn 步，之后两个指针再一起前进，则当前指针到达链表末尾的时候，后指针就到了需要删除的位置，这样只进行一趟扫描就可以解决问题。 由于删除链表结点的操作是令前置结点的 next 指向其后置结点，则实际上我们搜索到删除结点的前置结点就停下更方便删除，因此循环退出条件也变为前指针的 next 是否已经指向空而不是前指针本身为空。 注意到，如果 nnn 的值等于链表长度，也即需要删除的结点是头结点时，头结点没有前置结点，则直接返回头结点的后置结点即可。而这种情况下前指针走了 nnn 步刚好为空，可以作为判断的条件。 PS：代码中含有的注释部分是另一种写法，包括了释放删除结点的内存。 时间复杂度：O(L)O(L)O(L)，其中 LLL 是链表的长度。我们总共对链表进行了一次遍历。 空间复杂度：O(1)O(1)O(1)。只需要常数个指针进行遍历即可。"},{"title":"Leetcode 17.电话号码的字母组合","date":"2021-05-24T14:36:08.481Z","url":"/2021/05/24/Leetcode%2017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","tags":[["C++","/tags/C/"],["回溯","/tags/%E5%9B%9E%E6%BA%AF/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 示例 2： 示例 3： 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 链接：  题目分析 题目要求返回所有的可能情况，则我们可以使用回溯的方法，维护一个字符串，不断将数字代表的字母加入到字符串中，得到一种结果后再进行回溯，删除加入的字母，将数字代表的另一个字母加入到字符串中，这样便可以穷举所有的可能结果。而数字与字母的对应关系可以使用一个哈希表解决。注意当输入的串为空串时，也要返回一个空的字符串数组作为结果。 时间复杂度：O(3m×4n)O(3^m\\times4^n)O(3m×4n)，其中 mmm 是输入中对应 3 个字母的数字个数，也即 2、3、4、5、6、8 数字的数量，nnn 是输入中对应 4 个字母的数字个数，也即 7、9 数字的数量。这是因为我们需要遍历所有可能的字母组合。 空间复杂度：O(m+n)O(m+n)O(m+n)，其中 mmm 是输入中对应 3 个字母的数字个数，nnn 是输入中对应 4 个字母的数字个数。因为返回值不计入空间复杂度中，而其他开销还有哈希表和递归调用中的层数开销。哈希表大小是固定的，可以视为常数；而最大递归层数为 m+nm+nm+n。"},{"title":"Leetcode 15.三数之和","date":"2021-05-24T14:36:08.476Z","url":"/2021/05/24/Leetcode%2015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 示例 2： 示例 3： 提示： 0&lt;=nums.length&lt;=30000 &lt;= nums.length &lt;= 30000&lt;=nums.length&lt;=3000 −105&lt;=nums[i]&lt;=105-10^5 &lt;= nums[i] &lt;= 10^5−105&lt;=nums[i]&lt;=105 链接：  题目分析 对于三个数字的和，我们可以拆分为一个数字和另外两个数字的和，这两个数的和等于另外一个数的相反数就可以让三个数的和为 0。而对于两数之和的问题，我们进行排序后便可以用双指针的思想，从两端向中间寻找从而降低复杂度。 首先对整个数组进行排序。然后我们先确定第一个数的位置，并得到另外两个数的目标和 target，之后我们使用两个指针 left 和 right 分别初始化到剩下的数组两端，并计算他们的和，如果小于 target，则 left 往右移动，若大于 target，则 right 往左移动。每找到一组和为 target 的元组就和第一个数一起加入到结果数组中。 需要注意的问题是，题目要求三元组不能重复。所以我们在进行遍历的时候，如果和前一个数相同，就跳过，继续往后寻找。而每次找到某个三元组之后，直接令 left 往右而 right 往左，因为他们不能再构成一组不重复的解了。因为第一个数字也是从左到右确定的，并且是三元组中的最小值，因此也不会造成重复。 时间复杂度：O(n2)O(n^2)O(n2)，其中 nnn 是数组的长度。外层循环确定第一个数的位置，而内层循环中使用双指针搜索，一共只对剩下的数组进行了一次遍历，因此一共两层遍历，时间复杂度为 O(n2)O(n^2)O(n2)。 空间复杂度：O(log⁡n)O(\\log n)O(logn) 或 O(n)O(n)O(n)，其中 nnn 是数组的长度。一般计算空间复杂度的时候会忽略作为答案进行输出的空间。而我们需要对数组进行排序，如果传入的数组不允许更改，则我们需要复制一个副本进行排序，则需要 O(n)O(n)O(n) 的空间。如果可以直接对原数组进行排序，则只需要额外的 O(log⁡n)O(\\log n)O(logn) 空间进行排序。"},{"title":"Leetcode 11.盛最多水的容器","date":"2021-05-24T14:36:08.472Z","url":"/2021/05/24/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","tags":[["C++","/tags/C/"],["双指针","/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你 nnn 个非负整数 a1，a2，...，ana_1，a_2，...，a_na1​，a2​，...，an​，每个数代表坐标中的一个点 (i, ai)(i, a_i)(i, ai​) 。在坐标内画 nnn 条垂直线，垂直线 iii 的两个端点分别为 (i, ai)(i, a_i)(i, ai​) 和 (i,0)(i, 0)(i,0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 示例 2： 示例 3： 示例 4： 提示： n=height.lengthn = height.lengthn=height.length 2&lt;=n&lt;=3∗1042 &lt;= n &lt;= 3 * 10^42&lt;=n&lt;=3∗104 0&lt;=height[i]&lt;=3∗1040 &lt;= height[i] &lt;= 3 * 10^40&lt;=height[i]&lt;=3∗104 链接：  题目分析 1.暴力解法 直接对数组进行双层遍历，两个变量分别表示容器的两边下标。那么水容量就是短边乘上容器宽，记录最大容量即可。不出意外，这样的算法超时了。 时间复杂度：O(n2)O(n^2)O(n2)，nnn 表示数组大小。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量进行记录。 2.暴力解法改进 考虑到，如果我们遍历的时候，从两边往中间遍历，宽是不断变小的，如果边也在同时变小的话，那么肯定不是最大的容量，对于这样的情况是可以进行剪枝的。于是我们稍微修改了遍历的顺序，容器左壁从左边开始遍历，容器右壁从右边开始遍历。分别记录左右边最大值，小于这个值的情况就可以直接进行剪枝了。内层遍历结束后，我们需要将右壁的最大值归为 0 再进行下一个内层遍历。经过剪枝后刚好能够通过测试，并不优良，因为本质上还是双层遍历。 时间复杂度：O(n2)O(n^2)O(n2)，nnn 表示数组大小。虽然经过剪枝，但本质上还是双层遍历。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量进行记录。 3.双指针解法 其实上面的暴力解法改进的思路已经非常接近双指针的思路了。上面的暴力解法都是先确定左壁再遍历右壁进行计算，但实际上，容器高只取决于短的那条边。那么如果我们还是从左右两边往中间遍历，是不是可以按照实际情况选择移动左壁还是右壁呢？实际上我们应该移动短的那边就可以了。因为将进行移动的话，容器宽变小了，而容器高却还是取决于短边，移动长边不会增加还可能更少，因此一定不会使容量更大。而移动短边的话，可能提高了容器高的值，就可能使容量增大。所以我们实际上只需要进行一层遍历，两个指针开始时分别在数组两端表示两个容器壁，而后短边不断向对方移动，每次移动的时候判断容积是否变大，变大则更新结果，最后直到两个容器壁相遇则结束。 时间复杂度：O(n)O(n)O(n)，nnn 表示数组大小。两个指针从左右两端开始遍历直到相遇，总共只对数组进行了一层遍历。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量进行记录。"},{"title":"Leetcode 10.正则表达式匹配","date":"2021-05-24T14:36:08.468Z","url":"/2021/05/24/Leetcode%2010.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。 示例 1： 示例 2: 示例 3： 示例 4： 示例 5： 提示： 0&lt;=s.length &lt;=200 &lt;= s.length &lt;= 200&lt;=s.length &lt;=20 0&lt;=p.length &lt;=300 &lt;= p.length &lt;= 300&lt;=p.length &lt;=30 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 链接：  题目分析 对于字符串 s 和 p，我们是逐步匹配的。对于普通字符是一对一匹配，采用一个匹配函数判断即可，对于 . 匹配任意字符的情况也可以在这里得到解决。我们可以采用动态规划的思路，dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配。注意 s 和 p 的下标都是从 0 开始的，因此 s 的第 i 个字符是 s[i-1]。那应该有以下的状态转移方程。 若 p[j−1]≠∗p[j-1]\\neq *p[j−1]​=∗ dp[i][j]={dp[i−1][j−1],s[i−1]=p[j−1]flase,s[i−1]≠p[j−1]dp[i][j] = \\begin{cases} dp[i-1][j-1], &amp; s[i-1] = p[j-1] \\\\ flase, &amp; s[i-1]\\neq p[j-1] \\end{cases} dp[i][j]={dp[i−1][j−1],flase,​s[i−1]=p[j−1]s[i−1]​=p[j−1]​ 而当出现了字符 * 时，表示我们可以对 p[j-1] 匹配任意次，也包括 0 次。这时候，我们可以分情况，如果是匹配 0 次，则相当于我们直接把 p[j] 和 p[j-1] 去掉。如果是匹配 1 次或多次，我们可以直接认为是匹配 1 次，然后将 s[i] 去掉，而 p[j] 和 p[j-1] 继续保留到下次匹配中。这样的话可以得到下面的状态转移方程。 若 p[j−1]=∗p[j-1]= *p[j−1]=∗ dp[i][j]={dp[i−1][j]ordp[i][j−2],s[i−1]=p[j−2]dp[i][j−2],s[i−1]≠p[j−2]dp[i][j] = \\begin{cases} dp[i-1][j]\\quad or\\quad dp[i][j-2], &amp; s[i-1] = p[j-2] \\\\ dp[i][j-2], &amp; s[i-1]\\neq p[j-2] \\end{cases} dp[i][j]={dp[i−1][j]ordp[i][j−2],dp[i][j−2],​s[i−1]=p[j−2]s[i−1]​=p[j−2]​ 我们最后的答案也即 dp[s.size()][p.size()]，也就是两个字符串完全匹配的结果。 对于边界条件，我们规定 dp[0][0] = true，也即两个空串是匹配的。而由于 p 中可能开头就存在 a* 而匹配到 s 中空串的情况，i 需从 0 开始。另外代码中存在着一定的冗余，例如 p 中的 a* 必须视为一个整体，但是我们在逐步匹配中，首先直接让 a 进行了匹配，这样的匹配是多余的。但是对于这样的情况，在检查到 * 时，我们的状态转移和 dp[x][j-1] 完全没有关系，因此不对最后结果产生任何影响。 时间复杂度：O(mn)O(mn)O(mn)，其中 m、nm、nm、n 分别表示字符串 s 和 p 的长度。因为动态规划的状态总数是 (m+1)∗n(m+1)*n(m+1)∗n，而对于每个状态转移的时间复杂度是 O(1)O(1)O(1)。 空间复杂度：O(mn)O(mn)O(mn)，其中 m、nm、nm、n 分别表示字符串 s 和 p 的长度。即存储动态规划状态所需要的空间。"},{"title":"Leetcode 5.最长回文子串","date":"2021-05-24T14:36:08.465Z","url":"/2021/05/24/Leetcode%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 1&lt;=s.length&lt;=10001 &lt;= s.length &lt;= 10001&lt;=s.length&lt;=1000 s 仅由数字和英文字母（大写和/或小写）组成 链接：  题目分析 1.暴力遍历解法 最容易想到的解法，就是分割每一个子串，并用函数判断这个子串是否是回文串，如果是则更新到结果中。对所有的子串进行判断会超时，我们可以进行稍微的改进，也就是只从比当前结果长的子串开始判断，因为比当前结果短的子串即使是回文串也不会是答案，这样可以节省大量的时间。 时间复杂度：O(n3)O(n^3)O(n3)，其中 nnn 是字符串的长度。因为我们一共需要判断 O(n2)O(n^2)O(n2) 个数的子串，而每个子串判断时间是 O(n)O(n)O(n)。 空间复杂度：O(1)O(1)O(1)。进行判断时并没有真的分割出子串，只是对下标进行记录，一共需要常数个变量进行记录。 2.动态规划解法 对于某一个子串，只需要满足它的首尾去掉是一个回文串，而首尾本身也是相同的字符，那么它也是一个回文串。也即有dp[left, right] = dp[left+1][right-1] &amp;&amp; s[left]==s[right]。其中 dp[left][right] 记录了由 s[left] 到 s[right] 的子串是一个回文串。需要注意的是，动态规划的转移方程是从短的子串向长的子串转移，则我们应该从短的字符串向长的字符串进行循环。而对于边界条件，子串字符个数为 1 时一定是一个回文串；子串字符个数为 2 时，两个字符相同时是一个回文串。 时间复杂度：O(n2)O(n^2)O(n2)，其中 nnn 是字符串的长度。因为动态规划的状态总数是 O(n2)O(n^2)O(n2) ，而状态转移时间是 O(1)O(1)O(1)。 空间复杂度：O(n2)O(n^2)O(n2)，其中 nnn 是字符串的长度。即存储动态规划状态所需要的空间。 3.中心扩展解法 类似于动态规划方法的状态转移思路，我们可以从某一个中心出发，向字符串两端不断扩展匹配是否是相同字符，这样可以得到某一个位置为中心时最大的回文子串长度，若比当前记录的长度更长则进行记录即可，反过来说，其实动态规划的边界情况也就是中心扩展解法的“回文中心”。而每次选择回文中心，有一个字符或者是两个字符的情况，我们要对其分别进行扩展。 注意到我们进行扩展的子函数中循环是首先有对 s[left] 和 s[right] 是否相同进行判断的，这样字符个数为 1 时一定相同，而字符个数为 2 时是否相同也同时进行了判断，因此不必再单独判断字符为 2 时的边界情况。 时间复杂度：O(n2)O(n^2)O(n2)，其中 nnn 是字符串的长度。我们一共需要扩展 nnn 个长度为 1 的回文中心和 n−1n-1n−1 个长度为 2 的回文中心，而对于每次扩展，最大长度为 n/2n/2n/2。因此总的时间复杂度为 O((n+n−1)∗n/2)=O(n2)O((n+n-1)*n/2)=O(n^2)O((n+n−1)∗n/2)=O(n2)。 空间复杂度：O(1)O(1)O(1)。进行扩展时只需要进行判断并记录，一共需要常数个变量进行记录。"},{"title":"Leetcode 4.寻找两个正序数组的中位数","date":"2021-05-24T14:36:08.460Z","url":"/2021/05/24/Leetcode%204.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","tags":[["C++","/tags/C/"],["二分查找","/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 示例 2： 示例 3： 示例 4： 示例 5： 提示： nums1.length==mnums1.length == mnums1.length==m nums2.length==nnums2.length == nnums2.length==n 0&lt;=m&lt;=10000 &lt;= m &lt;= 10000&lt;=m&lt;=1000 0&lt;=n&lt;=10000 &lt;= n &lt;= 10000&lt;=n&lt;=1000 1&lt;=m+n&lt;=20001 &lt;= m + n &lt;= 20001&lt;=m+n&lt;=2000 −106&lt;=nums1[i],nums2[i]&lt;=106-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6−106&lt;=nums1[i],nums2[i]&lt;=106 链接：  题目分析 1.合并数组解法 由于这是两个已经有序的数组，很容易想到归并排序。也就是将两个数组合并成一个，然后再返回处在中间的数字即可。注意合并的时候要考虑某一个数组已经遍历完毕的情况，另外对于奇数个数字和偶数个数字，中位数的计算也不同。 时间复杂度：O(m+n)O(m+n)O(m+n)，其中 m、nm、nm、n 分别是两个数组的大小。因为顺序遍历了两个数组进行合并，合并后返回中位数的过程是 O(1)O(1)O(1) 的。 空间复杂度：O(m+n)O(m+n)O(m+n)，其中 m、nm、nm、n 分别是两个数组的大小。因为开辟了一个新数组用来存放合并后的数组。 2.合并数组解法改进 由于我们只需要寻找中位数，其实可以不用将真的将两个数组合并，只需要按顺序寻找到中位数就可以了。由于奇数和偶数计算中位数方式的不同，我们用变量 right 来记录当前第 cnt 小的数，而用 left 来记录上一个 right 也即第 cnt-1 小的数。遍历次数 cnt 为 (m+n)/2+1(m+n)/2+1(m+n)/2+1，这样当 (m+n)(m+n)(m+n) 为奇数时，我们找到了第 (m+n)/2+1(m+n)/2+1(m+n)/2+1 小的数也即中位数，返回 right；当 (m+n)(m+n)(m+n) 为偶数时，left 是第 (m+n)/2(m+n)/2(m+n)/2 小的数，right 是第 (m+n)/2+1(m+n)/2+1(m+n)/2+1 小的数，中位数是这两个数的平均值，返回 (left+right)/2.0。（这也是变量命名的含义，中位数是左右两个数的平均值） 时间复杂度：O(m+n)O(m+n)O(m+n)，其中 m、nm、nm、n 分别是两个数组的大小。思路和上面一致，但是只需要遍历一半，因为我们只需要找到中位数就可以停止了。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量对遍历结果进行记录。 3.二分查找解法 由于数组都是有序的，而我们只需要找到处在中间的那个数，可以考虑用二分查找的方法加快搜索速度。一个思路是对于 nums1、nums2 两个数组，我们要寻找第 k 小的数，则每个数组都寻找第 k/2 个数，假设分别为 nums1[k/2-1] 和 nums2[k/2-1]，比较他们的大小。 若 nums1[k/2-1] &gt;= nums2[k/2-1]，则说明 nums2[k/2-1] 最多也只能比 nums1[0 ~ k/2-2] 和 nums2[0 ~ k/2-2] 都大，最多只有 (k/2−1)+(k/2−1)=k−2(k/2-1)+(k/2-1)=k-2(k/2−1)+(k/2−1)=k−2 个数比它小，则它小于第 k 小的数，也即 nums2[0 ~ k/2-1] 都可以进行排除。 若 nums1[k/2-1] &lt; nums2[k/2-1]，则相应排除 nums1[0 ~ k/2-1]。 在剩下的数组中，我们就要找第 k-(k/2) 小的数了。如此二分排除下去就能够得到答案，我们可以采用循环的写法，依然将 k-(k/2) 当做下一个 k。这样的算法下，也有几种特殊情况。 数组中剩下的数字已经不够 k/2 个，这个时候，我们只需要选取数组最后一个数字作为比较对象，若进行排除则整个数组排除即可。当然，相应的，我们排除的数字个数可能就不再是 k/2，更新 k 值的时候需要注意。 如果一个数组已经全部排除，则说明中位数存在于另外一个数组中，我们直接返回另外一个数组中第 k 个数即可。 若 k 为 1，则到了循环的终点，我们返回两个数组中首元素值更小的那个数即可。 时间复杂度：O(log(m+n))O(log(m+n))O(log(m+n))，其中 m、nm、nm、n 分别是两个数组的大小。因为初始 k=(m+n)/2k=(m+n)/2k=(m+n)/2 或 k=(m+n)/2+1k=(m+n)/2+1k=(m+n)/2+1，而每一次搜索会将范围减半。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量对搜索结果进行记录。 4.划分数组解法 从另一个角度想，中位数其实就是将数组分割为两个相等长度的子集。而数组的长度我们是知道的，则每个子集的长度我们也是知道的。则我们在 i 处将 nums1 分割为两部分时，相应也就知道了在 nums2 中的哪一处分割为两部分，假设为 j。如果满足 nums1[i-1] &lt;= nums2[j] 且 nums1[i] &gt;= nums2[j-1]。即左半部分为 nums1[0 ~ i-1] 和 nums2[0 ~ j-1]，右半部分为 nums1[i ~ m-1] 和 nums2[j ~ n-1]。此时可以满足左边的所有值都小于右边，则中位数就找到了。这样我们只需要对其中某一个数组进行二分查找，时间复杂度会更低一些。 若 m+n 为偶数，则我们应该有 i+j=m−i+n−ji+j=m-i+n-ji+j=m−i+n−j。 中位数是 (max(nums1[i-1], nums2[j-1])+min(nums1[i], nums2[j]))/2。 若 m+n 为奇数，则我们应该有 i+j=m−i+n−j+1i+j=m-i+n-j+1i+j=m−i+n−j+1。（左半部分多一个数） 中位数是 max(nums1[i-1], nums2[j-1])。 根据上面两点可以得到 j=⌊m+n+12⌋−ij = \\lfloor\\frac{m+n+1}{2}\\rfloor-ij=⌊2m+n+1​⌋−i。 我们令 nums1 的长度小于 nums2 的长度，则可以保证 j∈[0,n]j\\in[0,n]j∈[0,n]。 如果 nums1 长度大于 nums2 则交换两个数组即可。 对于整个数组都存在某半部分的情况，我们可以令 nums1[-1]=nums2[-1]=INT_MIN，nums1[m]=nums2[n]=INT_MAX。这样不会对左半部分的最大值或者右半部分的最小值产生影响。 PS:：代码来自官方题解。 时间复杂度：O(log(min(m,n)))O(log(min(m,n)))O(log(min(m,n)))，其中 m、nm、nm、n 分别是两个数组的大小。这是因为我们只对长度较小的那个数组进行了二分查找。 空间复杂度：O(1)O(1)O(1)。我们只需要常数个变量对查找结果进行记录。"},{"title":"Leetcode 3.无重复字符的最长子串","date":"2021-05-24T14:36:08.446Z","url":"/2021/05/24/Leetcode%203.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":[["C++","/tags/C/"],["滑动窗口","/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 示例 2: 示例 3: 示例 4: 提示： 0&lt;=s.length&lt;=5∗1040 &lt;= s.length &lt;= 5 * 10^40&lt;=s.length&lt;=5∗104 sss 由英文字母、数字、符号和空格组成 链接：  题目分析 由于题目要求寻找的子串是连续的，则我们可以使用滑动窗口的思想。也就是说，right 向右遍历添加字符进入窗口，而当添加的字符与窗口中已有字符重复时，我们将左边的字符移出窗口，直到字符不再重复。而我们维护这样一个窗口，若窗口是目前最大长度时，对这个长度进行记录即可。查找字符是否存在使用一个哈希表解决。注意字符串为空的情况直接返回 0。 时间复杂度：O(n)O(n)O(n)，nnn 是字符串的长度。滑动窗口的两头指针分别遍历了一次字符串。 空间复杂度：O(∣Σ∣)O(|\\Sigma|)O(∣Σ∣)，Σ\\SigmaΣ 是字符串中出现过的字符集，∣Σ∣|\\Sigma|∣Σ∣ 表示字符集的大小。因为我们需要维护字符串出现过的字符构成的哈希表。"},{"title":"Leetcode 2.两数相加","date":"2021-05-24T14:36:08.435Z","url":"/2021/05/24/Leetcode%202.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":[["C++","/tags/C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例1： 示例2： 示例3： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 链接：  题目分析 类似于大数加法，链表中的数字是逆序存储的，刚好就像我们列竖式计算的过程，直接将每一位相加，并将进位 carry 存储即可。结果中的某一位为 res[i] = (l1[i] + l2[i] + carry) % 10 而 carry = (l1[i] + l2[i] + carry) / 10。而对于不一样长的链表，我们只需认为短链表的结点值为 0。迭代遍历整个链表并将结果不断增加到结果链表中得到答案。需要注意的点是，若两个链表的所有结点都已经遍历完毕而仍然有进位，需要将进位也添加到结果链表中；对于链表的迭代，一定要先判断指针是否已经为空。 时间复杂度：O(max(m,n))O(max(m,n))O(max(m,n))，其中 m、nm、nm、n 分别是两个链表的长度。因为只需遍历一次链表，而对于每个结点处理的时间开销为 O(1)O(1)O(1)。 空间复杂度：O(1)O(1)O(1)。返回值不计入空间开销，而我们只需要一个变量存储进位值，无需其他额外开销。"},{"title":"Leetcode 1.两数之和","date":"2021-05-24T14:36:08.432Z","url":"/2021/05/24/Leetcode%201.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":[["C++","/tags/C/"],["哈希","/tags/%E5%93%88%E5%B8%8C/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":" 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 示例 2： 示例 3： 提示： 2&lt;=nums.length&lt;=1032 &lt;= nums.length &lt;= 10^32&lt;=nums.length&lt;=103 −109&lt;=nums[i]&lt;=109-10^9 &lt;= nums[i] &lt;= 10^9−109&lt;=nums[i]&lt;=109 −109&lt;=target&lt;=109-10^9 &lt;= target &lt;= 10^9−109&lt;=target&lt;=109 只会存在一个有效答案 链接：  题目分析 1.暴力解法 我们可以直接对数组进行双层遍历，对于整数 nums[i]，寻找数组中是否存在另外一个整数 nums[j] 使得他们的和为 target，如果存在则返回答案。当然，由于我们在寻找 nums[j] 时，位于 nums[i] 前面的元素已经和 nums[i] 匹配过，而且每个元素不能使用两次，因此向后寻找元素进行匹配即可。 时间复杂度：O(n2)O(n^2)O(n2)，nnn 是数组元素数目。最坏情况下对任意两个元素都需进行比较。 空间复杂度：O(1)O(1)O(1)。只需进行求和比较，无需额外的空间。 2.哈希表解法 从暴力解法我们可以注意到，我们对查找的要求较高。如果能够快速找到 target-nums[i] 的数组下标，则可以较快完成目标。我们考虑使用 unordered_map 存放元素及其下标。依然是遍历整个数组，对于每个元素 nums[i]，查找 target-nums[i] 是否存在于哈希表中，如果有，则返回 target-nums[i] 的下标以及 i；如果没有，则将 nums[i] 的值和下标添加到哈希表中。 对于重复元素，case1：有三个或以上，则说明这些重复元素并不构成解（因为只会存在一个有效答案），没有影响；case2：有两个，且为解，则只能两个重复元素的和刚好为 target（因为只会存在一个有效答案），对于这种情况，第二个重复元素并未进入哈希表就已经作为答案进行返回；case3：有两个，且不为解，没有影响。因此对于重复元素直接进行插入覆盖不会产生问题。 时间复杂度：O(n)O(n)O(n)，nnn 是数组元素数目。只进行一次遍历，哈希表每次查找的时间复杂度为O(1)O(1)O(1)。 空间复杂度：O(n)O(n)O(n)，nnn 是数组元素数目。主要为建立哈希表的开销。"}]